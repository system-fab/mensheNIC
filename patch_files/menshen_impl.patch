diff -ruN '--exclude=.git' '--exclude=p4c' '--exclude=tb' menshen/action/action_engine.v parametric_menshen/action/action_engine.v
--- menshen/action/action_engine.v
+++ parametric_menshen/action/action_engine.v
@@ -88,7 +88,8 @@
 reg							page_tbl_out_valid, page_tbl_out_valid_next;
 // reg							page_tbl_out_valid_d1;
 // output from ram
-wire [15:0]					page_tbl_out;
+reg [15:0]					page_tbl_out;
+wire [15:0]                 page_tbl_out_r;
 // reg [15:0]					page_tbl_out_d1;
 
 /********intermediate variables declared here********/
@@ -100,30 +101,16 @@
 wire [255:0]				output_md;
 
 
-reg [PHV_LEN-1:0]	phv_out_r;
-reg					phv_valid_out_r;
-
-always @(*) begin
-
-	phv_out_r = phv_out;
-	phv_valid_out_r = 0;
-
-	if (phv_valid_bit) begin
-		phv_valid_out_r = 1;
-		phv_out_r = {output_6B[7], output_6B[6], output_6B[5], output_6B[4], output_6B[3], output_6B[2], output_6B[1], output_6B[0],
-				output_4B[7], output_4B[6], output_4B[5], output_4B[4], output_4B[3], output_4B[2], output_4B[1], output_4B[0],
-				output_2B[7], output_2B[6], output_2B[5], output_2B[4], output_2B[3], output_2B[2], output_2B[1], output_2B[0], output_md};
-	end
-end
-
 always @(posedge clk) begin
 	if (~rst_n) begin
 		phv_out <= 0;
 		phv_valid_out <= 0;
 	end
 	else begin
-		phv_out <= phv_out_r;
-		phv_valid_out <= phv_valid_out_r;
+		phv_out <= {output_6B[7], output_6B[6], output_6B[5], output_6B[4], output_6B[3], output_6B[2], output_6B[1], output_6B[0],
+				    output_4B[7], output_4B[6], output_4B[5], output_4B[4], output_4B[3], output_4B[2], output_4B[1], output_4B[0],
+    				output_2B[7], output_2B[6], output_2B[5], output_2B[4], output_2B[3], output_2B[2], output_2B[1], output_2B[0], output_md};
+		phv_valid_out <= phv_valid_bit;
 	end
 end
 
@@ -133,7 +120,6 @@
 				EMPTY_1=1,
 				FLUSH_VLAN=2;
 
-reg [C_VLANID_WIDTH-1:0]	vlan_out_next;
 reg							vlan_out_valid_next;
 reg	[1:0]					state, state_next;
 
@@ -141,14 +127,11 @@
 always @(*) begin
 
 	state_next = state;
-	vlan_out_next = vlan_out;
 	vlan_out_valid_next = 0;
 
 	case (state)
 		IDLE: begin
 			if (phv_valid_in) begin
-				vlan_out_next = phv_in[140:129];
-
 				state_next = FLUSH_VLAN;
 			end
 		end
@@ -172,7 +155,7 @@
 	end
 	else begin
 		state <= state_next;
-		vlan_out <= vlan_out_next;
+		vlan_out <= phv_in[140:129];
 		vlan_out_valid <= vlan_out_valid_next;
 
 		// vlan_out_d1 <= vlan_out;
@@ -210,11 +193,13 @@
 		vlan_fifo_state <= VLAN_FIFO_IDLE;
 		act_vlan_ready <= 1;
 		page_tbl_out_valid <= 0;
+		page_tbl_out <= 0;
 	end
 	else begin
 		vlan_fifo_state <= vlan_fifo_state_next;
 		act_vlan_ready <= act_vlan_ready_next;
 		page_tbl_out_valid <= page_tbl_out_valid_next;
+		page_tbl_out <= page_tbl_out_r;
 	end
 end
 
@@ -401,408 +386,191 @@
     CONTROL PATH
 */
 
-generate 
-	if (C_S_AXIS_DATA_WIDTH == 512) begin
-		/****control path for 512b*****/
-		wire [7:0]          mod_id; //module ID
-		wire [15:0]         control_flag; //dst udp port num
-		reg  [7:0]          c_index; //table index(addr)
-		reg                 c_wr_en; //enable table write(wen)
-		reg [15:0]			entry_reg;
-		
-		reg  [2:0]          c_state;
-		
-		localparam IDLE_C = 0,
-		           WRITE_C = 1,
-				   SU_WRITE_C = 2;
-		
-		assign mod_id = c_s_axis_tdata[368+:8];
-		assign control_flag = c_s_axis_tdata[335:320];
-		
-		//LE to BE switching
-		wire[C_S_AXIS_DATA_WIDTH-1:0] c_s_axis_tdata_swapped;
-		assign c_s_axis_tdata_swapped = {	c_s_axis_tdata[0+:8],
-											c_s_axis_tdata[8+:8],
-											c_s_axis_tdata[16+:8],
-											c_s_axis_tdata[24+:8],
-											c_s_axis_tdata[32+:8],
-											c_s_axis_tdata[40+:8],
-											c_s_axis_tdata[48+:8],
-											c_s_axis_tdata[56+:8],
-											c_s_axis_tdata[64+:8],
-											c_s_axis_tdata[72+:8],
-											c_s_axis_tdata[80+:8],
-											c_s_axis_tdata[88+:8],
-											c_s_axis_tdata[96+:8],
-											c_s_axis_tdata[104+:8],
-											c_s_axis_tdata[112+:8],
-											c_s_axis_tdata[120+:8],
-											c_s_axis_tdata[128+:8],
-											c_s_axis_tdata[136+:8],
-											c_s_axis_tdata[144+:8],
-											c_s_axis_tdata[152+:8],
-											c_s_axis_tdata[160+:8],
-											c_s_axis_tdata[168+:8],
-											c_s_axis_tdata[176+:8],
-											c_s_axis_tdata[184+:8],
-											c_s_axis_tdata[192+:8],
-											c_s_axis_tdata[200+:8],
-											c_s_axis_tdata[208+:8],
-											c_s_axis_tdata[216+:8],
-											c_s_axis_tdata[224+:8],
-											c_s_axis_tdata[232+:8],
-											c_s_axis_tdata[240+:8],
-											c_s_axis_tdata[248+:8],
-		                                    c_s_axis_tdata[256+:8],
-		                                    c_s_axis_tdata[264+:8],
-		                                    c_s_axis_tdata[272+:8],
-		                                    c_s_axis_tdata[280+:8],
-		                                    c_s_axis_tdata[288+:8],
-		                                    c_s_axis_tdata[296+:8],
-		                                    c_s_axis_tdata[304+:8],
-		                                    c_s_axis_tdata[312+:8],
-		                                    c_s_axis_tdata[320+:8],
-		                                    c_s_axis_tdata[328+:8],
-		                                    c_s_axis_tdata[336+:8],
-		                                    c_s_axis_tdata[344+:8],
-		                                    c_s_axis_tdata[352+:8],
-		                                    c_s_axis_tdata[360+:8],
-		                                    c_s_axis_tdata[368+:8],
-		                                    c_s_axis_tdata[376+:8],
-		                                    c_s_axis_tdata[384+:8],
-		                                    c_s_axis_tdata[392+:8],
-		                                    c_s_axis_tdata[400+:8],
-		                                    c_s_axis_tdata[408+:8],
-		                                    c_s_axis_tdata[416+:8],
-		                                    c_s_axis_tdata[424+:8],
-		                                    c_s_axis_tdata[432+:8],
-		                                    c_s_axis_tdata[440+:8],
-		                                    c_s_axis_tdata[448+:8],
-		                                    c_s_axis_tdata[456+:8],
-		                                    c_s_axis_tdata[464+:8],
-		                                    c_s_axis_tdata[472+:8],
-		                                    c_s_axis_tdata[480+:8],
-		                                    c_s_axis_tdata[488+:8],
-		                                    c_s_axis_tdata[496+:8],
-		                                    c_s_axis_tdata[504+:8]
-		                                };
-		
-		always @(posedge clk or negedge rst_n) begin
-		    if(~rst_n) begin
-		        c_wr_en <= 1'b0;
-		        c_index <= 4'b0;
-		
-		        c_m_axis_tdata <= 0;
-		        c_m_axis_tuser <= 0;
-		        c_m_axis_tkeep <= 0;
-		        c_m_axis_tvalid <= 0;
-		        c_m_axis_tlast <= 0;
-
-				entry_reg <= 0;
-		
-		        c_state <= IDLE_C;
-		    end
-		    else begin
-		        case(c_state)
-		            IDLE_C: begin
-		                if(c_s_axis_tvalid && mod_id[7:3] == STAGE_ID && mod_id[2:0] == ACTION_ID && control_flag == 16'hf2f1)begin
-		                    c_wr_en <= 1'b0;
-		                    c_index <= c_s_axis_tdata[384+:8];
-		
-		                    c_m_axis_tdata <= 0;
-		                    c_m_axis_tuser <= 0;
-		                    c_m_axis_tkeep <= 0;
-		                    c_m_axis_tvalid <= 0;
-		                    c_m_axis_tlast <= 0;
-		
-		                    c_state <= WRITE_C;
-		
-		                end
-		                else begin
-		                    c_wr_en <= 1'b0;
-		                    c_index <= 4'b0; 
-		
-		                    c_m_axis_tdata <= c_s_axis_tdata;
-		                    c_m_axis_tuser <= c_s_axis_tuser;
-		                    c_m_axis_tkeep <= c_s_axis_tkeep;
-		                    c_m_axis_tvalid <= c_s_axis_tvalid;
-		                    c_m_axis_tlast <= c_s_axis_tlast;
-		
-		                    c_state <= IDLE_C;
-		                end
-		            end
-		            //support full table flush
-					WRITE_C: begin
-						if(c_s_axis_tvalid) begin
-							c_wr_en <= 1'b1;
-							entry_reg <= c_s_axis_tdata_swapped[511 -: 16];
-							if(c_s_axis_tlast) begin
-								c_state <= IDLE_C;
-							end
-							else begin
-								c_state <= SU_WRITE_C;
-							end
-						end
-						else begin
-							c_wr_en <= 1'b0;
-						end
-					end
-
-					SU_WRITE_C: begin
-						if(c_s_axis_tvalid) begin
-							entry_reg <= c_s_axis_tdata_swapped[511 -: 16];
-							c_wr_en <= 1'b1;
-							c_index <= c_index + 1'b1;
-							if(c_s_axis_tlast) begin
-								c_state <= IDLE_C;
-							end
-							else begin
-								c_state <= SU_WRITE_C;
-							end
-						end
-						else begin
-							c_wr_en <= 1'b0;
-						end
-					end
-		        endcase
-		
-		    end
-		end
-		
-		
-		//page table
-		page_tbl_16w_32d
-		page_tbl_16w_32d
-		(
-		    //write
-		    .addra(c_index[4:0]),
-		    .clka(clk),
-		    .dina(entry_reg),
-		    .ena(1'b1),
-		    .wea(c_wr_en),
-		
-		    //match
-		    .addrb(act_vlan_in[8:4]),
-		    .clkb(clk),
-		    .doutb(page_tbl_out),
-		    .enb(1'b1)
-		);
-	end
-	else begin // control path for 256b
-		wire [7:0]          mod_id; //module ID
-		wire [15:0]         control_flag; //dst udp port num
-		wire[C_S_AXIS_DATA_WIDTH-1:0] c_s_axis_tdata_swapped;
-		assign c_s_axis_tdata_swapped = {	c_s_axis_tdata[0+:8],
-											c_s_axis_tdata[8+:8],
-											c_s_axis_tdata[16+:8],
-											c_s_axis_tdata[24+:8],
-											c_s_axis_tdata[32+:8],
-											c_s_axis_tdata[40+:8],
-											c_s_axis_tdata[48+:8],
-											c_s_axis_tdata[56+:8],
-											c_s_axis_tdata[64+:8],
-											c_s_axis_tdata[72+:8],
-											c_s_axis_tdata[80+:8],
-											c_s_axis_tdata[88+:8],
-											c_s_axis_tdata[96+:8],
-											c_s_axis_tdata[104+:8],
-											c_s_axis_tdata[112+:8],
-											c_s_axis_tdata[120+:8],
-											c_s_axis_tdata[128+:8],
-											c_s_axis_tdata[136+:8],
-											c_s_axis_tdata[144+:8],
-											c_s_axis_tdata[152+:8],
-											c_s_axis_tdata[160+:8],
-											c_s_axis_tdata[168+:8],
-											c_s_axis_tdata[176+:8],
-											c_s_axis_tdata[184+:8],
-											c_s_axis_tdata[192+:8],
-											c_s_axis_tdata[200+:8],
-											c_s_axis_tdata[208+:8],
-											c_s_axis_tdata[216+:8],
-											c_s_axis_tdata[224+:8],
-											c_s_axis_tdata[232+:8],
-											c_s_axis_tdata[240+:8],
-											c_s_axis_tdata[248+:8]};
-
-        assign mod_id = c_s_axis_tdata[112+:8];
-        assign control_flag = c_s_axis_tdata[64+:16];
-		localparam	IDLE_C = 0,
-					PARSE_C = 1,
-					RAM_ENTRY = 2,
-					FLUSH_REST_C = 3;
-		// 
-		reg [2:0] c_state, c_state_next;
-		reg [C_S_AXIS_DATA_WIDTH-1:0]		r_tdata, c_s_axis_tdata_d1;
-		reg [C_S_AXIS_TUSER_WIDTH-1:0]		r_tuser, c_s_axis_tuser_d1;
-		reg [C_S_AXIS_DATA_WIDTH/8-1:0]		r_tkeep, c_s_axis_tkeep_d1;
-		reg									r_tlast, c_s_axis_tlast_d1;
-		reg									r_tvalid, c_s_axis_tvalid_d1;
-
-		reg [C_S_AXIS_DATA_WIDTH-1:0]		r_1st_tdata, r_1st_tdata_next;
-		reg [C_S_AXIS_TUSER_WIDTH-1:0]		r_1st_tuser, r_1st_tuser_next;
-		reg [C_S_AXIS_DATA_WIDTH/8-1:0]		r_1st_tkeep, r_1st_tkeep_next;
-		reg									r_1st_tlast, r_1st_tlast_next;
-		reg									r_1st_tvalid, r_1st_tvalid_next;
-
-		reg [15:0]							c_wr_data_next, c_wr_data;
-		reg [7:0]							c_index_next, c_index;
-		reg									c_wr_en_next, c_wr_en;
-
-		always @(*) begin
-			c_state_next = c_state;
-
-			r_tdata = 0;
-			r_tkeep = 0;
-			r_tuser = 0;
-			r_tlast = 0;
-			r_tvalid = 0;
-
-			r_1st_tdata_next = r_1st_tdata;
-			r_1st_tkeep_next = r_1st_tkeep;
-			r_1st_tuser_next = r_1st_tuser;
-			r_1st_tlast_next = r_1st_tlast;
-			r_1st_tvalid_next = r_1st_tvalid;
-
-			c_index_next = c_index;
-			c_wr_en_next = 0;
-			c_wr_data_next = c_wr_data;
-
-			case (c_state) 
-				IDLE_C: begin // 1st segment
-					r_tvalid = 0;
-					if (c_s_axis_tvalid) begin
-						// store 1st segment
-						r_1st_tdata_next = c_s_axis_tdata;
-						r_1st_tuser_next = c_s_axis_tuser;
-						r_1st_tkeep_next = c_s_axis_tkeep;
-						r_1st_tlast_next = c_s_axis_tlast;
-						r_1st_tvalid_next = c_s_axis_tvalid;
-
-						c_state_next = PARSE_C;
-					end
-				end
-				PARSE_C: begin // 2nd segment
-					if (mod_id[7:3] == STAGE_ID && mod_id[2:0] == ACTION_ID && 
-						control_flag == 16'hf2f1 && c_s_axis_tvalid) begin
-						// should not emit segment
-						c_index_next = c_s_axis_tdata[128+:8];
-						c_state_next = RAM_ENTRY;
-					end
-					else if (!c_s_axis_tvalid) begin
-					end
-					else begin
-						// emit
-						r_tdata = r_1st_tdata;
-						r_tkeep = r_1st_tkeep;
-						r_tuser = r_1st_tuser;
-						r_tlast = r_1st_tlast;
-						r_tvalid = r_1st_tvalid;
-						c_state_next = FLUSH_REST_C;
-					end
-				end
-				RAM_ENTRY: begin // 3rd segment
-					if (c_s_axis_tvalid) begin
-						c_wr_en_next = 1; // next clk to write
-						c_wr_data_next = c_s_axis_tdata_swapped[255-:16];
-						
-						c_state_next = FLUSH_REST_C;
-					end
-				end
-				FLUSH_REST_C: begin
-					c_wr_en_next = 0;
-					r_tdata = c_s_axis_tdata_d1;
-					r_tkeep = c_s_axis_tkeep_d1;
-					r_tuser = c_s_axis_tuser_d1;
-					r_tlast = c_s_axis_tlast_d1;
-					r_tvalid = c_s_axis_tvalid_d1;
-					if (c_s_axis_tvalid_d1 && c_s_axis_tlast_d1) begin
-						c_state_next = IDLE_C;
-					end
-				end
-			endcase
-		end
-
-		always @(posedge clk) begin
-			if (~rst_n) begin
-				c_state <= IDLE_C;
-
-				// control output
-				c_m_axis_tdata <= 0;
-				c_m_axis_tuser <= 0;
-				c_m_axis_tkeep <= 0;
-				c_m_axis_tlast <= 0;
-				c_m_axis_tvalid <= 0;
-				//
-				c_index <= 0;
-				c_wr_en <= 0;
-				c_wr_data <= 0;
-			end
-			else begin
-				c_state <= c_state_next;
+generate
+    /****control path for 512b*****/
+    wire [7:0]          mod_id; //module ID
+    wire [15:0]         control_flag; //dst udp port num
+    reg  [7:0]          c_index; //table index(addr)
+    reg                 c_wr_en; //enable table write(wen)
+    reg [15:0]			entry_reg;
+
+    reg  [2:0]          c_state;
+
+    localparam IDLE_C = 0,
+               WRITE_C = 1,
+		       SU_WRITE_C = 2;
+
+    assign mod_id = c_s_axis_tdata[368+:8];
+    assign control_flag = c_s_axis_tdata[303:288];
+
+    //LE to BE switching
+    wire[C_S_AXIS_DATA_WIDTH-1:0] c_s_axis_tdata_swapped;
+    assign c_s_axis_tdata_swapped = {	c_s_axis_tdata[0+:8],
+									    c_s_axis_tdata[8+:8],
+									    c_s_axis_tdata[16+:8],
+									    c_s_axis_tdata[24+:8],
+									    c_s_axis_tdata[32+:8],
+									    c_s_axis_tdata[40+:8],
+									    c_s_axis_tdata[48+:8],
+									    c_s_axis_tdata[56+:8],
+									    c_s_axis_tdata[64+:8],
+									    c_s_axis_tdata[72+:8],
+									    c_s_axis_tdata[80+:8],
+									    c_s_axis_tdata[88+:8],
+									    c_s_axis_tdata[96+:8],
+									    c_s_axis_tdata[104+:8],
+									    c_s_axis_tdata[112+:8],
+									    c_s_axis_tdata[120+:8],
+									    c_s_axis_tdata[128+:8],
+									    c_s_axis_tdata[136+:8],
+									    c_s_axis_tdata[144+:8],
+									    c_s_axis_tdata[152+:8],
+									    c_s_axis_tdata[160+:8],
+									    c_s_axis_tdata[168+:8],
+									    c_s_axis_tdata[176+:8],
+									    c_s_axis_tdata[184+:8],
+									    c_s_axis_tdata[192+:8],
+									    c_s_axis_tdata[200+:8],
+									    c_s_axis_tdata[208+:8],
+									    c_s_axis_tdata[216+:8],
+									    c_s_axis_tdata[224+:8],
+									    c_s_axis_tdata[232+:8],
+									    c_s_axis_tdata[240+:8],
+									    c_s_axis_tdata[248+:8],
+                                        c_s_axis_tdata[256+:8],
+                                        c_s_axis_tdata[264+:8],
+                                        c_s_axis_tdata[272+:8],
+                                        c_s_axis_tdata[280+:8],
+                                        c_s_axis_tdata[288+:8],
+                                        c_s_axis_tdata[296+:8],
+                                        c_s_axis_tdata[304+:8],
+                                        c_s_axis_tdata[312+:8],
+                                        c_s_axis_tdata[320+:8],
+                                        c_s_axis_tdata[328+:8],
+                                        c_s_axis_tdata[336+:8],
+                                        c_s_axis_tdata[344+:8],
+                                        c_s_axis_tdata[352+:8],
+                                        c_s_axis_tdata[360+:8],
+                                        c_s_axis_tdata[368+:8],
+                                        c_s_axis_tdata[376+:8],
+                                        c_s_axis_tdata[384+:8],
+                                        c_s_axis_tdata[392+:8],
+                                        c_s_axis_tdata[400+:8],
+                                        c_s_axis_tdata[408+:8],
+                                        c_s_axis_tdata[416+:8],
+                                        c_s_axis_tdata[424+:8],
+                                        c_s_axis_tdata[432+:8],
+                                        c_s_axis_tdata[440+:8],
+                                        c_s_axis_tdata[448+:8],
+                                        c_s_axis_tdata[456+:8],
+                                        c_s_axis_tdata[464+:8],
+                                        c_s_axis_tdata[472+:8],
+                                        c_s_axis_tdata[480+:8],
+                                        c_s_axis_tdata[488+:8],
+                                        c_s_axis_tdata[496+:8],
+                                        c_s_axis_tdata[504+:8]
+                                    };
+
+    always @(posedge clk or negedge rst_n) begin
+        if(~rst_n) begin
+            c_wr_en <= 1'b0;
+            c_index <= 4'b0;
+
+            c_m_axis_tdata <= 0;
+            c_m_axis_tuser <= 0;
+            c_m_axis_tkeep <= 0;
+            c_m_axis_tvalid <= 0;
+            c_m_axis_tlast <= 0;
+
+		    entry_reg <= 0;
+
+            c_state <= IDLE_C;
+        end
+        else begin
+            case(c_state)
+                IDLE_C: begin
+                    if(c_s_axis_tvalid && mod_id[7:3] == STAGE_ID && mod_id[2:0] == ACTION_ID && control_flag == 16'hf2f1)begin
+                        c_wr_en <= 1'b0;
+                        c_index <= c_s_axis_tdata[384+:8];
+
+                        c_m_axis_tdata <= 0;
+                        c_m_axis_tuser <= 0;
+                        c_m_axis_tkeep <= 0;
+                        c_m_axis_tvalid <= 0;
+                        c_m_axis_tlast <= 0;
+
+                        c_state <= WRITE_C;
+
+                    end
+                    else begin
+                        c_wr_en <= 1'b0;
+                        c_index <= 4'b0; 
+
+                        c_m_axis_tdata <= c_s_axis_tdata;
+                        c_m_axis_tuser <= c_s_axis_tuser;
+                        c_m_axis_tkeep <= c_s_axis_tkeep;
+                        c_m_axis_tvalid <= c_s_axis_tvalid;
+                        c_m_axis_tlast <= c_s_axis_tlast;
+
+                        c_state <= IDLE_C;
+                    end
+                end
+                //support full table flush
+			    WRITE_C: begin
+				    if(c_s_axis_tvalid) begin
+					    c_wr_en <= 1'b1;
+					    entry_reg <= c_s_axis_tdata_swapped[511 -: 16];
+					    if(c_s_axis_tlast) begin
+						    c_state <= IDLE_C;
+					    end
+					    else begin
+						    c_state <= SU_WRITE_C;
+					    end
+				    end
+				    else begin
+					    c_wr_en <= 1'b0;
+				    end
+			    end
+
+			    SU_WRITE_C: begin
+				    if(c_s_axis_tvalid) begin
+					    entry_reg <= c_s_axis_tdata_swapped[511 -: 16];
+					    c_wr_en <= 1'b1;
+					    c_index <= c_index + 1'b1;
+					    if(c_s_axis_tlast) begin
+						    c_state <= IDLE_C;
+					    end
+					    else begin
+						    c_state <= SU_WRITE_C;
+					    end
+				    end
+				    else begin
+					    c_wr_en <= 1'b0;
+				    end
+			    end
+            endcase
 
+        end
+    end
 
-				// output ctrl master signals
-				c_m_axis_tdata <= r_tdata;
-				c_m_axis_tkeep <= r_tkeep;
-				c_m_axis_tuser <= r_tuser;
-				c_m_axis_tlast <= r_tlast;
-				c_m_axis_tvalid <= r_tvalid;
-				//
-				c_index <= c_index_next;
-				c_wr_en <= c_wr_en_next;
-				c_wr_data <= c_wr_data_next;
-			end
-		end
 
-		always @(posedge clk) begin
-			if (~rst_n) begin
-				// delayed 1 clk
-				c_s_axis_tdata_d1 <= 0;
-				c_s_axis_tuser_d1 <= 0;
-				c_s_axis_tkeep_d1 <= 0;
-				c_s_axis_tlast_d1 <= 0;
-				c_s_axis_tvalid_d1 <= 0;
-				//
-				r_1st_tdata <= 0;
-				r_1st_tkeep <= 0;
-				r_1st_tuser <= 0;
-				r_1st_tlast <= 0;
-				r_1st_tvalid <= 0;
-			end
-			else begin
-				// delayed 1 clk
-				c_s_axis_tdata_d1 <= c_s_axis_tdata;
-				c_s_axis_tuser_d1 <= c_s_axis_tuser;
-				c_s_axis_tkeep_d1 <= c_s_axis_tkeep;
-				c_s_axis_tlast_d1 <= c_s_axis_tlast;
-				c_s_axis_tvalid_d1 <= c_s_axis_tvalid;
-				// 
-				r_1st_tdata <= r_1st_tdata_next;
-				r_1st_tkeep <= r_1st_tkeep_next;
-				r_1st_tuser <= r_1st_tuser_next;
-				r_1st_tlast <= r_1st_tlast_next;
-				r_1st_tvalid <= r_1st_tvalid_next;
-			end
-		end
-		//page table
-		page_tbl_16w_32d
-		page_tbl_16w_32d
-		(
-		    //write
-		    .addra(c_index[4:0]),
-		    .clka(clk),
-		    .dina(c_wr_data),
-		    .ena(1'b1),
-		    .wea(c_wr_en),
-		
-		    //match
-		    .addrb(act_vlan_in[8:4]),
-		    .clkb(clk),
-		    .doutb(page_tbl_out),
-		    .enb(1'b1)
-		);
-	end
+    //page table
+    page_tbl_16w_32d
+    page_tbl_16w_32d
+    (
+        //write
+        .addra(c_index[4:0]),
+        .clka(clk),
+        .dina(entry_reg),
+        .ena(1'b1),
+        .wea(c_wr_en),
+
+        //match
+        .addrb(act_vlan_in[8:4]),
+        .clkb(clk),
+        .doutb(page_tbl_out_r),
+        .enb(1'b1)
+    );
 endgenerate
 
 
diff -ruN '--exclude=.git' '--exclude=p4c' '--exclude=tb' menshen/action/alu_1.v parametric_menshen/action/alu_1.v
--- menshen/action/alu_1.v
+++ parametric_menshen/action/alu_1.v
@@ -31,70 +31,37 @@
               extract op1 from pkt header, op2 from action, add(sub) and write back.
 */
 
-
-localparam IDLE_S=3'd0, 
-		   WAIT1_S=3'd1, 
-		   WAIT2_S=3'd2, 
-		   WAIT3_S=3'd3, 
-		   OUTPUT_S=3'd4;
-
-reg [2:0]					state, state_next;
 reg [DATA_WIDTH-1:0]		container_out_r;
 reg							container_out_valid_next;
 
-always @(*) begin
-	state_next = state;
-	container_out_r = container_out;
-	container_out_valid_next = 0;
-
-	case (state)
-		IDLE_S: begin
-			if (action_valid) begin
-				state_next = OUTPUT_S;
-				case(action_in[24:21])
-            	    4'b0001, 4'b1001: begin
-            	        container_out_r = operand_1_in + operand_2_in;
-            	    end
-            	    4'b0010, 4'b1010: begin
-            	        container_out_r = operand_1_in - operand_2_in;
-            	    end
-					4'b1110: begin
-						container_out_r = operand_2_in;
-					end
-            	    //if its an empty (default) action
-            	    default: begin
-            	        container_out_r = operand_1_in;
-            	    end
-            	endcase
-			end
-		end
-		WAIT1_S: begin
-			// empty cycle
-			state_next = WAIT2_S;
-		end
-		WAIT2_S: begin
-			state_next = WAIT3_S;
-		end
-		WAIT3_S: begin
-			state_next = OUTPUT_S;
-		end
-		OUTPUT_S: begin
-			container_out_valid_next = 1;
-			state_next = IDLE_S;
-		end
-	endcase
-end
-
-always @(posedge clk or negedge rst_n) begin
+always @(posedge clk) begin
 	if (~rst_n) begin
 		container_out <= 0;
 		container_out_valid <= 0;
-		state <= IDLE_S;
+		
+		container_out_r <= 0;
+		container_out_valid_next <= 0;
 	end
 	else begin
-		state <= state_next;
 		container_out_valid <= container_out_valid_next;
 		container_out <= container_out_r;
+		
+		container_out_valid_next <= action_valid;
+		case(action_in[24:21])
+    	    4'b0001, 4'b1001: begin
+    	        container_out_r <= operand_1_in + operand_2_in;
+    	    end
+    	    4'b0010, 4'b1010: begin
+    	        container_out_r <= operand_1_in - operand_2_in;
+    	    end
+			4'b1110: begin
+				container_out_r <= operand_2_in;
+			end
+    	    //if its an empty (default) action
+    	    default: begin
+    	        container_out_r <= operand_1_in;
+    	    end
+    	endcase
 	end
 end
 
diff -ruN '--exclude=.git' '--exclude=p4c' '--exclude=tb' menshen/action/alu_2.v parametric_menshen/action/alu_2.v
--- menshen/action/alu_2.v
+++ parametric_menshen/action/alu_2.v
@@ -122,7 +122,7 @@
 				action_type_next = action_in[24:21];
                 overflow_next = 0;
 				alu_state_next = EMPTY1_S;
-				ready_out_next = 1'b0;
+				//ready_out_next = 1'b0;
 
                 
                 case(action_in[24:21])
diff -ruN '--exclude=.git' '--exclude=p4c' '--exclude=tb' menshen/action/alu_3.v parametric_menshen/action/alu_3.v
--- menshen/action/alu_3.v
+++ parametric_menshen/action/alu_3.v
@@ -36,69 +36,37 @@
     
 */
 
-localparam IDLE_S=3'd0,
-		   WAIT1_S=3'd1,
-		   WAIT2_S=3'd2, 
-		   WAIT3_S=3'd3, 
-		   OUTPUT_S=3'd4;
-
-reg [2:0]						state, state_next;
 reg [META_LEN-1:0]		comp_meta_data_out_r;
 reg								comp_meta_data_valid_next;
 
-always @(*) begin
-	state_next = state;
-	comp_meta_data_out_r = comp_meta_data_out;
-	comp_meta_data_valid_next = 0;
-
-	case (state)
-		IDLE_S: begin
-			if (action_valid_in) begin
-				state_next = OUTPUT_S;
-				case(action_in[24:21])
-            	    4'b1100: begin // dst_port
-            	        comp_meta_data_out_r[255:32] = {action_in[10:5],comp_meta_data_in[249:32]};
-            	        comp_meta_data_out_r[31:24]  = action_in[20:13];
-            	        comp_meta_data_out_r[23:0]   = comp_meta_data_in[23:0];
-            	    end
-            	    4'b1101: begin // discard
-            	        comp_meta_data_out_r[255:129] = {action_in[10:5],comp_meta_data_in[249:129]};
-            	        comp_meta_data_out_r[128] = action_in[12];
-            	        comp_meta_data_out_r[127:0] = comp_meta_data_in[127:0];
-            	    end
-            	    default: begin
-            	        comp_meta_data_out_r = comp_meta_data_in;
-            	    end
-            	endcase
-			end
-		end
-		WAIT1_S: begin
-			// empty cycle
-			state_next = WAIT2_S;
-		end
-		WAIT2_S: begin
-			state_next = WAIT3_S;
-		end
-		WAIT3_S: begin
-			state_next = OUTPUT_S;
-		end
-		OUTPUT_S: begin
-			comp_meta_data_valid_next = 1;
-			state_next = IDLE_S;
-		end
-	endcase
-end
-
 always @(posedge clk) begin
 	if (~rst_n) begin
 		comp_meta_data_out <= 0;
 		comp_meta_data_valid_out <= 0;
-		state <= IDLE_S;
+		
+		comp_meta_data_out_r <= 0;
+		comp_meta_data_valid_next <= 0;
 	end
 	else begin
-		state <= state_next;
 		comp_meta_data_out <= comp_meta_data_out_r;
 		comp_meta_data_valid_out <= comp_meta_data_valid_next;
+		
+		comp_meta_data_valid_next <= action_valid_in;
+		case(action_in[24:21])
+    	    4'b1100: begin // dst_port
+    	        comp_meta_data_out_r[255:32] <= {action_in[10:5],comp_meta_data_in[249:32]};
+    	        comp_meta_data_out_r[31:24]  <= action_in[20:13];
+    	        comp_meta_data_out_r[23:0]   <= comp_meta_data_in[23:0];
+    	    end
+    	    4'b1101: begin // discard
+    	        comp_meta_data_out_r[255:129] <= {action_in[10:5],comp_meta_data_in[249:129]};
+    	        comp_meta_data_out_r[128] <= action_in[12];
+    	        comp_meta_data_out_r[127:0] <= comp_meta_data_in[127:0];
+    	    end
+    	    default: begin
+    	        comp_meta_data_out_r <= comp_meta_data_in;
+    	    end
+    	endcase
 	end
 end
 
diff -ruN '--exclude=.git' '--exclude=p4c' '--exclude=tb' menshen/action/crossbar.v parametric_menshen/action/crossbar.v
--- menshen/action/crossbar.v
+++ parametric_menshen/action/crossbar.v
@@ -48,71 +48,91 @@
 wire [ACT_LEN-1:0]       sub_action [24:0];
 
 
+reg [PHV_LEN-1:0]         phv_in_r;
+reg                       phv_in_valid_r;
+reg [ACT_LEN*25-1:0]      action_in_r;
+reg                       action_in_valid_r;
+
+always @(posedge clk) begin
+	if (~rst_n) begin
+		phv_in_r <= 0;
+		phv_in_valid_r <= 0;
+		action_in_r <= 0;
+		action_in_valid_r <= 0;
+	end
+	else begin
+		phv_in_r <= phv_in;
+		phv_in_valid_r <= phv_in_valid;
+		action_in_r <= action_in;
+		action_in_valid_r <= action_in_valid;
+	end
+end
+
 /********intermediate variables declared here********/
 
-assign cont_6B[7] = phv_in[PHV_LEN-1            -: width_6B];
-assign cont_6B[6] = phv_in[PHV_LEN-1-  width_6B -: width_6B];
-assign cont_6B[5] = phv_in[PHV_LEN-1-2*width_6B -: width_6B];
-assign cont_6B[4] = phv_in[PHV_LEN-1-3*width_6B -: width_6B];
-assign cont_6B[3] = phv_in[PHV_LEN-1-4*width_6B -: width_6B];
-assign cont_6B[2] = phv_in[PHV_LEN-1-5*width_6B -: width_6B];
-assign cont_6B[1] = phv_in[PHV_LEN-1-6*width_6B -: width_6B];
-assign cont_6B[0] = phv_in[PHV_LEN-1-7*width_6B -: width_6B];
-
-assign cont_4B[7] = phv_in[PHV_LEN-1-8*width_6B           -: width_4B];
-assign cont_4B[6] = phv_in[PHV_LEN-1-8*width_6B-  width_4B -: width_4B];
-assign cont_4B[5] = phv_in[PHV_LEN-1-8*width_6B-2*width_4B -: width_4B];
-assign cont_4B[4] = phv_in[PHV_LEN-1-8*width_6B-3*width_4B -: width_4B];
-assign cont_4B[3] = phv_in[PHV_LEN-1-8*width_6B-4*width_4B -: width_4B];
-assign cont_4B[2] = phv_in[PHV_LEN-1-8*width_6B-5*width_4B -: width_4B];
-assign cont_4B[1] = phv_in[PHV_LEN-1-8*width_6B-6*width_4B -: width_4B];
-assign cont_4B[0] = phv_in[PHV_LEN-1-8*width_6B-7*width_4B -: width_4B];
-
-
-assign cont_2B[7] = phv_in[PHV_LEN-1-8*width_6B-8*width_4B            -: width_2B];
-assign cont_2B[6] = phv_in[PHV_LEN-1-8*width_6B-8*width_4B-  width_2B -: width_2B];
-assign cont_2B[5] = phv_in[PHV_LEN-1-8*width_6B-8*width_4B-2*width_2B -: width_2B];
-assign cont_2B[4] = phv_in[PHV_LEN-1-8*width_6B-8*width_4B-3*width_2B -: width_2B];
-assign cont_2B[3] = phv_in[PHV_LEN-1-8*width_6B-8*width_4B-4*width_2B -: width_2B];
-assign cont_2B[2] = phv_in[PHV_LEN-1-8*width_6B-8*width_4B-5*width_2B -: width_2B];
-assign cont_2B[1] = phv_in[PHV_LEN-1-8*width_6B-8*width_4B-6*width_2B -: width_2B];
-assign cont_2B[0] = phv_in[PHV_LEN-1-8*width_6B-8*width_4B-7*width_2B -: width_2B];
+assign cont_6B[7] = phv_in_r[PHV_LEN-1            -: width_6B];
+assign cont_6B[6] = phv_in_r[PHV_LEN-1-  width_6B -: width_6B];
+assign cont_6B[5] = phv_in_r[PHV_LEN-1-2*width_6B -: width_6B];
+assign cont_6B[4] = phv_in_r[PHV_LEN-1-3*width_6B -: width_6B];
+assign cont_6B[3] = phv_in_r[PHV_LEN-1-4*width_6B -: width_6B];
+assign cont_6B[2] = phv_in_r[PHV_LEN-1-5*width_6B -: width_6B];
+assign cont_6B[1] = phv_in_r[PHV_LEN-1-6*width_6B -: width_6B];
+assign cont_6B[0] = phv_in_r[PHV_LEN-1-7*width_6B -: width_6B];
+
+assign cont_4B[7] = phv_in_r[PHV_LEN-1-8*width_6B           -: width_4B];
+assign cont_4B[6] = phv_in_r[PHV_LEN-1-8*width_6B-  width_4B -: width_4B];
+assign cont_4B[5] = phv_in_r[PHV_LEN-1-8*width_6B-2*width_4B -: width_4B];
+assign cont_4B[4] = phv_in_r[PHV_LEN-1-8*width_6B-3*width_4B -: width_4B];
+assign cont_4B[3] = phv_in_r[PHV_LEN-1-8*width_6B-4*width_4B -: width_4B];
+assign cont_4B[2] = phv_in_r[PHV_LEN-1-8*width_6B-5*width_4B -: width_4B];
+assign cont_4B[1] = phv_in_r[PHV_LEN-1-8*width_6B-6*width_4B -: width_4B];
+assign cont_4B[0] = phv_in_r[PHV_LEN-1-8*width_6B-7*width_4B -: width_4B];
+
+
+assign cont_2B[7] = phv_in_r[PHV_LEN-1-8*width_6B-8*width_4B            -: width_2B];
+assign cont_2B[6] = phv_in_r[PHV_LEN-1-8*width_6B-8*width_4B-  width_2B -: width_2B];
+assign cont_2B[5] = phv_in_r[PHV_LEN-1-8*width_6B-8*width_4B-2*width_2B -: width_2B];
+assign cont_2B[4] = phv_in_r[PHV_LEN-1-8*width_6B-8*width_4B-3*width_2B -: width_2B];
+assign cont_2B[3] = phv_in_r[PHV_LEN-1-8*width_6B-8*width_4B-4*width_2B -: width_2B];
+assign cont_2B[2] = phv_in_r[PHV_LEN-1-8*width_6B-8*width_4B-5*width_2B -: width_2B];
+assign cont_2B[1] = phv_in_r[PHV_LEN-1-8*width_6B-8*width_4B-6*width_2B -: width_2B];
+assign cont_2B[0] = phv_in_r[PHV_LEN-1-8*width_6B-8*width_4B-7*width_2B -: width_2B];
 
 // Tao: get action for each PHV container
-assign sub_action[24] = action_in[ACT_LEN*25-1-:ACT_LEN];					// 1st action
-assign sub_action[23] = action_in[ACT_LEN*25-1 -  ACT_LEN-:ACT_LEN];		// 2nd action
-assign sub_action[22] = action_in[ACT_LEN*25-1 -2*ACT_LEN-:ACT_LEN];		// 3rd action
-assign sub_action[21] = action_in[ACT_LEN*25-1 -3*ACT_LEN-:ACT_LEN];
-assign sub_action[20] = action_in[ACT_LEN*25-1 -4*ACT_LEN-:ACT_LEN];
-assign sub_action[19] = action_in[ACT_LEN*25-1 -5*ACT_LEN-:ACT_LEN];
-assign sub_action[18] = action_in[ACT_LEN*25-1 -6*ACT_LEN-:ACT_LEN];
-assign sub_action[17] = action_in[ACT_LEN*25-1 -7*ACT_LEN-:ACT_LEN];
-
-assign sub_action[16] = action_in[ACT_LEN*25-1 -8*ACT_LEN-:ACT_LEN];
-assign sub_action[15] = action_in[ACT_LEN*25-1 -9*ACT_LEN-:ACT_LEN];
-assign sub_action[14] = action_in[ACT_LEN*25-1 -10*ACT_LEN-:ACT_LEN];
-assign sub_action[13] = action_in[ACT_LEN*25-1 -11*ACT_LEN-:ACT_LEN];
-assign sub_action[12] = action_in[ACT_LEN*25-1 -12*ACT_LEN-:ACT_LEN];
-assign sub_action[11] = action_in[ACT_LEN*25-1 -13*ACT_LEN-:ACT_LEN];
-assign sub_action[10] = action_in[ACT_LEN*25-1 -14*ACT_LEN-:ACT_LEN];
-assign sub_action[9] = action_in[ACT_LEN*25-1 -15*ACT_LEN-:ACT_LEN];
-
-assign sub_action[8] = action_in[ACT_LEN*25-1 -16*ACT_LEN-:ACT_LEN];
-assign sub_action[7] = action_in[ACT_LEN*25-1 -17*ACT_LEN-:ACT_LEN];
-assign sub_action[6] = action_in[ACT_LEN*25-1 -18*ACT_LEN-:ACT_LEN];
-assign sub_action[5] = action_in[ACT_LEN*25-1 -19*ACT_LEN-:ACT_LEN];
-assign sub_action[4] = action_in[ACT_LEN*25-1 -20*ACT_LEN-:ACT_LEN];
-assign sub_action[3] = action_in[ACT_LEN*25-1 -21*ACT_LEN-:ACT_LEN];
-assign sub_action[2] = action_in[ACT_LEN*25-1 -22*ACT_LEN-:ACT_LEN];
-assign sub_action[1] = action_in[ACT_LEN*25-1 -23*ACT_LEN-:ACT_LEN];
+assign sub_action[24] = action_in_r[ACT_LEN*25-1-:ACT_LEN];					// 1st action
+assign sub_action[23] = action_in_r[ACT_LEN*25-1 -  ACT_LEN-:ACT_LEN];		// 2nd action
+assign sub_action[22] = action_in_r[ACT_LEN*25-1 -2*ACT_LEN-:ACT_LEN];		// 3rd action
+assign sub_action[21] = action_in_r[ACT_LEN*25-1 -3*ACT_LEN-:ACT_LEN];
+assign sub_action[20] = action_in_r[ACT_LEN*25-1 -4*ACT_LEN-:ACT_LEN];
+assign sub_action[19] = action_in_r[ACT_LEN*25-1 -5*ACT_LEN-:ACT_LEN];
+assign sub_action[18] = action_in_r[ACT_LEN*25-1 -6*ACT_LEN-:ACT_LEN];
+assign sub_action[17] = action_in_r[ACT_LEN*25-1 -7*ACT_LEN-:ACT_LEN];
+
+assign sub_action[16] = action_in_r[ACT_LEN*25-1 -8*ACT_LEN-:ACT_LEN];
+assign sub_action[15] = action_in_r[ACT_LEN*25-1 -9*ACT_LEN-:ACT_LEN];
+assign sub_action[14] = action_in_r[ACT_LEN*25-1 -10*ACT_LEN-:ACT_LEN];
+assign sub_action[13] = action_in_r[ACT_LEN*25-1 -11*ACT_LEN-:ACT_LEN];
+assign sub_action[12] = action_in_r[ACT_LEN*25-1 -12*ACT_LEN-:ACT_LEN];
+assign sub_action[11] = action_in_r[ACT_LEN*25-1 -13*ACT_LEN-:ACT_LEN];
+assign sub_action[10] = action_in_r[ACT_LEN*25-1 -14*ACT_LEN-:ACT_LEN];
+assign sub_action[9] = action_in_r[ACT_LEN*25-1 -15*ACT_LEN-:ACT_LEN];
+
+assign sub_action[8] = action_in_r[ACT_LEN*25-1 -16*ACT_LEN-:ACT_LEN];
+assign sub_action[7] = action_in_r[ACT_LEN*25-1 -17*ACT_LEN-:ACT_LEN];
+assign sub_action[6] = action_in_r[ACT_LEN*25-1 -18*ACT_LEN-:ACT_LEN];
+assign sub_action[5] = action_in_r[ACT_LEN*25-1 -19*ACT_LEN-:ACT_LEN];
+assign sub_action[4] = action_in_r[ACT_LEN*25-1 -20*ACT_LEN-:ACT_LEN];
+assign sub_action[3] = action_in_r[ACT_LEN*25-1 -21*ACT_LEN-:ACT_LEN];
+assign sub_action[2] = action_in_r[ACT_LEN*25-1 -22*ACT_LEN-:ACT_LEN];
+assign sub_action[1] = action_in_r[ACT_LEN*25-1 -23*ACT_LEN-:ACT_LEN];
 
-assign sub_action[0] = action_in[ACT_LEN*25-1 -24*ACT_LEN-:ACT_LEN];
+assign sub_action[0] = action_in_r[ACT_LEN*25-1 -24*ACT_LEN-:ACT_LEN];
 
 //assign inputs for ALUs 
 
 always @(posedge clk) begin
-	action_out <= action_in;
-	action_valid_out <= action_in_valid;
+	action_out <= action_in_r;
+	action_valid_out <= action_in_valid_r;
 end
 
 localparam IDLE = 0,
@@ -127,18 +147,8 @@
         // action_full_reg <= 625'b0;
         // phv_valid_reg <= 1'b0;
         // action_valid_reg <= 1'b0;
-        //reset outputs
         alu_in_valid <= 1'b0;
-        phv_remain_data <= 256'b0;
-        //reset all the outputs
-        alu_in_6B_1 <= 384'b0;
-        alu_in_6B_2 <= 384'b0;
-        alu_in_4B_1 <= 256'b0;
-        alu_in_4B_2 <= 256'b0;
-        alu_in_4B_3 <= 256'b0;
-        alu_in_2B_1 <= 128'b0;
-        alu_in_2B_2 <= 128'b0;
-       
+        
 		state <= IDLE;
 		ready_out <= 1;
     end
@@ -147,7 +157,7 @@
 		case (state) 
 			IDLE: begin
 
-				if(phv_in_valid == 1'b1) begin
+				if(phv_in_valid_r == 1'b1) begin
 					if (ready_in) begin
 						alu_in_valid <= 1'b1;
 					end
@@ -155,93 +165,8 @@
 						ready_out <= 0;
 						state <= HALT;
 					end
-        		    //assign values one by one (of course need to consider act format)
-        		    for(i=7; i>=0; i=i-1) begin
-        		        case(sub_action[16+i+1][24:21])
-        		            //be noted that 2 ops need to be the same width
-        		            4'b0001, 4'b0010: begin
-        		                alu_in_6B_1[(i+1)*width_6B-1 -: width_6B] <= cont_6B[sub_action[16+i+1][18:16]];
-        		                alu_in_6B_2[(i+1)*width_6B-1 -: width_6B] <= cont_6B[sub_action[16+i+1][13:11]];
-        		            end
-        		            //extracted from action field (imm)
-        		            4'b1001, 4'b1010: begin
-        		                alu_in_6B_1[(i+1)*width_6B-1 -: width_6B] <= cont_6B[sub_action[16+i+1][18:16]];
-        		                alu_in_6B_2[(i+1)*width_6B-1 -: width_6B] <= {32'b0,sub_action[16+i+1][15:0]};
-        		            end
-							// set operation, operand A set to 0, operand B set to imm
-							4'b1110: begin
-        		                alu_in_6B_1[(i+1)*width_6B-1 -: width_6B] <= 48'b0;
-        		                alu_in_6B_2[(i+1)*width_6B-1 -: width_6B] <= {32'b0,sub_action[16+i+1][15:0]};
-							end
-        		            //if there is no action to take, output the original value
-        		            default: begin
-        		                //alu_1 should be set to the phv value
-        		                alu_in_6B_1[(i+1)*width_6B-1 -: width_6B] <= cont_6B[i];
-        		                alu_in_6B_2[(i+1)*width_6B-1 -: width_6B] <= 48'b0;
-        		            end
-        		        endcase
-        		    end
-        		    //4B is a bit of differernt from 2B and 6B
-        		    for(i=7; i>=0; i=i-1) begin
-        		        alu_in_4B_3[(i+1)*width_4B-1 -: width_4B] <= cont_4B[i];
-        		        casez(sub_action[8+i+1][24:21])
-        		            //be noted that 2 ops need to be the same width
-        		            4'b0001, 4'b0010: begin
-        		                alu_in_4B_1[(i+1)*width_4B-1 -: width_4B] <= cont_4B[sub_action[8+i+1][18:16]];
-        		                alu_in_4B_2[(i+1)*width_4B-1 -: width_4B] <= cont_4B[sub_action[8+i+1][13:11]];
-        		            end
-        		            4'b1001, 4'b1010: begin
-        		                alu_in_4B_1[(i+1)*width_4B-1 -: width_4B] <= cont_4B[sub_action[8+i+1][18:16]];
-        		                alu_in_4B_2[(i+1)*width_4B-1 -: width_4B] <= {16'b0,sub_action[8+i+1][15:0]};
-        		            end
-							// set operation, operand A set to 0, operand B set to imm
-							4'b1110: begin
-        		                alu_in_4B_1[(i+1)*width_4B-1 -: width_4B] <= 32'b0;
-        		                alu_in_4B_2[(i+1)*width_4B-1 -: width_4B] <= {16'b0,sub_action[8+i+1][15:0]};
-							end
-        		            //loadd put here
-        		            4'b1011, 4'b1000, 4'b0111: begin
-        		                alu_in_4B_1[(i+1)*width_4B-1 -: width_4B] <= cont_4B[sub_action[8+i+1][18:16]];
-        		                //alu_in_4B_2[(i+1)*width_4B-1 -: width_4B] <= {16'b0,sub_action[8+i+1][15:0]};
-        		                alu_in_4B_2[(i+1)*width_4B-1 -: width_4B] <= cont_4B[sub_action[8+i+1][13:11]];
-        		            end
-        		            //if there is no action to take, output the original value
-        		            default: begin
-        		                //alu_1 should be set to the phv value
-        		                alu_in_4B_1[(i+1)*width_4B-1 -: width_4B] <= cont_4B[i];
-        		                alu_in_4B_2[(i+1)*width_4B-1 -: width_4B] <= 32'b0;
-        		            end
-        		        endcase
-        		    end
-        		    for(i=7; i>=0; i=i-1) begin
-        		        casez(sub_action[i+1][24:21])
-        		            //be noted that 2 ops need to be the same width
-        		            4'b0001, 4'b0010: begin
-        		                alu_in_2B_1[(i+1)*width_2B-1 -: width_2B] <= cont_2B[sub_action[i+1][18:16]];
-        		                alu_in_2B_2[(i+1)*width_2B-1 -: width_2B] <= cont_2B[sub_action[i+1][13:11]];
-        		            end
-        		            4'b1001, 4'b1010: begin
-        		                alu_in_2B_1[(i+1)*width_2B-1 -: width_2B] <= cont_2B[sub_action[i+1][18:16]];
-        		                alu_in_2B_2[(i+1)*width_2B-1 -: width_2B] <= sub_action[i+1][15:0];
-        		            end
-							// set operation, operand A set to 0, operand B set to imm
-							4'b1110: begin
-        		                alu_in_2B_1[(i+1)*width_2B-1 -: width_2B] <= 16'b0;
-        		                alu_in_2B_2[(i+1)*width_2B-1 -: width_2B] <= sub_action[i+1][15:0];
-							end
-        		            //if there is no action to take, output the original value
-        		            default: begin
-        		                //alu_1 should be set to the phv value
-        		                alu_in_2B_1[(i+1)*width_2B-1 -: width_2B] <= cont_2B[i];
-        		                alu_in_2B_2[(i+1)*width_2B-1 -: width_2B] <= 16'b0;
-        		            end
-        		        endcase
-        		    end
-        		    
-        		    //the left is metadata & conditional ins, no need to modify
-        		    phv_remain_data <= phv_in[255:0];
+        		    ///////////////// see second always block for output assignment /////////////////
         		end 
-
         		else begin
         		    alu_in_valid <= 1'b0;
         		end
@@ -257,4 +182,106 @@
     end
 end
 
+
+always @(posedge clk) begin
+    if(~rst_n) begin
+        alu_in_6B_1 <= 384'b0;
+        alu_in_6B_2 <= 384'b0;
+        alu_in_4B_1 <= 256'b0;
+        alu_in_4B_2 <= 256'b0;
+        alu_in_4B_3 <= 256'b0;
+        alu_in_2B_1 <= 128'b0;
+        alu_in_2B_2 <= 128'b0;
+        
+        phv_remain_data <= 256'b0;
+    end
+    else begin
+        //assign values one by one (of course need to consider act format)
+        for(i=7; i>=0; i=i-1) begin
+            case(sub_action[16+i+1][24:21])
+                //be noted that 2 ops need to be the same width
+                4'b0001, 4'b0010: begin
+                    alu_in_6B_1[(i+1)*width_6B-1 -: width_6B] <= cont_6B[sub_action[16+i+1][18:16]];
+                    alu_in_6B_2[(i+1)*width_6B-1 -: width_6B] <= cont_6B[sub_action[16+i+1][13:11]];
+                end
+                //extracted from action field (imm)
+                4'b1001, 4'b1010: begin
+                    alu_in_6B_1[(i+1)*width_6B-1 -: width_6B] <= cont_6B[sub_action[16+i+1][18:16]];
+                    alu_in_6B_2[(i+1)*width_6B-1 -: width_6B] <= {32'b0,sub_action[16+i+1][15:0]};
+                end
+                // set operation, operand A set to 0, operand B set to imm
+                4'b1110: begin
+                    alu_in_6B_1[(i+1)*width_6B-1 -: width_6B] <= 48'b0;
+                    alu_in_6B_2[(i+1)*width_6B-1 -: width_6B] <= {32'b0,sub_action[16+i+1][15:0]};
+                end
+                //if there is no action to take, output the original value
+                default: begin
+                    //alu_1 should be set to the phv value
+                    alu_in_6B_1[(i+1)*width_6B-1 -: width_6B] <= cont_6B[i];
+                    alu_in_6B_2[(i+1)*width_6B-1 -: width_6B] <= 48'b0;
+                end
+            endcase
+        end
+        //4B is a bit of differernt from 2B and 6B
+        for(i=7; i>=0; i=i-1) begin
+            alu_in_4B_3[(i+1)*width_4B-1 -: width_4B] <= cont_4B[i];
+            casez(sub_action[8+i+1][24:21])
+                //be noted that 2 ops need to be the same width
+                4'b0001, 4'b0010: begin
+                    alu_in_4B_1[(i+1)*width_4B-1 -: width_4B] <= cont_4B[sub_action[8+i+1][18:16]];
+                    alu_in_4B_2[(i+1)*width_4B-1 -: width_4B] <= cont_4B[sub_action[8+i+1][13:11]];
+                end
+                4'b1001, 4'b1010: begin
+                    alu_in_4B_1[(i+1)*width_4B-1 -: width_4B] <= cont_4B[sub_action[8+i+1][18:16]];
+                    alu_in_4B_2[(i+1)*width_4B-1 -: width_4B] <= {16'b0,sub_action[8+i+1][15:0]};
+                end
+                // set operation, operand A set to 0, operand B set to imm
+                4'b1110: begin
+                    alu_in_4B_1[(i+1)*width_4B-1 -: width_4B] <= 32'b0;
+                    alu_in_4B_2[(i+1)*width_4B-1 -: width_4B] <= {16'b0,sub_action[8+i+1][15:0]};
+                end
+                //loadd put here
+                4'b1011, 4'b1000, 4'b0111: begin
+                    alu_in_4B_1[(i+1)*width_4B-1 -: width_4B] <= cont_4B[sub_action[8+i+1][18:16]];
+                    //alu_in_4B_2[(i+1)*width_4B-1 -: width_4B] <= {16'b0,sub_action[8+i+1][15:0]};
+                    alu_in_4B_2[(i+1)*width_4B-1 -: width_4B] <= cont_4B[sub_action[8+i+1][13:11]];
+                end
+                //if there is no action to take, output the original value
+                default: begin
+                    //alu_1 should be set to the phv value
+                    alu_in_4B_1[(i+1)*width_4B-1 -: width_4B] <= cont_4B[i];
+                    alu_in_4B_2[(i+1)*width_4B-1 -: width_4B] <= 32'b0;
+                end
+            endcase
+        end
+        for(i=7; i>=0; i=i-1) begin
+            casez(sub_action[i+1][24:21])
+                //be noted that 2 ops need to be the same width
+                4'b0001, 4'b0010: begin
+                    alu_in_2B_1[(i+1)*width_2B-1 -: width_2B] <= cont_2B[sub_action[i+1][18:16]];
+                    alu_in_2B_2[(i+1)*width_2B-1 -: width_2B] <= cont_2B[sub_action[i+1][13:11]];
+                end
+                4'b1001, 4'b1010: begin
+                    alu_in_2B_1[(i+1)*width_2B-1 -: width_2B] <= cont_2B[sub_action[i+1][18:16]];
+                    alu_in_2B_2[(i+1)*width_2B-1 -: width_2B] <= sub_action[i+1][15:0];
+                end
+                // set operation, operand A set to 0, operand B set to imm
+                4'b1110: begin
+                    alu_in_2B_1[(i+1)*width_2B-1 -: width_2B] <= 16'b0;
+                    alu_in_2B_2[(i+1)*width_2B-1 -: width_2B] <= sub_action[i+1][15:0];
+                end
+                //if there is no action to take, output the original value
+                default: begin
+                    //alu_1 should be set to the phv value
+                    alu_in_2B_1[(i+1)*width_2B-1 -: width_2B] <= cont_2B[i];
+                    alu_in_2B_2[(i+1)*width_2B-1 -: width_2B] <= 16'b0;
+                end
+            endcase
+        end
+        
+        //the left is metadata & conditional ins, no need to modify
+        phv_remain_data <= phv_in_r[255:0];
+    end
+end
+
 endmodule
diff -ruN '--exclude=.git' '--exclude=p4c' '--exclude=tb' menshen/depar_do_deparsing.v parametric_menshen/depar_do_deparsing.v
--- menshen/depar_do_deparsing.v
+++ parametric_menshen/depar_do_deparsing.v
@@ -1,22 +1,5 @@
 `timescale 1ns / 1ps
 
-`define SUB_DEPARSE_1P(idx) \
-	if(parse_action[idx][0]) begin \
-		case(sub_depar_val_out_type_d1[idx]) \
-			2'b01: pkts_tdata_stored_1p_next[parse_action_ind_10b[idx]<<3 +: 16] = sub_depar_val_out_swapped[idx][32+:16]; \
-			2'b10: pkts_tdata_stored_1p_next[parse_action_ind_10b[idx]<<3 +: 32] = sub_depar_val_out_swapped[idx][16+:32]; \
-			2'b11: pkts_tdata_stored_1p_next[parse_action_ind_10b[idx]<<3 +: 48] = sub_depar_val_out_swapped[idx][0+:48]; \
-		endcase \
-	end \
-
-`define SUB_DEPARSE_2P(idx) \
-	if(parse_action[idx][0]) begin \
-		case(sub_depar_val_out_type_d1[idx]) \
-			2'b01: pkts_tdata_stored_2p_next[parse_action_ind_10b[idx]<<3 +: 16] = sub_depar_val_out_swapped[idx][32+:16]; \
-			2'b10: pkts_tdata_stored_2p_next[parse_action_ind_10b[idx]<<3 +: 32] = sub_depar_val_out_swapped[idx][16+:32]; \
-			2'b11: pkts_tdata_stored_2p_next[parse_action_ind_10b[idx]<<3 +: 48] = sub_depar_val_out_swapped[idx][0+:48]; \
-		endcase \
-	end \
 
 `define SWAP_BYTE_ORDER(idx) \
 	assign sub_depar_val_out_swapped[idx] = {	sub_depar_val_out_d1[idx][0+:8], \
@@ -84,13 +67,7 @@
 	input													ctrl_s_axis_tlast
 );
 
-integer i;
-
-reg [C_AXIS_DATA_WIDTH-1:0]						depar_out_tdata_next;
-reg [C_AXIS_DATA_WIDTH/8-1:0]					depar_out_tkeep_next;
-reg [C_AXIS_TUSER_WIDTH-1:0]					depar_out_tuser_next;
-reg												depar_out_tlast_next;
-reg												depar_out_tvalid_next;
+integer i, j;
 
 wire [159:0] bram_out;
 reg [159:0] bram_out_d1;
@@ -98,17 +75,39 @@
 wire [9:0] parse_action_ind_10b [0:9];
 
 
-wire [15:0] parse_action [0:9];		// we have 10 parse action
-assign parse_action[9] = bram_out_d1[0+:16];
-assign parse_action[8] = bram_out_d1[16+:16];
-assign parse_action[7] = bram_out_d1[32+:16];
-assign parse_action[6] = bram_out_d1[48+:16];
-assign parse_action[5] = bram_out_d1[64+:16];
-assign parse_action[4] = bram_out_d1[80+:16];
-assign parse_action[3] = bram_out_d1[96+:16];
-assign parse_action[2] = bram_out_d1[112+:16];
-assign parse_action[1] = bram_out_d1[128+:16];
-assign parse_action[0] = bram_out_d1[144+:16];
+reg [C_PKT_VEC_WIDTH-1:0] sub_depar_in;
+reg [15:0]                parse_action [0:9];		// we have 10 parse action
+
+always @(posedge clk) begin
+    if(~aresetn) begin
+        sub_depar_in <= 0;
+        
+        parse_action[9] <= 0;
+        parse_action[8] <= 0;
+        parse_action[7] <= 0;
+        parse_action[6] <= 0;
+        parse_action[5] <= 0;
+        parse_action[4] <= 0;
+        parse_action[3] <= 0;
+        parse_action[2] <= 0;
+        parse_action[1] <= 0;
+        parse_action[0] <= 0;
+    end
+    else begin
+        sub_depar_in <= phv_fifo_out;
+    
+        parse_action[9] <= bram_out_d1[0+:16];
+        parse_action[8] <= bram_out_d1[16+:16];
+        parse_action[7] <= bram_out_d1[32+:16];
+        parse_action[6] <= bram_out_d1[48+:16];
+        parse_action[5] <= bram_out_d1[64+:16];
+        parse_action[4] <= bram_out_d1[80+:16];
+        parse_action[3] <= bram_out_d1[96+:16];
+        parse_action[2] <= bram_out_d1[112+:16];
+        parse_action[1] <= bram_out_d1[128+:16];
+        parse_action[0] <= bram_out_d1[144+:16];
+    end
+end
 
 assign parse_action_ind[0] = parse_action[0][12:6];
 assign parse_action_ind[1] = parse_action[1][12:6];
@@ -177,34 +176,143 @@
 wire discard_signal;
 assign discard_signal = phv_fifo_out[128];
 
+reg [1:0]                       chunk_index;
+reg [C_AXIS_DATA_WIDTH-1:0]     depar_out_tdata_next[2:0];
+reg [C_AXIS_TUSER_WIDTH-1:0]    depar_out_tuser_next[2:0];
+reg [C_AXIS_DATA_WIDTH/8-1:0]   depar_out_tkeep_next[2:0];
+reg                             depar_out_tlast_next[2:0];
+reg                             depar_out_tvalid_next;
+
+reg [C_AXIS_DATA_WIDTH-1:0]     pkts_tdata_stored [2:0];
+reg [C_AXIS_TUSER_WIDTH-1:0]    pkts_tuser_stored [2:0];
+reg [(C_AXIS_DATA_WIDTH/8)-1:0] pkts_tkeep_stored [2:0];
+reg                             pkts_tlast_stored [2:0];
+
+reg [C_AXIS_DATA_WIDTH-1:0]     temp_pkt_tdata[1:0];
+reg [C_AXIS_DATA_WIDTH-1:0]     mask[1:0];
+
 localparam		IDLE=0,
-				WAIT_1CYCLE_RAM=1,
-				START_SUB_DEPARSE=2,
-				FINISH_SUB_DEPARSER_0=3,
-				FINISH_SUB_DEPARSER_1=4,
-				FINISH_SUB_DEPARSER_2=5,
-				FLUSH_PKT_0=6,
-				FLUSH_PKT_1=7,
-				FLUSH_PKT_2=8,
-				FLUSH_PKT_3=9,
-				FLUSH_PKT=10,
-				DROP_PKT=11,
-				DROP_PKT_REMAINING=12,
-				EMPTY_1=13,
-				EMPTY_2=14;
-
-
-reg [C_AXIS_DATA_WIDTH-1:0]			pkts_tdata_stored_1p, pkts_tdata_stored_2p;
-reg [C_AXIS_TUSER_WIDTH-1:0]		pkts_tuser_stored_1p, pkts_tuser_stored_2p;
-reg [(C_AXIS_DATA_WIDTH/8)-1:0]		pkts_tkeep_stored_1p, pkts_tkeep_stored_2p;
-reg									pkts_tlast_stored_1p, pkts_tlast_stored_2p;
-reg [C_AXIS_DATA_WIDTH-1:0]			pkts_tdata_stored_1p_next, pkts_tdata_stored_2p_next;
-reg [C_AXIS_TUSER_WIDTH-1:0]		pkts_tuser_stored_1p_next, pkts_tuser_stored_2p_next;
-reg [(C_AXIS_DATA_WIDTH/8)-1:0]		pkts_tkeep_stored_1p_next, pkts_tkeep_stored_2p_next;
-reg									pkts_tlast_stored_1p_next, pkts_tlast_stored_2p_next;
+				WAIT_RAM_1=1,
+				WAIT_RAM_2=2,
+				START_SUB_DEPARSE=3,
+				FINISH_SUB_DEPARSER_0=4,
+				FINISH_SUB_DEPARSER_1=5,
+				FINISH_SUB_DEPARSER_2=6,
+				FLUSH_PKT_0=7,
+				FLUSH_PKT_1=8,
+				FLUSH_PKT_2=9,
+				FLUSH_PKT_3=10,
+				FLUSH_PKT=11,
+				DROP_PKT=12,
+				DROP_PKT_REMAINING=13,
+				EMPTY=14;
 
 reg [4:0] state, state_next;
 
+
+always @(posedge clk) begin
+    if(~aresetn) begin
+		state <= IDLE;
+
+        temp_pkt_tdata[0] <= {C_AXIS_DATA_WIDTH{1'b0}};
+        temp_pkt_tdata[1] <= {C_AXIS_DATA_WIDTH{1'b0}};
+		mask[0]            <= {C_AXIS_DATA_WIDTH{1'b1}};
+		mask[1]            <= {C_AXIS_DATA_WIDTH{1'b1}};
+        
+		for (j=0; j<3; j=j+1) begin
+			pkts_tdata_stored[j] <= 0;
+			pkts_tuser_stored[j] <= 0;
+			pkts_tkeep_stored[j] <= 0;
+			pkts_tlast_stored[j] <= 0;
+
+			depar_out_tdata_next[j] <= 0;
+			depar_out_tuser_next[j] <= 0;
+			depar_out_tkeep_next[j] <= 0;
+			depar_out_tlast_next[j] <= 0;
+		end
+
+		depar_out_tdata <= 0;
+        depar_out_tkeep <= 0;
+        depar_out_tuser <= 0;
+        depar_out_tlast <= 0;
+        depar_out_tvalid <= 0;
+	end
+    else begin
+		state <= state_next;
+
+        temp_pkt_tdata[0] <= {C_AXIS_DATA_WIDTH{1'b0}};
+        temp_pkt_tdata[1] <= {C_AXIS_DATA_WIDTH{1'b0}};
+		mask[0]            <= {C_AXIS_DATA_WIDTH{1'b1}};
+		mask[1]            <= {C_AXIS_DATA_WIDTH{1'b1}};
+
+        for (j=0; j<5; j=j+1) begin
+            if(parse_action[j][0] & sub_depar_val_out_valid_d1[j]) begin
+                case(sub_depar_val_out_type_d1[j])
+                    2'b01: begin
+						   temp_pkt_tdata[0][parse_action_ind_10b[j]<<3 +: 16] <= sub_depar_val_out_swapped[j][32+:16];
+						   mask[0][parse_action_ind_10b[j]<<3 +: 16] <= 16'b0;
+					end
+                    2'b10: begin
+						   temp_pkt_tdata[0][parse_action_ind_10b[j]<<3 +: 32] <= sub_depar_val_out_swapped[j][16+:32];
+						   mask[0][parse_action_ind_10b[j]<<3 +: 32] <= 32'b0;
+					end
+                    2'b11: begin
+						   temp_pkt_tdata[0][parse_action_ind_10b[j]<<3 +: 48] <= sub_depar_val_out_swapped[j][0+:48];
+						   mask[0][parse_action_ind_10b[j]<<3 +: 48] <= 48'b0;
+					end
+                endcase
+            end
+            
+            if(parse_action[j+5][0]) begin
+                case(sub_depar_val_out_type_d1[j+5] & sub_depar_val_out_valid_d1[j+5])
+                    2'b01: begin
+						   temp_pkt_tdata[1][parse_action_ind_10b[j+5]<<3 +: 16] <= sub_depar_val_out_swapped[j+5][32+:16];
+						   mask[1][parse_action_ind_10b[j]<<3 +: 16] <= 16'b0;
+					end
+                    2'b10: begin
+						   temp_pkt_tdata[1][parse_action_ind_10b[j+5]<<3 +: 32] <= sub_depar_val_out_swapped[j+5][16+:32];
+						   mask[1][parse_action_ind_10b[j]<<3 +: 32] <= 32'b0;
+					end
+                    2'b11: begin
+						   temp_pkt_tdata[1][parse_action_ind_10b[j+5]<<3 +: 48] <= sub_depar_val_out_swapped[j+5][0+:48];
+						   mask[1][parse_action_ind_10b[j]<<3 +: 48] <= 48'b0;
+					end
+                endcase
+            end
+        end
+
+        pkts_tdata_stored[0] <= (fst_half_fifo_tdata & mask[0]) | temp_pkt_tdata[0];
+        pkts_tuser_stored[0] <= phv_fifo_out[0+:C_AXIS_TUSER_WIDTH];
+        pkts_tkeep_stored[0] <= fst_half_fifo_tkeep;
+        pkts_tlast_stored[0] <= fst_half_fifo_tlast;
+
+        pkts_tdata_stored[1] <= (snd_half_fifo_tdata & mask[1]) | temp_pkt_tdata[1];
+        pkts_tuser_stored[1] <= snd_half_fifo_tuser;
+        pkts_tkeep_stored[1] <= snd_half_fifo_tkeep;
+        pkts_tlast_stored[1] <= snd_half_fifo_tlast;
+        
+        pkts_tdata_stored[2] <= pkt_fifo_tdata;
+        pkts_tuser_stored[2] <= pkt_fifo_tuser;
+        pkts_tkeep_stored[2] <= pkt_fifo_tkeep;
+        pkts_tlast_stored[2] <= pkt_fifo_tlast;
+        
+        
+		for (j=0; j<3; j=j+1) begin
+			depar_out_tdata_next[j] <= pkts_tdata_stored[j];
+			depar_out_tuser_next[j] <= pkts_tuser_stored[j];
+			depar_out_tkeep_next[j] <= pkts_tkeep_stored[j];
+			depar_out_tlast_next[j] <= pkts_tlast_stored[j];
+		end
+
+        depar_out_tdata <= depar_out_tdata_next[chunk_index];
+        depar_out_tkeep <= depar_out_tkeep_next[chunk_index];
+        depar_out_tuser <= depar_out_tuser_next[chunk_index];
+        depar_out_tlast <= depar_out_tlast_next[chunk_index];
+        depar_out_tvalid <= depar_out_tvalid_next;
+    end
+end
+
+
 always @(*) begin
 
 	phv_fifo_rd_en = 0;
@@ -212,37 +320,22 @@
 	fst_half_fifo_rd_en = 0;
 	snd_half_fifo_rd_en = 0;
 	pkt_fifo_rd_en = 0;
-	// output
-	depar_out_tdata_next = depar_out_tdata;
-	depar_out_tuser_next = depar_out_tuser;
-	depar_out_tkeep_next = depar_out_tkeep;
-	depar_out_tlast_next = depar_out_tlast;
 	depar_out_tvalid_next = 0;
-
 	sub_depar_act_valid = 10'b0;
+	chunk_index = 0;
 
 	state_next = state;
-	//
-	pkts_tdata_stored_1p_next = pkts_tdata_stored_1p;
-	pkts_tuser_stored_1p_next = pkts_tuser_stored_1p;
-	pkts_tkeep_stored_1p_next = pkts_tkeep_stored_1p;
-	pkts_tlast_stored_1p_next = pkts_tlast_stored_1p;
-	//
-	pkts_tdata_stored_2p_next = pkts_tdata_stored_2p;
-	pkts_tuser_stored_2p_next = pkts_tuser_stored_2p;
-	pkts_tkeep_stored_2p_next = pkts_tkeep_stored_2p;
-	pkts_tlast_stored_2p_next = pkts_tlast_stored_2p;
 
 	case (state) 
 		IDLE: begin
 			if (!vlan_fifo_empty) begin
-				state_next = WAIT_1CYCLE_RAM;
+				state_next = WAIT_RAM_1;
 			end
 		end
-		WAIT_1CYCLE_RAM: begin
-			state_next = START_SUB_DEPARSE;
+		WAIT_RAM_1: begin
+			state_next = WAIT_RAM_2;
 		end
-		START_SUB_DEPARSE: begin
+		WAIT_RAM_2: begin
 			if (!fst_half_fifo_empty 
 					&& !snd_half_fifo_empty 
 					&& !phv_fifo_empty) begin
@@ -252,47 +345,45 @@
 					phv_fifo_rd_en = 1;
 				end
 				else begin
-					sub_depar_act_valid = 10'b1111111111;
-
-					state_next = EMPTY_2;
-					pkts_tdata_stored_1p_next = fst_half_fifo_tdata;
-					pkts_tuser_stored_1p_next = phv_fifo_out[0+:128];
-					pkts_tkeep_stored_1p_next = fst_half_fifo_tkeep;
-					pkts_tlast_stored_1p_next = fst_half_fifo_tlast;
+					state_next = START_SUB_DEPARSE;
+					// pkts_tdata_stored_1p_next = fst_half_fifo_tdata;
+					// pkts_tuser_stored_1p_next = phv_fifo_out[0+:C_AXIS_TUSER_WIDTH];
+					// pkts_tkeep_stored_1p_next = fst_half_fifo_tkeep;
+					// pkts_tlast_stored_1p_next = fst_half_fifo_tlast;
 					//
 				end
 			end
 		end
-		EMPTY_1: begin
-			// sub_depar_act_valid = 10'b1111111111;
-			state_next = EMPTY_2;
+		START_SUB_DEPARSE: begin
+			sub_depar_act_valid = 10'b1111111111;
+			state_next = EMPTY;
 		end
-		EMPTY_2: begin
+		EMPTY: begin
 			state_next = FINISH_SUB_DEPARSER_0;
-			pkts_tdata_stored_2p_next = snd_half_fifo_tdata;
-			pkts_tuser_stored_2p_next = snd_half_fifo_tuser;
-			pkts_tkeep_stored_2p_next = snd_half_fifo_tkeep;
-			pkts_tlast_stored_2p_next = snd_half_fifo_tlast;
+			// pkts_tdata_stored_2p_next = snd_half_fifo_tdata;
+			// pkts_tuser_stored_2p_next = snd_half_fifo_tuser;
+			// pkts_tkeep_stored_2p_next = snd_half_fifo_tkeep;
+			// pkts_tlast_stored_2p_next = snd_half_fifo_tlast;
 		end
 		FINISH_SUB_DEPARSER_0: begin
-			`SUB_DEPARSE_1P(0)
-			`SUB_DEPARSE_1P(1)
-			`SUB_DEPARSE_2P(5)
+			// `SUB_DEPARSE_1P(0)
+			// `SUB_DEPARSE_1P(1)
+			// `SUB_DEPARSE_2P(5)
 
 			state_next = FINISH_SUB_DEPARSER_1;
 		end
 		FINISH_SUB_DEPARSER_1: begin
-			`SUB_DEPARSE_1P(2)
-			`SUB_DEPARSE_2P(6)
-			`SUB_DEPARSE_2P(7)
+			// `SUB_DEPARSE_1P(2)
+			// `SUB_DEPARSE_2P(6)
+			// `SUB_DEPARSE_2P(7)
 
 			state_next = FINISH_SUB_DEPARSER_2;
 		end
 		FINISH_SUB_DEPARSER_2: begin
-			`SUB_DEPARSE_1P(3)
-			`SUB_DEPARSE_1P(4)
-			`SUB_DEPARSE_2P(8)
-			`SUB_DEPARSE_2P(9)
+			// `SUB_DEPARSE_1P(3)
+			// `SUB_DEPARSE_1P(4)
+			// `SUB_DEPARSE_2P(8)
+			// `SUB_DEPARSE_2P(9)
 
 			state_next = FLUSH_PKT_0;
 		end
@@ -301,15 +392,15 @@
 			vlan_fifo_rd_en = 1;
 			fst_half_fifo_rd_en = 1;
 			snd_half_fifo_rd_en = 1;
-
-			depar_out_tdata_next = pkts_tdata_stored_1p;
-			depar_out_tuser_next = pkts_tuser_stored_1p;
-			depar_out_tkeep_next = pkts_tkeep_stored_1p;
-			depar_out_tlast_next = pkts_tlast_stored_1p;
+			chunk_index = 0;
+			// depar_out_tdata_next = pkts_tdata_stored_1p;
+			// depar_out_tuser_next = pkts_tuser_stored_1p;
+			// depar_out_tkeep_next = pkts_tkeep_stored_1p;
+			// depar_out_tlast_next = pkts_tlast_stored_1p;
 
 			if (depar_out_tready) begin
 				depar_out_tvalid_next = 1;
-				if (pkts_tlast_stored_1p) begin
+				if (pkts_tlast_stored[0]) begin
 					state_next = IDLE;
 				end
 				else begin
@@ -318,14 +409,15 @@
 			end
 		end
 		FLUSH_PKT_1: begin
-			depar_out_tdata_next = pkts_tdata_stored_2p;
-			depar_out_tuser_next = pkts_tuser_stored_2p;
-			depar_out_tkeep_next = pkts_tkeep_stored_2p;
-			depar_out_tlast_next = pkts_tlast_stored_2p;
+			chunk_index = 1;
+			// depar_out_tdata_next = pkts_tdata_stored_2p;
+			// depar_out_tuser_next = pkts_tuser_stored_2p;
+			// depar_out_tkeep_next = pkts_tkeep_stored_2p;
+			// depar_out_tlast_next = pkts_tlast_stored_2p;
 
 			if (depar_out_tready) begin
 				depar_out_tvalid_next = 1;
-				if (pkts_tlast_stored_2p) begin
+				if (pkts_tlast_stored[1]) begin
 					state_next = IDLE;
 				end
 				else begin
@@ -334,11 +426,12 @@
 			end
 		end
 		FLUSH_PKT: begin
+			chunk_index = 2;
 			if (!pkt_fifo_empty) begin
-				depar_out_tdata_next = pkt_fifo_tdata;
-				depar_out_tuser_next =  pkt_fifo_tuser;
-				depar_out_tkeep_next =  pkt_fifo_tkeep;
-				depar_out_tlast_next =  pkt_fifo_tlast;
+				// depar_out_tdata_next = pkt_fifo_tdata;
+				// depar_out_tuser_next =  pkt_fifo_tuser;
+				// depar_out_tkeep_next =  pkt_fifo_tkeep;
+				// depar_out_tlast_next =  pkt_fifo_tlast;
 				if (depar_out_tready) begin
 					pkt_fifo_rd_en = 1;
 					depar_out_tvalid_next = 1;
@@ -374,46 +467,46 @@
 	endcase
 end
 
-always @(posedge clk) begin
-	if (~aresetn) begin
-		state <= IDLE;
-		//
-		pkts_tdata_stored_1p <= 0;
-		pkts_tuser_stored_1p <= 0;
-		pkts_tkeep_stored_1p <= 0;
-		pkts_tlast_stored_1p <= 0;
-		//
-		pkts_tdata_stored_2p <= 0;
-		pkts_tuser_stored_2p <= 0;
-		pkts_tkeep_stored_2p <= 0;
-		pkts_tlast_stored_2p <= 0;
-		//
-		depar_out_tdata <= 0;
-		depar_out_tkeep <= 0;
-		depar_out_tuser <= 0;
-		depar_out_tlast <= 0;
-		depar_out_tvalid <= 0;
-	end
-	else begin
-		state <= state_next;
-		//
-		pkts_tdata_stored_1p <= pkts_tdata_stored_1p_next;
-		pkts_tuser_stored_1p <= pkts_tuser_stored_1p_next;
-		pkts_tkeep_stored_1p <= pkts_tkeep_stored_1p_next;
-		pkts_tlast_stored_1p <= pkts_tlast_stored_1p_next;
-		//
-		pkts_tdata_stored_2p <= pkts_tdata_stored_2p_next;
-		pkts_tuser_stored_2p <= pkts_tuser_stored_2p_next;
-		pkts_tkeep_stored_2p <= pkts_tkeep_stored_2p_next;
-		pkts_tlast_stored_2p <= pkts_tlast_stored_2p_next;
-		//
-		depar_out_tdata <= depar_out_tdata_next;
-		depar_out_tkeep <= depar_out_tkeep_next;
-		depar_out_tuser <= depar_out_tuser_next;
-		depar_out_tlast <= depar_out_tlast_next;
-		depar_out_tvalid <= depar_out_tvalid_next;
-	end
-end
+// always @(posedge clk) begin
+// 	if (~aresetn) begin
+// 		state <= IDLE;
+// 		//
+// 		pkts_tdata_stored_1p <= 0;
+// 		pkts_tuser_stored_1p <= 0;
+// 		pkts_tkeep_stored_1p <= 0;
+// 		pkts_tlast_stored_1p <= 0;
+// 		//
+// 		pkts_tdata_stored_2p <= 0;
+// 		pkts_tuser_stored_2p <= 0;
+// 		pkts_tkeep_stored_2p <= 0;
+// 		pkts_tlast_stored_2p <= 0;
+// 		//
+// 		depar_out_tdata <= 0;
+// 		depar_out_tkeep <= 0;
+// 		depar_out_tuser <= 0;
+// 		depar_out_tlast <= 0;
+// 		depar_out_tvalid <= 0;
+// 	end
+// 	else begin
+// 		state <= state_next;
+// 		//
+// 		pkts_tdata_stored_1p <= pkts_tdata_stored_1p_next;
+// 		pkts_tuser_stored_1p <= pkts_tuser_stored_1p_next;
+// 		pkts_tkeep_stored_1p <= pkts_tkeep_stored_1p_next;
+// 		pkts_tlast_stored_1p <= pkts_tlast_stored_1p_next;
+// 		//
+// 		pkts_tdata_stored_2p <= pkts_tdata_stored_2p_next;
+// 		pkts_tuser_stored_2p <= pkts_tuser_stored_2p_next;
+// 		pkts_tkeep_stored_2p <= pkts_tkeep_stored_2p_next;
+// 		pkts_tlast_stored_2p <= pkts_tlast_stored_2p_next;
+// 		//
+// 		depar_out_tdata <= depar_out_tdata_next;
+// 		depar_out_tkeep <= depar_out_tkeep_next;
+// 		depar_out_tuser <= depar_out_tuser_next;
+// 		depar_out_tlast <= depar_out_tlast_next;
+// 		depar_out_tvalid <= depar_out_tvalid_next;
+// 	end
+// end
 
 
 //===================== sub deparser
@@ -430,7 +523,7 @@
 			.aresetn			(aresetn),
 			.parse_act_valid	(sub_depar_act_valid[index]),
 			.parse_act			(parse_action[index][5:0]),
-			.phv_in				(phv_fifo_out),
+			.phv_in				(sub_depar_in),
 			.val_out_valid		(sub_depar_val_out_valid[index]),
 			.val_out			(sub_depar_val_out[index]),
 			.val_out_type		(sub_depar_val_out_type[index])
@@ -454,7 +547,7 @@
            SU_WRITE_C = 3;
 
 assign mod_id = ctrl_s_axis_tdata[368+:8];
-assign control_flag = ctrl_s_axis_tdata[335:320];
+assign control_flag = ctrl_s_axis_tdata[303:288];
 
 //LE to BE switching
 wire[C_AXIS_DATA_WIDTH-1:0] ctrl_s_axis_tdata_swapped;
diff -ruN '--exclude=.git' '--exclude=p4c' '--exclude=tb' menshen/deparser_top.v parametric_menshen/deparser_top.v
--- menshen/deparser_top.v
+++ parametric_menshen/deparser_top.v
@@ -142,16 +142,16 @@
 wire [C_AXIS_TUSER_WIDTH-1:0]	seg_fifo_tuser_in, seg_fifo_tuser_out;
 wire [C_AXIS_DATA_WIDTH/8-1:0]	seg_fifo_tkeep_in, seg_fifo_tkeep_out;
 wire							seg_fifo_tlast_in, seg_fifo_tlast_out;
-wire seg_fifo_valid_in;
-wire seg_fifo_rd_en;
-wire seg_fifo_full;
-wire seg_fifo_empty;
-
-reg [C_AXIS_DATA_WIDTH-1:0]		seg_fifo_tdata_in_r;
-reg [C_AXIS_TUSER_WIDTH-1:0]	seg_fifo_tuser_in_r;
-reg [C_AXIS_DATA_WIDTH/8-1:0]	seg_fifo_tkeep_in_r;
-reg								seg_fifo_tlast_in_r;
-reg								seg_fifo_valid_in_r;
+wire                            seg_fifo_valid_in, seg_fifo_rd_en;
+wire                            seg_fifo_full;
+wire                            seg_fifo_empty;
+
+reg [C_AXIS_DATA_WIDTH-1:0]		seg_fifo_tdata_in_r, seg_fifo_tdata_out_r;
+reg [C_AXIS_TUSER_WIDTH-1:0]	seg_fifo_tuser_in_r, seg_fifo_tuser_out_r;
+reg [C_AXIS_DATA_WIDTH/8-1:0]	seg_fifo_tkeep_in_r, seg_fifo_tkeep_out_r;
+reg								seg_fifo_tlast_in_r, seg_fifo_tlast_out_r;
+reg								seg_fifo_valid_in_r, seg_fifo_rd_en_r;
+reg                             seg_fifo_empty_r;
 // seg fifo
 fallthrough_small_fifo #(
 	.WIDTH(C_AXIS_DATA_WIDTH+C_AXIS_TUSER_WIDTH+C_AXIS_DATA_WIDTH/8+1),
@@ -163,7 +163,7 @@
 	// .din					({seg_fifo_tdata_in, seg_fifo_tuser_in, seg_fifo_tkeep_in, seg_fifo_tlast_in}),
 	// .wr_en					(seg_fifo_valid_in),
 	//
-	.rd_en					(seg_fifo_rd_en),
+	.rd_en					(seg_fifo_rd_en_r),
 	.dout					({seg_fifo_tdata_out, seg_fifo_tuser_out, seg_fifo_tkeep_out, seg_fifo_tlast_out}),
 	//
 	.full					(),
@@ -176,6 +176,7 @@
 
 //
 depar_wait_segs #(
+    .C_AXIS_TUSER_WIDTH(C_AXIS_TUSER_WIDTH)
 )
 wait_segs
 (
@@ -218,7 +219,8 @@
 //
 depar_do_deparsing #(
 	.C_PKT_VEC_WIDTH(C_PKT_VEC_WIDTH),
-	.DEPARSER_MOD_ID(DEPARSER_MOD_ID)
+	.DEPARSER_MOD_ID(DEPARSER_MOD_ID),
+	.C_AXIS_TUSER_WIDTH(C_AXIS_TUSER_WIDTH)
 )
 do_deparsing
 (
@@ -247,11 +249,11 @@
 	.snd_half_fifo_empty						(snd_half_fifo_empty),
 	.snd_half_fifo_rd_en						(snd_half_fifo_rd_en),
 	// segs
-	.pkt_fifo_tdata								(seg_fifo_tdata_out),
-	.pkt_fifo_tuser								(seg_fifo_tuser_out),
-	.pkt_fifo_tkeep								(seg_fifo_tkeep_out),
-	.pkt_fifo_tlast								(seg_fifo_tlast_out),
-	.pkt_fifo_empty								(seg_fifo_empty),
+	.pkt_fifo_tdata								(seg_fifo_tdata_out_r),
+	.pkt_fifo_tuser								(seg_fifo_tuser_out_r),
+	.pkt_fifo_tkeep								(seg_fifo_tkeep_out_r),
+	.pkt_fifo_tlast								(seg_fifo_tlast_out_r),
+	.pkt_fifo_empty								(seg_fifo_empty_r),
 	.pkt_fifo_rd_en								(seg_fifo_rd_en),
 	// output
 	.depar_out_tdata							(depar_out_tdata),
@@ -289,6 +291,13 @@
 		seg_fifo_tkeep_in_r <= 0;
 		seg_fifo_tlast_in_r <= 0;
 		seg_fifo_valid_in_r <= 0;
+		//
+		seg_fifo_tdata_out_r <= 0;
+		seg_fifo_tuser_out_r <= 0;
+		seg_fifo_tkeep_out_r <= 0;
+		seg_fifo_tlast_out_r <= 0;
+		seg_fifo_rd_en_r <= 0;
+		seg_fifo_empty_r <= 0;
 	end
 	else begin
 		//
@@ -309,6 +318,13 @@
 		seg_fifo_tkeep_in_r <= seg_fifo_tkeep_in;
 		seg_fifo_tlast_in_r <= seg_fifo_tlast_in;
 		seg_fifo_valid_in_r <= seg_fifo_valid_in;
+		//
+		seg_fifo_tdata_out_r <= seg_fifo_tdata_out;
+		seg_fifo_tuser_out_r <= seg_fifo_tuser_out;
+		seg_fifo_tkeep_out_r <= seg_fifo_tkeep_out;
+		seg_fifo_tlast_out_r <= seg_fifo_tlast_out;
+		seg_fifo_rd_en_r <= seg_fifo_rd_en;
+		seg_fifo_empty_r <= seg_fifo_empty;
 	end
 end
 
diff -ruN '--exclude=.git' '--exclude=p4c' '--exclude=tb' menshen/depar_wait_segs.v parametric_menshen/depar_wait_segs.v
--- menshen/depar_wait_segs.v
+++ parametric_menshen/depar_wait_segs.v
@@ -68,6 +68,12 @@
 reg vlan_valid_next;
 reg [11:0] vlan_next;
 
+reg         output_fifo_valid_r;
+reg         fst_half_valid_r;
+reg         snd_half_valid_r;
+reg         vlan_valid_r;
+reg [11:0]  vlan_r;
+
 reg [2:0] state, state_next;
 
 // we delay the processing of PHV to the next module
@@ -77,52 +83,52 @@
 
 	pkt_fifo_rd_en = 0;
 
-	fst_half_tdata_next = 0;
-	fst_half_tuser_next = 0;
-	fst_half_tkeep_next = 0;
-	fst_half_tlast_next = 0;
-
-	snd_half_tdata_next = 0;
-	snd_half_tuser_next = 0;
-	snd_half_tkeep_next = 0;
-	snd_half_tlast_next = 0;
-
-	fst_half_valid_next = 0;
-	snd_half_valid_next = 0;
-	vlan_valid_next = 0;
-	vlan_next = vlan;
-
-	// output remaining segs
-	output_fifo_tdata_next = 0;
-	output_fifo_tuser_next = 0;
-	output_fifo_tkeep_next = 0;
-	output_fifo_tlast_next = 0;
-	output_fifo_valid_next = 0;
+	// fst_half_tdata_next = 0;
+	// fst_half_tuser_next = 0;
+	// fst_half_tkeep_next = 0;
+	// fst_half_tlast_next = 0;
+
+	// snd_half_tdata_next = 0;
+	// snd_half_tuser_next = 0;
+	// snd_half_tkeep_next = 0;
+	// snd_half_tlast_next = 0;
+
+	// // output remaining segs
+	// output_fifo_tdata_next = 0;
+	// output_fifo_tuser_next = 0;
+	// output_fifo_tkeep_next = 0;
+	// output_fifo_tlast_next = 0;
+
+	output_fifo_valid_r = 0;
+	fst_half_valid_r = 0;
+	snd_half_valid_r = 0;
+	vlan_valid_r = 0;
+	vlan_r = vlan;
 
 	case (state)
 		WAIT_FIRST_SEG: begin
 			if (!pkt_fifo_empty) begin
-				fst_half_tdata_next = pkt_fifo_tdata;
-				fst_half_tuser_next = pkt_fifo_tuser;
-				fst_half_tkeep_next = pkt_fifo_tkeep;
-				fst_half_tlast_next = pkt_fifo_tlast;
+				// fst_half_tdata_next = pkt_fifo_tdata;
+				// fst_half_tuser_next = pkt_fifo_tuser;
+				// fst_half_tkeep_next = pkt_fifo_tkeep;
+				// fst_half_tlast_next = pkt_fifo_tlast;
 
-				vlan_next = pkt_fifo_tdata[116+:12];
+				vlan_r = pkt_fifo_tdata[288+:12];
 
 				if (pkt_fifo_tlast) begin
 					if (fst_half_fifo_ready && snd_half_fifo_ready) begin
 						pkt_fifo_rd_en = 1;
-						fst_half_valid_next = 1;
-						snd_half_valid_next = 1;
-						vlan_valid_next = 1;
+						fst_half_valid_r = 1;
+						snd_half_valid_r = 1;
+						vlan_valid_r = 1;
 						state_next = WAIT_FIRST_SEG;
 					end
 				end
 				else begin
 					if (fst_half_fifo_ready) begin
 						pkt_fifo_rd_en = 1;
-						fst_half_valid_next = 1;
-						vlan_valid_next = 1;
+						fst_half_valid_r = 1;
+						vlan_valid_r = 1;
 						state_next = WAIT_SECOND_SEG;
 					end
 				end
@@ -130,23 +136,23 @@
 		end
 		WAIT_SECOND_SEG: begin
 			if (!pkt_fifo_empty) begin
-				snd_half_tdata_next = pkt_fifo_tdata;
-				snd_half_tuser_next = pkt_fifo_tuser;
-				snd_half_tkeep_next = pkt_fifo_tkeep;
-				snd_half_tlast_next = pkt_fifo_tlast;
+				// snd_half_tdata_next = pkt_fifo_tdata;
+				// snd_half_tuser_next = pkt_fifo_tuser;
+				// snd_half_tkeep_next = pkt_fifo_tkeep;
+				// snd_half_tlast_next = pkt_fifo_tlast;
 
 
 				if (pkt_fifo_tlast) begin
 					if (snd_half_fifo_ready) begin
 						pkt_fifo_rd_en = 1;
-						snd_half_valid_next = 1;
+						snd_half_valid_r = 1;
 						state_next = WAIT_FIRST_SEG;
 					end
 				end
 				else begin
 					if (snd_half_fifo_ready) begin
 						pkt_fifo_rd_en = 1;
-						snd_half_valid_next = 1;
+						snd_half_valid_r = 1;
 						state_next = FLUSH_SEG;
 					end
 				end
@@ -154,13 +160,13 @@
 		end
 		FLUSH_SEG: begin
 			if (!pkt_fifo_empty) begin
-				output_fifo_tdata_next = pkt_fifo_tdata;
-				output_fifo_tuser_next = pkt_fifo_tuser;
-				output_fifo_tkeep_next = pkt_fifo_tkeep;
-				output_fifo_tlast_next = pkt_fifo_tlast;
+				// output_fifo_tdata_next = pkt_fifo_tdata;
+				// output_fifo_tuser_next = pkt_fifo_tuser;
+				// output_fifo_tkeep_next = pkt_fifo_tkeep;
+				// output_fifo_tlast_next = pkt_fifo_tlast;
 
 				if (output_fifo_ready) begin
-					output_fifo_valid_next = 1;
+					output_fifo_valid_r = 1;
 					pkt_fifo_rd_en = 1;
 					if (pkt_fifo_tlast) begin
 						state_next = WAIT_FIRST_SEG;
@@ -171,6 +177,53 @@
 	endcase
 end
 
+always @(posedge clk) begin
+    if (~aresetn) begin
+        fst_half_tdata_next <= 0;
+        fst_half_tuser_next <= 0;
+        fst_half_tkeep_next <= 0;
+        fst_half_tlast_next <= 0;
+
+        snd_half_tdata_next <= 0;
+        snd_half_tuser_next <= 0;
+        snd_half_tkeep_next <= 0;
+        snd_half_tlast_next <= 0;
+
+        output_fifo_tdata_next <= 0;
+        output_fifo_tuser_next <= 0;
+        output_fifo_tkeep_next <= 0;
+        output_fifo_tlast_next <= 0;
+        
+        output_fifo_valid_next <= 0;
+	    fst_half_valid_next <= 0;
+	    snd_half_valid_next <= 0;
+	    vlan_valid_next <= 0;
+	    vlan_next <= 0;
+    end
+    else begin
+	    fst_half_tdata_next <= pkt_fifo_tdata;
+        fst_half_tuser_next <= pkt_fifo_tuser;
+        fst_half_tkeep_next <= pkt_fifo_tkeep;
+        fst_half_tlast_next <= pkt_fifo_tlast;
+
+        snd_half_tdata_next <= pkt_fifo_tdata;
+        snd_half_tuser_next <= pkt_fifo_tuser;
+        snd_half_tkeep_next <= pkt_fifo_tkeep;
+        snd_half_tlast_next <= pkt_fifo_tlast;
+
+        output_fifo_tdata_next <= pkt_fifo_tdata;
+        output_fifo_tuser_next <= pkt_fifo_tuser;
+        output_fifo_tkeep_next <= pkt_fifo_tkeep;
+        output_fifo_tlast_next <= pkt_fifo_tlast;
+        
+        output_fifo_valid_next <= output_fifo_valid_r;
+	    fst_half_valid_next <= fst_half_valid_r;
+	    snd_half_valid_next <= snd_half_valid_r;
+	    vlan_valid_next <= vlan_valid_r;
+	    vlan_next <= vlan_r;
+    end
+end
+
 
 always @(posedge clk) begin
 	if (~aresetn) begin
diff -ruN '--exclude=.git' '--exclude=p4c' '--exclude=tb' menshen/extract/key_extract_top.v parametric_menshen/extract/key_extract_top.v
--- menshen/extract/key_extract_top.v
+++ parametric_menshen/extract/key_extract_top.v
@@ -153,18 +153,6 @@
 
 
 
-
-
-
-
-
-
-
-
-
-
-
-
 //======================================================================================
 /****control path for 512b*****/
 wire [7:0]          mod_id; //module ID
@@ -187,507 +175,252 @@
            SU_WRITE_MASK_C = 5,
 		   FLUSH_PKT_C = 6;
 
-generate 
-    if(C_S_AXIS_DATA_WIDTH == 512) begin
-        assign mod_id = c_s_axis_tdata[368+:8];
-        //4'b0 for key offset
-        //4'b1 for key mask
-        assign resv = c_s_axis_tdata[376+:4];
-        assign control_flag = c_s_axis_tdata[335:320];
-
-        reg [37:0]                    key_off_entry_reg;
-        reg [192:0]                   key_mask_entry_reg;
-        //LE to BE switching
-        wire[C_S_AXIS_DATA_WIDTH-1:0] c_s_axis_tdata_swapped;
-
-		assign c_s_axis_tdata_swapped = {	c_s_axis_tdata[0+:8],
-											c_s_axis_tdata[8+:8],
-											c_s_axis_tdata[16+:8],
-											c_s_axis_tdata[24+:8],
-											c_s_axis_tdata[32+:8],
-											c_s_axis_tdata[40+:8],
-											c_s_axis_tdata[48+:8],
-											c_s_axis_tdata[56+:8],
-											c_s_axis_tdata[64+:8],
-											c_s_axis_tdata[72+:8],
-											c_s_axis_tdata[80+:8],
-											c_s_axis_tdata[88+:8],
-											c_s_axis_tdata[96+:8],
-											c_s_axis_tdata[104+:8],
-											c_s_axis_tdata[112+:8],
-											c_s_axis_tdata[120+:8],
-											c_s_axis_tdata[128+:8],
-											c_s_axis_tdata[136+:8],
-											c_s_axis_tdata[144+:8],
-											c_s_axis_tdata[152+:8],
-											c_s_axis_tdata[160+:8],
-											c_s_axis_tdata[168+:8],
-											c_s_axis_tdata[176+:8],
-											c_s_axis_tdata[184+:8],
-											c_s_axis_tdata[192+:8],
-											c_s_axis_tdata[200+:8],
-											c_s_axis_tdata[208+:8],
-											c_s_axis_tdata[216+:8],
-											c_s_axis_tdata[224+:8],
-											c_s_axis_tdata[232+:8],
-											c_s_axis_tdata[240+:8],
-											c_s_axis_tdata[248+:8],
-                                            c_s_axis_tdata[256+:8],
-                                            c_s_axis_tdata[264+:8],
-                                            c_s_axis_tdata[272+:8],
-                                            c_s_axis_tdata[280+:8],
-                                            c_s_axis_tdata[288+:8],
-                                            c_s_axis_tdata[296+:8],
-                                            c_s_axis_tdata[304+:8],
-                                            c_s_axis_tdata[312+:8],
-                                            c_s_axis_tdata[320+:8],
-                                            c_s_axis_tdata[328+:8],
-                                            c_s_axis_tdata[336+:8],
-                                            c_s_axis_tdata[344+:8],
-                                            c_s_axis_tdata[352+:8],
-                                            c_s_axis_tdata[360+:8],
-                                            c_s_axis_tdata[368+:8],
-                                            c_s_axis_tdata[376+:8],
-                                            c_s_axis_tdata[384+:8],
-                                            c_s_axis_tdata[392+:8],
-                                            c_s_axis_tdata[400+:8],
-                                            c_s_axis_tdata[408+:8],
-                                            c_s_axis_tdata[416+:8],
-                                            c_s_axis_tdata[424+:8],
-                                            c_s_axis_tdata[432+:8],
-                                            c_s_axis_tdata[440+:8],
-                                            c_s_axis_tdata[448+:8],
-                                            c_s_axis_tdata[456+:8],
-                                            c_s_axis_tdata[464+:8],
-                                            c_s_axis_tdata[472+:8],
-                                            c_s_axis_tdata[480+:8],
-                                            c_s_axis_tdata[488+:8],
-                                            c_s_axis_tdata[496+:8],
-                                            c_s_axis_tdata[504+:8]
-                                            };
-        always @(posedge clk or negedge rst_n) begin
-            if(~rst_n) begin
-                c_wr_en_off <= 1'b0;
-                c_wr_en_mask <= 1'b0;
-                c_index <= 8'b0;
-        
-                c_m_axis_tdata <= 0;
-                c_m_axis_tuser <= 0;
-                c_m_axis_tkeep <= 0;
-                c_m_axis_tvalid <= 0;
-                c_m_axis_tlast <= 0;
-
-                key_off_entry_reg <= 0;
-                key_mask_entry_reg <= 0;
-        
-                c_state <= IDLE_C;
-        
-            end
-            else begin
-                case(c_state)
-                    IDLE_C: begin
-                        if(c_s_axis_tvalid && mod_id[7:3] == STAGE_ID && mod_id[2:0] == KEY_EX_ID &&
-                         control_flag == 16'hf2f1)begin
-                            //c_wr_en <= 1'b1;
-                            c_index <= c_s_axis_tdata[384+:8];
-        
-                            c_m_axis_tdata <= 0;
-                            c_m_axis_tuser <= 0;
-                            c_m_axis_tkeep <= 0;
-                            c_m_axis_tvalid <= 0;
-                            c_m_axis_tlast <= 0;
-        
-                            //c_state <= WRITE_C;
-                            if(resv == 4'b0) begin
-                                c_wr_en_off <= 1'b0;
-                                c_state <= WRITE_OFF_C;
-                            end
-                            else begin
-                                c_wr_en_mask <= 1'b0;
-                                c_state <= WRITE_MASK_C;
-                            end
+generate
+    assign mod_id = c_s_axis_tdata[368+:8];
+    //4'b0 for key offset
+    //4'b1 for key mask
+    assign resv = c_s_axis_tdata[376+:4];
+    assign control_flag = c_s_axis_tdata[303:288];
+
+    reg [37:0]                    key_off_entry_reg;
+    reg [192:0]                   key_mask_entry_reg;
+    //LE to BE switching
+    wire[C_S_AXIS_DATA_WIDTH-1:0] c_s_axis_tdata_swapped;
+
+    assign c_s_axis_tdata_swapped = {	c_s_axis_tdata[0+:8],
+									    c_s_axis_tdata[8+:8],
+									    c_s_axis_tdata[16+:8],
+									    c_s_axis_tdata[24+:8],
+									    c_s_axis_tdata[32+:8],
+									    c_s_axis_tdata[40+:8],
+									    c_s_axis_tdata[48+:8],
+									    c_s_axis_tdata[56+:8],
+									    c_s_axis_tdata[64+:8],
+									    c_s_axis_tdata[72+:8],
+									    c_s_axis_tdata[80+:8],
+									    c_s_axis_tdata[88+:8],
+									    c_s_axis_tdata[96+:8],
+									    c_s_axis_tdata[104+:8],
+									    c_s_axis_tdata[112+:8],
+									    c_s_axis_tdata[120+:8],
+									    c_s_axis_tdata[128+:8],
+									    c_s_axis_tdata[136+:8],
+									    c_s_axis_tdata[144+:8],
+									    c_s_axis_tdata[152+:8],
+									    c_s_axis_tdata[160+:8],
+									    c_s_axis_tdata[168+:8],
+									    c_s_axis_tdata[176+:8],
+									    c_s_axis_tdata[184+:8],
+									    c_s_axis_tdata[192+:8],
+									    c_s_axis_tdata[200+:8],
+									    c_s_axis_tdata[208+:8],
+									    c_s_axis_tdata[216+:8],
+									    c_s_axis_tdata[224+:8],
+									    c_s_axis_tdata[232+:8],
+									    c_s_axis_tdata[240+:8],
+									    c_s_axis_tdata[248+:8],
+                                        c_s_axis_tdata[256+:8],
+                                        c_s_axis_tdata[264+:8],
+                                        c_s_axis_tdata[272+:8],
+                                        c_s_axis_tdata[280+:8],
+                                        c_s_axis_tdata[288+:8],
+                                        c_s_axis_tdata[296+:8],
+                                        c_s_axis_tdata[304+:8],
+                                        c_s_axis_tdata[312+:8],
+                                        c_s_axis_tdata[320+:8],
+                                        c_s_axis_tdata[328+:8],
+                                        c_s_axis_tdata[336+:8],
+                                        c_s_axis_tdata[344+:8],
+                                        c_s_axis_tdata[352+:8],
+                                        c_s_axis_tdata[360+:8],
+                                        c_s_axis_tdata[368+:8],
+                                        c_s_axis_tdata[376+:8],
+                                        c_s_axis_tdata[384+:8],
+                                        c_s_axis_tdata[392+:8],
+                                        c_s_axis_tdata[400+:8],
+                                        c_s_axis_tdata[408+:8],
+                                        c_s_axis_tdata[416+:8],
+                                        c_s_axis_tdata[424+:8],
+                                        c_s_axis_tdata[432+:8],
+                                        c_s_axis_tdata[440+:8],
+                                        c_s_axis_tdata[448+:8],
+                                        c_s_axis_tdata[456+:8],
+                                        c_s_axis_tdata[464+:8],
+                                        c_s_axis_tdata[472+:8],
+                                        c_s_axis_tdata[480+:8],
+                                        c_s_axis_tdata[488+:8],
+                                        c_s_axis_tdata[496+:8],
+                                        c_s_axis_tdata[504+:8]
+                                        };
+    always @(posedge clk or negedge rst_n) begin
+        if(~rst_n) begin
+            c_wr_en_off <= 1'b0;
+            c_wr_en_mask <= 1'b0;
+            c_index <= 8'b0;
+
+            c_m_axis_tdata <= 0;
+            c_m_axis_tuser <= 0;
+            c_m_axis_tkeep <= 0;
+            c_m_axis_tvalid <= 0;
+            c_m_axis_tlast <= 0;
+
+            key_off_entry_reg <= 0;
+            key_mask_entry_reg <= 0;
+
+            c_state <= IDLE_C;
+
+        end
+        else begin
+            case(c_state)
+                IDLE_C: begin
+                    if(c_s_axis_tvalid && mod_id[7:3] == STAGE_ID && mod_id[2:0] == KEY_EX_ID &&
+                     control_flag == 16'hf2f1)begin
+                        //c_wr_en <= 1'b1;
+                        c_index <= c_s_axis_tdata[384+:8];
+
+                        c_m_axis_tdata <= 0;
+                        c_m_axis_tuser <= 0;
+                        c_m_axis_tkeep <= 0;
+                        c_m_axis_tvalid <= 0;
+                        c_m_axis_tlast <= 0;
+
+                        //c_state <= WRITE_C;
+                        if(resv == 4'b0) begin
+                            c_wr_en_off <= 1'b0;
+                            c_state <= WRITE_OFF_C;
                         end
                         else begin
-                            c_wr_en_off <= 1'b0;
                             c_wr_en_mask <= 1'b0;
-                            c_index <= 8'b0; 
-        
-                            c_m_axis_tdata <= c_s_axis_tdata;
-                            c_m_axis_tuser <= c_s_axis_tuser;
-                            c_m_axis_tkeep <= c_s_axis_tkeep;
-                            c_m_axis_tvalid <= c_s_axis_tvalid;
-                            c_m_axis_tlast <= c_s_axis_tlast;
-        
-                            c_state <= IDLE_C;
+                            c_state <= WRITE_MASK_C;
                         end
                     end
-                    //support full table flush
-                    WRITE_OFF_C: begin
-                        if(c_s_axis_tvalid) begin
-                            key_off_entry_reg <= c_s_axis_tdata_swapped[511 -: 38];
-                            c_wr_en_off <= 1'b1;
-                            if(c_s_axis_tlast) begin
-                                c_state <= IDLE_C;
-                            end
-                            else begin
-                                c_state <= SU_WRITE_OFF_C;
-                            end
+                    else begin
+                        c_wr_en_off <= 1'b0;
+                        c_wr_en_mask <= 1'b0;
+                        c_index <= 8'b0; 
+
+                        c_m_axis_tdata <= c_s_axis_tdata;
+                        c_m_axis_tuser <= c_s_axis_tuser;
+                        c_m_axis_tkeep <= c_s_axis_tkeep;
+                        c_m_axis_tvalid <= c_s_axis_tvalid;
+                        c_m_axis_tlast <= c_s_axis_tlast;
+
+                        c_state <= IDLE_C;
+                    end
+                end
+                //support full table flush
+                WRITE_OFF_C: begin
+                    if(c_s_axis_tvalid) begin
+                        key_off_entry_reg <= c_s_axis_tdata_swapped[511 -: 38];
+                        c_wr_en_off <= 1'b1;
+                        if(c_s_axis_tlast) begin
+                            c_state <= IDLE_C;
                         end
                         else begin
-                            c_wr_en_off <= 0;
+                            c_state <= SU_WRITE_OFF_C;
                         end
                     end
+                    else begin
+                        c_wr_en_off <= 0;
+                    end
+                end
 
-                    SU_WRITE_OFF_C: begin
-                        if(c_s_axis_tvalid) begin
-                            key_off_entry_reg <= c_s_axis_tdata_swapped[511 -: 38];
-                            c_wr_en_off <= 1'b1;
-                            c_index <= c_index + 1'b1;
-                            if(c_s_axis_tlast) begin
-                                c_state <= IDLE_C;
-                            end
-                            else begin
-                                c_state <= SU_WRITE_OFF_C;
-                            end
+                SU_WRITE_OFF_C: begin
+                    if(c_s_axis_tvalid) begin
+                        key_off_entry_reg <= c_s_axis_tdata_swapped[511 -: 38];
+                        c_wr_en_off <= 1'b1;
+                        c_index <= c_index + 1'b1;
+                        if(c_s_axis_tlast) begin
+                            c_state <= IDLE_C;
                         end
                         else begin
-                            c_wr_en_off <= 1'b0;
+                            c_state <= SU_WRITE_OFF_C;
                         end
                     end
+                    else begin
+                        c_wr_en_off <= 1'b0;
+                    end
+                end
 
-                    WRITE_MASK_C: begin
-                        if(c_s_axis_tvalid) begin
-                            key_mask_entry_reg <= c_s_axis_tdata_swapped[511 -: 193];
-                            c_wr_en_mask <= 1'b1;
-                            if(c_s_axis_tlast) begin
-                                c_state <= IDLE_C;
-                            end
-                            else begin
-                                c_state <= SU_WRITE_MASK_C;
-                            end
+                WRITE_MASK_C: begin
+                    if(c_s_axis_tvalid) begin
+                        key_mask_entry_reg <= c_s_axis_tdata_swapped[511 -: 193];
+                        c_wr_en_mask <= 1'b1;
+                        if(c_s_axis_tlast) begin
+                            c_state <= IDLE_C;
                         end
                         else begin
-                            c_wr_en_mask <= 0;
+                            c_state <= SU_WRITE_MASK_C;
                         end
                     end
+                    else begin
+                        c_wr_en_mask <= 0;
+                    end
+                end
 
-                    SU_WRITE_MASK_C: begin
-                        if(c_s_axis_tvalid) begin
-                            key_mask_entry_reg <= c_s_axis_tdata_swapped[511 -: 193];
-                            c_wr_en_mask <= 1'b1;
-                            c_index <= c_index + 1'b1;
-                            if(c_s_axis_tlast) begin
-                                c_state <= IDLE_C;
-                            end
-                            else begin
-                                c_state <= SU_WRITE_MASK_C;
-                            end
+                SU_WRITE_MASK_C: begin
+                    if(c_s_axis_tvalid) begin
+                        key_mask_entry_reg <= c_s_axis_tdata_swapped[511 -: 193];
+                        c_wr_en_mask <= 1'b1;
+                        c_index <= c_index + 1'b1;
+                        if(c_s_axis_tlast) begin
+                            c_state <= IDLE_C;
                         end
                         else begin
-                            c_wr_en_mask <= 1'b0;
+                            c_state <= SU_WRITE_MASK_C;
                         end
                     end
-
-                    default: begin
-                        c_wr_en_off <= 1'b0;
+                    else begin
                         c_wr_en_mask <= 1'b0;
-                        c_index <= 8'b0; 
-                        c_m_axis_tdata <= c_s_axis_tdata;
-                        c_m_axis_tuser <= c_s_axis_tuser;
-                        c_m_axis_tkeep <= c_s_axis_tkeep;
-                        c_m_axis_tvalid <= c_s_axis_tvalid;
-                        c_m_axis_tlast <= c_s_axis_tlast;
                     end
-                endcase
-        
-            end
-        end
-        //ram for key extract
-        blk_mem_gen_2
-        key_ram_38w_32d
-        (
-            .addra(c_index[4:0]),
-            .clka(clk),
-            .dina(key_off_entry_reg),
-            .ena(1'b1),
-            .wea(c_wr_en_off),
-
-            //only [3:0] is needed for addressing
-            .addrb(vlan_in[8:4]),
-            .clkb(clk),
-            .doutb(key_offset_w),
-            .enb(1'b1)
-        );
-
-        blk_mem_gen_3
-        mask_ram_193w_32d
-        (
-            .addra(c_index[4:0]),
-            .clka(clk),
-            .dina(key_mask_entry_reg),
-            .ena(1'b1),
-            .wea(c_wr_en_mask),
-
-            //only [3:0] is needed for addressing
-            .addrb(vlan_in[8:4]),
-            .clkb(clk),
-            .doutb(key_mask_out_w),
-            .enb(1'b1)
-        );
-    end
+                end
 
-    else if(C_S_AXIS_DATA_WIDTH == 256) begin
+                default: begin
+                    c_wr_en_off <= 1'b0;
+                    c_wr_en_mask <= 1'b0;
+                    c_index <= 8'b0; 
+                    c_m_axis_tdata <= c_s_axis_tdata;
+                    c_m_axis_tuser <= c_s_axis_tuser;
+                    c_m_axis_tkeep <= c_s_axis_tkeep;
+                    c_m_axis_tvalid <= c_s_axis_tvalid;
+                    c_m_axis_tlast <= c_s_axis_tlast;
+                end
+            endcase
 
-		wire[C_S_AXIS_DATA_WIDTH-1:0] c_s_axis_tdata_swapped;
-		assign c_s_axis_tdata_swapped = {	c_s_axis_tdata[0+:8],
-											c_s_axis_tdata[8+:8],
-											c_s_axis_tdata[16+:8],
-											c_s_axis_tdata[24+:8],
-											c_s_axis_tdata[32+:8],
-											c_s_axis_tdata[40+:8],
-											c_s_axis_tdata[48+:8],
-											c_s_axis_tdata[56+:8],
-											c_s_axis_tdata[64+:8],
-											c_s_axis_tdata[72+:8],
-											c_s_axis_tdata[80+:8],
-											c_s_axis_tdata[88+:8],
-											c_s_axis_tdata[96+:8],
-											c_s_axis_tdata[104+:8],
-											c_s_axis_tdata[112+:8],
-											c_s_axis_tdata[120+:8],
-											c_s_axis_tdata[128+:8],
-											c_s_axis_tdata[136+:8],
-											c_s_axis_tdata[144+:8],
-											c_s_axis_tdata[152+:8],
-											c_s_axis_tdata[160+:8],
-											c_s_axis_tdata[168+:8],
-											c_s_axis_tdata[176+:8],
-											c_s_axis_tdata[184+:8],
-											c_s_axis_tdata[192+:8],
-											c_s_axis_tdata[200+:8],
-											c_s_axis_tdata[208+:8],
-											c_s_axis_tdata[216+:8],
-											c_s_axis_tdata[224+:8],
-											c_s_axis_tdata[232+:8],
-											c_s_axis_tdata[240+:8],
-											c_s_axis_tdata[248+:8]};
-
-        assign mod_id = c_s_axis_tdata[112+:8];
-        //4'b0 for key offset
-        //4'b1 for key mask
-        assign resv = c_s_axis_tdata[120+:4];
-        assign control_flag = c_s_axis_tdata[64+:16];
-
-		reg [7:0] c_index_next;
-		reg [2:0] c_state_next;
-		reg c_wr_en_off_next, c_wr_en_mask_next;
-		reg [37:0] key_off_entry_reg, key_off_entry_reg_next;
-		reg [192:0] key_mask_entry_reg, key_mask_entry_reg_next;
-
-		reg [C_S_AXIS_DATA_WIDTH-1:0]		r_tdata, c_s_axis_tdata_d1;
-		reg [C_S_AXIS_TUSER_WIDTH-1:0]		r_tuser, c_s_axis_tuser_d1;
-		reg [C_S_AXIS_DATA_WIDTH/8-1:0]		r_tkeep, c_s_axis_tkeep_d1;
-		reg									r_tlast, c_s_axis_tlast_d1;
-		reg									r_tvalid, c_s_axis_tvalid_d1;
-
-		reg [C_S_AXIS_DATA_WIDTH-1:0]		r_1st_tdata, r_1st_tdata_next;
-		reg [C_S_AXIS_TUSER_WIDTH-1:0]		r_1st_tuser, r_1st_tuser_next;
-		reg [C_S_AXIS_DATA_WIDTH/8-1:0]		r_1st_tkeep, r_1st_tkeep_next;
-		reg									r_1st_tlast, r_1st_tlast_next;
-		reg									r_1st_tvalid, r_1st_tvalid_next;
-
-		always @(*) begin
-			c_state_next = c_state;
-
-			r_tdata = 0;
-			r_tkeep = 0;
-			r_tuser = 0;
-			r_tlast = 0;
-			r_tvalid = 0;
-
-			r_1st_tdata_next = r_1st_tdata;
-			r_1st_tkeep_next = r_1st_tkeep;
-			r_1st_tuser_next = r_1st_tuser;
-			r_1st_tlast_next = r_1st_tlast;
-			r_1st_tvalid_next = r_1st_tvalid;
-
-			c_wr_en_mask_next = 0;
-			c_wr_en_off_next = 0;
-			c_index_next = c_index;
-			key_off_entry_reg_next = key_off_entry_reg;
-			key_mask_entry_reg_next = key_mask_entry_reg;
-
-			case (c_state)
-				IDLE_C: begin
-					r_tvalid = 0; // 1st segment
-					if (c_s_axis_tvalid) begin
-						// store 1st element
-						r_1st_tdata_next = c_s_axis_tdata;
-						r_1st_tuser_next = c_s_axis_tuser;
-						r_1st_tkeep_next = c_s_axis_tkeep;
-						r_1st_tlast_next = c_s_axis_tlast;
-						r_1st_tvalid_next = c_s_axis_tvalid;
-
-						c_state_next = PARSE_C;
-					end
-				end
-				PARSE_C: begin // 2nd segment
-					if (mod_id[7:3] == STAGE_ID && mod_id[2:0] == KEY_EX_ID &&
-							control_flag == 16'hf2f1 && c_s_axis_tvalid) begin
-						if (resv == 4'b0 && c_s_axis_tvalid) begin
-							c_index_next = c_s_axis_tdata[128+:8];
-							c_state_next = WRITE_OFF_C;
-						end
-						else begin
-							c_index_next = c_s_axis_tdata[128+:8];
-							c_state_next = WRITE_MASK_C;
-						end
-					end
-					else if (!c_s_axis_tvalid) begin
-					end
-					else begin
-						// emit
-						r_tdata = r_1st_tdata;
-						r_tkeep = r_1st_tkeep;
-						r_tuser = r_1st_tuser;
-						r_tlast = r_1st_tlast;
-						r_tvalid = r_1st_tvalid;
-						c_state_next = FLUSH_PKT_C;
-					end
-				end
-				WRITE_OFF_C: begin
-					if (c_s_axis_tvalid) begin
-						c_wr_en_off_next = 1;
-						key_off_entry_reg_next = c_s_axis_tdata_swapped[255-:38];
-
-						c_state_next = FLUSH_PKT_C;
-					end
-				end
-				WRITE_MASK_C: begin
-					if (c_s_axis_tvalid) begin
-						c_wr_en_mask_next = 1;
-						key_mask_entry_reg_next = c_s_axis_tdata_swapped[255-:193];
-
-						c_state_next = FLUSH_PKT_C;
-					end
-				end
-				FLUSH_PKT_C: begin
-					c_wr_en_off_next = 0;
-					c_wr_en_mask_next = 0;
-					r_tdata = c_s_axis_tdata_d1;
-					r_tkeep = c_s_axis_tkeep_d1;
-					r_tuser = c_s_axis_tuser_d1;
-					r_tlast = c_s_axis_tlast_d1;
-					r_tvalid = c_s_axis_tvalid_d1;
-					if (c_s_axis_tvalid_d1 && c_s_axis_tlast_d1) begin
-						c_state_next = IDLE_C;
-					end
-				end
-			endcase
-		end
-
-		always @(posedge clk) begin
-			if (~rst_n) begin
-				c_state <= IDLE_C;
-
-				// ctrl output
-				c_m_axis_tdata <= 0;
-				c_m_axis_tuser <= 0;
-				c_m_axis_tkeep <= 0;
-				c_m_axis_tlast <= 0;
-				c_m_axis_tvalid <= 0;
-				//
-				c_index <= 0;
-				c_wr_en_off <= 0;
-				c_wr_en_mask <= 0;
-				key_off_entry_reg <= 0;
-				key_mask_entry_reg <= 0;
-			end
-			else begin
-				c_state <= c_state_next;
-				// output ctrl master signals
-				c_m_axis_tdata <= r_tdata;
-				c_m_axis_tkeep <= r_tkeep;
-				c_m_axis_tuser <= r_tuser;
-				c_m_axis_tlast <= r_tlast;
-				c_m_axis_tvalid <= r_tvalid;
-				//
-				c_index <= c_index_next;
-				c_wr_en_off <= c_wr_en_off_next;
-				c_wr_en_mask <= c_wr_en_mask_next;
-				key_off_entry_reg <= key_off_entry_reg_next;
-				key_mask_entry_reg <= key_mask_entry_reg_next;
-			end
-		end
-
-		always @(posedge clk) begin
-			if (~rst_n) begin
-				// delayed 1 clk
-				c_s_axis_tdata_d1 <= 0;
-				c_s_axis_tuser_d1 <= 0;
-				c_s_axis_tkeep_d1 <= 0;
-				c_s_axis_tlast_d1 <= 0;
-				c_s_axis_tvalid_d1 <= 0;
-				//
-				r_1st_tdata <= 0;
-				r_1st_tkeep <= 0;
-				r_1st_tuser <= 0;
-				r_1st_tlast <= 0;
-				r_1st_tvalid <= 0;
-			end
-			else begin
-				// delayed 1 clk
-				c_s_axis_tdata_d1 <= c_s_axis_tdata;
-				c_s_axis_tuser_d1 <= c_s_axis_tuser;
-				c_s_axis_tkeep_d1 <= c_s_axis_tkeep;
-				c_s_axis_tlast_d1 <= c_s_axis_tlast;
-				c_s_axis_tvalid_d1 <= c_s_axis_tvalid;
-				// 
-				r_1st_tdata <= r_1st_tdata_next;
-				r_1st_tkeep <= r_1st_tkeep_next;
-				r_1st_tuser <= r_1st_tuser_next;
-				r_1st_tlast <= r_1st_tlast_next;
-				r_1st_tvalid <= r_1st_tvalid_next;
-			end
-		end
-        //ram for key extract
-        //blk_mem_gen_2 act_ram_18w_16d
-        // blk_mem_gen_2 #(
-        // 	.C_INIT_FILE_NAME	("./key_extract.mif"),
-        // 	.C_LOAD_INIT_FILE	(1)
-        // )
-        blk_mem_gen_2
-        key_ram_38w_32d
-        (
-            .addra(c_index[4:0]),
-            .clka(clk),
-            .dina(key_off_entry_reg),
-            .ena(1'b1),
-            .wea(c_wr_en_off),
-
-            //only [3:0] is needed for addressing
-            .addrb(vlan_in[8:4]),
-            .clkb(clk),
-            .doutb(key_offset_w),
-            .enb(1'b1)
-        );
-
-        blk_mem_gen_3
-        mask_ram_193w_16d
-        (
-            .addra(c_index[4:0]),
-            .clka(clk),
-            .dina(key_mask_entry_reg),
-            .ena(1'b1),
-            .wea(c_wr_en_mask),
-
-            //only [3:0] is needed for addressing
-            .addrb(vlan_in[8:4]),
-            .clkb(clk),
-            .doutb(key_mask_out_w),
-            .enb(1'b1)
-        );
+        end
     end
+    //ram for key extract
+    blk_mem_gen_2
+    key_ram_38w_32d
+    (
+        .addra(c_index[4:0]),
+        .clka(clk),
+        .dina(key_off_entry_reg),
+        .ena(1'b1),
+        .wea(c_wr_en_off),
+
+        //only [3:0] is needed for addressing
+        .addrb(vlan_in[8:4]),
+        .clkb(clk),
+        .doutb(key_offset_w),
+        .enb(1'b1)
+    );
+
+    blk_mem_gen_3
+    mask_ram_193w_32d
+    (
+        .addra(c_index[4:0]),
+        .clka(clk),
+        .dina(key_mask_entry_reg),
+        .ena(1'b1),
+        .wea(c_wr_en_mask),
+
+        //only [3:0] is needed for addressing
+        .addrb(vlan_in[8:4]),
+        .clkb(clk),
+        .doutb(key_mask_out_w),
+        .enb(1'b1)
+    );
 endgenerate
 
 //==========================================================
diff -ruN '--exclude=.git' '--exclude=p4c' '--exclude=tb' menshen/extract/key_extract.v parametric_menshen/extract/key_extract.v
--- menshen/extract/key_extract.v
+++ parametric_menshen/extract/key_extract.v
@@ -39,7 +39,25 @@
 localparam WIDTH_4B = 32;
 localparam WIDTH_6B = 48;
 
-//reg [KEY_LEN-1:0] key_out;
+reg [PHV_LEN-1:0] phv_in_r;
+reg               phv_valid_in_r;
+reg [KEY_OFF-1:0] key_offset_w_r;
+reg [KEY_LEN-1:0] key_mask_w_r;
+
+always @(posedge clk) begin
+	if (~rst_n) begin
+		phv_in_r <= 0;
+		phv_valid_in_r <= 0;
+		key_offset_w_r <= 0;
+		key_mask_w_r <= 0;
+	end
+	else begin
+		phv_in_r <= phv_in;
+		phv_valid_in_r <= phv_valid_in;
+		key_offset_w_r <= key_offset_w;
+		key_mask_w_r <= key_mask_w;
+	end
+end
 
 //24 fields to be retrived from the pkt header
 reg [WIDTH_2B-1:0]		cont_2B [0:7];
@@ -69,7 +87,7 @@
 
 localparam	IDLE_S=0,
 			CYCLE_1=1;
-reg [2:0] state, state_next;
+reg [2:0] state;
 
 reg [KEY_LEN-1:0] key_out; 
 // reg ready_out_next;
@@ -80,94 +98,107 @@
 
 always @(posedge clk) begin
 	if (~rst_n) begin
-		key_out <= 0;
-
 		state <= IDLE_S;
-
-
-		for (i=0; i<8; i=i+1) begin
-			cont_6B[i] <= 0;
-			cont_4B[i] <= 0;
-			cont_2B[i] <= 0;
-		end
-
-		phv_out <= 0;
+		
 		phv_valid_out <= 0;
 		key_valid_out <= 0;
-
-		key_offset_r <= 0;
-		key_mask_out_r <= 0;
 	end
 	else begin
 		case (state)
 			IDLE_S: begin
-				if (phv_valid_in) begin
-					key_offset_r <= key_offset_w;
-					key_mask_out_r <= key_mask_w;
-					phv_out <= phv_in;
-
-					cont_6B[7] <= phv_in[PHV_LEN-1            -: WIDTH_6B];
-					cont_6B[6] <= phv_in[PHV_LEN-1-  WIDTH_6B -: WIDTH_6B];
-					cont_6B[5] <= phv_in[PHV_LEN-1-2*WIDTH_6B -: WIDTH_6B];
-					cont_6B[4] <= phv_in[PHV_LEN-1-3*WIDTH_6B -: WIDTH_6B];
-					cont_6B[3] <= phv_in[PHV_LEN-1-4*WIDTH_6B -: WIDTH_6B];
-					cont_6B[2] <= phv_in[PHV_LEN-1-5*WIDTH_6B -: WIDTH_6B];
-					cont_6B[1] <= phv_in[PHV_LEN-1-6*WIDTH_6B -: WIDTH_6B];
-					cont_6B[0] <= phv_in[PHV_LEN-1-7*WIDTH_6B -: WIDTH_6B];
-
-					cont_4B[7] <= phv_in[PHV_LEN-1-8*WIDTH_6B            -: WIDTH_4B];
-					cont_4B[6] <= phv_in[PHV_LEN-1-8*WIDTH_6B-  WIDTH_4B -: WIDTH_4B];
-					cont_4B[5] <= phv_in[PHV_LEN-1-8*WIDTH_6B-2*WIDTH_4B -: WIDTH_4B];
-					cont_4B[4] <= phv_in[PHV_LEN-1-8*WIDTH_6B-3*WIDTH_4B -: WIDTH_4B];
-					cont_4B[3] <= phv_in[PHV_LEN-1-8*WIDTH_6B-4*WIDTH_4B -: WIDTH_4B];
-					cont_4B[2] <= phv_in[PHV_LEN-1-8*WIDTH_6B-5*WIDTH_4B -: WIDTH_4B];
-					cont_4B[1] <= phv_in[PHV_LEN-1-8*WIDTH_6B-6*WIDTH_4B -: WIDTH_4B];
-					cont_4B[0] <= phv_in[PHV_LEN-1-8*WIDTH_6B-7*WIDTH_4B -: WIDTH_4B];
-
-					cont_2B[7] <= phv_in[PHV_LEN-1-8*WIDTH_6B-8*WIDTH_4B            -: WIDTH_2B];
-					cont_2B[6] <= phv_in[PHV_LEN-1-8*WIDTH_6B-8*WIDTH_4B-  WIDTH_2B -: WIDTH_2B];
-					cont_2B[5] <= phv_in[PHV_LEN-1-8*WIDTH_6B-8*WIDTH_4B-2*WIDTH_2B -: WIDTH_2B];
-					cont_2B[4] <= phv_in[PHV_LEN-1-8*WIDTH_6B-8*WIDTH_4B-3*WIDTH_2B -: WIDTH_2B];
-					cont_2B[3] <= phv_in[PHV_LEN-1-8*WIDTH_6B-8*WIDTH_4B-4*WIDTH_2B -: WIDTH_2B];
-					cont_2B[2] <= phv_in[PHV_LEN-1-8*WIDTH_6B-8*WIDTH_4B-5*WIDTH_2B -: WIDTH_2B];
-					cont_2B[1] <= phv_in[PHV_LEN-1-8*WIDTH_6B-8*WIDTH_4B-6*WIDTH_2B -: WIDTH_2B];
-					cont_2B[0] <= phv_in[PHV_LEN-1-8*WIDTH_6B-8*WIDTH_4B-7*WIDTH_2B -: WIDTH_2B];
-
+			    phv_valid_out <= 0;
+				key_valid_out <= 0;
+				if (phv_valid_in_r)
 					state <= CYCLE_1;
-				end
-				else begin
-					phv_valid_out <= 0;
-					key_valid_out <= 0;
-				end
+				else
+					state <= IDLE_S;
 			end
 			CYCLE_1: begin
-				key_out[KEY_LEN-1                                     -: WIDTH_6B] <= cont_6B[key_offset_r[KEY_OFF-1     -: 3]];
-				key_out[KEY_LEN-1- 1*WIDTH_6B                         -: WIDTH_6B] <= cont_6B[key_offset_r[KEY_OFF-1-1*3 -: 3]];
-				key_out[KEY_LEN-1- 2*WIDTH_6B                         -: WIDTH_4B] <= cont_4B[key_offset_r[KEY_OFF-1-2*3 -: 3]];
-				key_out[KEY_LEN-1- 2*WIDTH_6B - 1*WIDTH_4B            -: WIDTH_4B] <= cont_4B[key_offset_r[KEY_OFF-1-3*3 -: 3]];
-				key_out[KEY_LEN-1- 2*WIDTH_6B - 2*WIDTH_4B            -: WIDTH_2B] <= cont_2B[key_offset_r[KEY_OFF-1-4*3 -: 3]];
-				key_out[KEY_LEN-1- 2*WIDTH_6B - 2*WIDTH_4B - WIDTH_2B -: WIDTH_2B] <= cont_2B[key_offset_r[KEY_OFF-1-5*3 -: 3]];
-
-				case(com_op[19:18])
-					2'b00: begin
-						key_out[0] <= (com_op_1>com_op_2)?1'b1:1'b0;
-					end
-					2'b01: begin
-						key_out[0] <= (com_op_1>=com_op_2)?1'b1:1'b0;
-					end
-					2'b10: begin
-						key_out[0] <= (com_op_1==com_op_2)?1'b1:1'b0;
-					end
-					default: begin
-						key_out[0] <= 1'b1;
-					end
-				endcase
 				phv_valid_out <= 1;
 				key_valid_out <= 1;
 
 				state <= IDLE_S;
 			end
+			default: begin
+				phv_valid_out <= 0;
+				key_valid_out <= 0;
+				state <= IDLE_S;
+			end
+		endcase
+	end
+end
+
+reg [PHV_LEN-1:0] phv_out_r;    // register used to wait 1 cycle for the result
+always @(posedge clk) begin
+	if (~rst_n) begin
+	    phv_out_r <= 0;
+	    phv_out <= 0;
+	    
+	    for (i=0; i<8; i=i+1) begin
+			cont_6B[i] <= 0;
+			cont_4B[i] <= 0;
+			cont_2B[i] <= 0;
+		end
+		key_out <= 0;
+		
+		key_offset_r <= 0;
+		key_mask_out_r <= 0;
+	end
+	else begin
+	    phv_out_r <= phv_in_r;
+	    phv_out <= phv_out_r;
+	    
+	    cont_6B[7] <= phv_in_r[PHV_LEN-1            -: WIDTH_6B];
+		cont_6B[6] <= phv_in_r[PHV_LEN-1-  WIDTH_6B -: WIDTH_6B];
+		cont_6B[5] <= phv_in_r[PHV_LEN-1-2*WIDTH_6B -: WIDTH_6B];
+		cont_6B[4] <= phv_in_r[PHV_LEN-1-3*WIDTH_6B -: WIDTH_6B];
+		cont_6B[3] <= phv_in_r[PHV_LEN-1-4*WIDTH_6B -: WIDTH_6B];
+		cont_6B[2] <= phv_in_r[PHV_LEN-1-5*WIDTH_6B -: WIDTH_6B];
+		cont_6B[1] <= phv_in_r[PHV_LEN-1-6*WIDTH_6B -: WIDTH_6B];
+		cont_6B[0] <= phv_in_r[PHV_LEN-1-7*WIDTH_6B -: WIDTH_6B];
+
+		cont_4B[7] <= phv_in_r[PHV_LEN-1-8*WIDTH_6B            -: WIDTH_4B];
+		cont_4B[6] <= phv_in_r[PHV_LEN-1-8*WIDTH_6B-  WIDTH_4B -: WIDTH_4B];
+		cont_4B[5] <= phv_in_r[PHV_LEN-1-8*WIDTH_6B-2*WIDTH_4B -: WIDTH_4B];
+		cont_4B[4] <= phv_in_r[PHV_LEN-1-8*WIDTH_6B-3*WIDTH_4B -: WIDTH_4B];
+		cont_4B[3] <= phv_in_r[PHV_LEN-1-8*WIDTH_6B-4*WIDTH_4B -: WIDTH_4B];
+		cont_4B[2] <= phv_in_r[PHV_LEN-1-8*WIDTH_6B-5*WIDTH_4B -: WIDTH_4B];
+		cont_4B[1] <= phv_in_r[PHV_LEN-1-8*WIDTH_6B-6*WIDTH_4B -: WIDTH_4B];
+		cont_4B[0] <= phv_in_r[PHV_LEN-1-8*WIDTH_6B-7*WIDTH_4B -: WIDTH_4B];
+
+		cont_2B[7] <= phv_in_r[PHV_LEN-1-8*WIDTH_6B-8*WIDTH_4B            -: WIDTH_2B];
+		cont_2B[6] <= phv_in_r[PHV_LEN-1-8*WIDTH_6B-8*WIDTH_4B-  WIDTH_2B -: WIDTH_2B];
+		cont_2B[5] <= phv_in_r[PHV_LEN-1-8*WIDTH_6B-8*WIDTH_4B-2*WIDTH_2B -: WIDTH_2B];
+		cont_2B[4] <= phv_in_r[PHV_LEN-1-8*WIDTH_6B-8*WIDTH_4B-3*WIDTH_2B -: WIDTH_2B];
+		cont_2B[3] <= phv_in_r[PHV_LEN-1-8*WIDTH_6B-8*WIDTH_4B-4*WIDTH_2B -: WIDTH_2B];
+		cont_2B[2] <= phv_in_r[PHV_LEN-1-8*WIDTH_6B-8*WIDTH_4B-5*WIDTH_2B -: WIDTH_2B];
+		cont_2B[1] <= phv_in_r[PHV_LEN-1-8*WIDTH_6B-8*WIDTH_4B-6*WIDTH_2B -: WIDTH_2B];
+		cont_2B[0] <= phv_in_r[PHV_LEN-1-8*WIDTH_6B-8*WIDTH_4B-7*WIDTH_2B -: WIDTH_2B];
+		
+		key_out[KEY_LEN-1                                     -: WIDTH_6B] <= cont_6B[key_offset_r[KEY_OFF-1     -: 3]];
+		key_out[KEY_LEN-1- 1*WIDTH_6B                         -: WIDTH_6B] <= cont_6B[key_offset_r[KEY_OFF-1-1*3 -: 3]];
+		key_out[KEY_LEN-1- 2*WIDTH_6B                         -: WIDTH_4B] <= cont_4B[key_offset_r[KEY_OFF-1-2*3 -: 3]];
+		key_out[KEY_LEN-1- 2*WIDTH_6B - 1*WIDTH_4B            -: WIDTH_4B] <= cont_4B[key_offset_r[KEY_OFF-1-3*3 -: 3]];
+		key_out[KEY_LEN-1- 2*WIDTH_6B - 2*WIDTH_4B            -: WIDTH_2B] <= cont_2B[key_offset_r[KEY_OFF-1-4*3 -: 3]];
+		key_out[KEY_LEN-1- 2*WIDTH_6B - 2*WIDTH_4B - WIDTH_2B -: WIDTH_2B] <= cont_2B[key_offset_r[KEY_OFF-1-5*3 -: 3]];
+		
+		case(com_op[19:18])
+			2'b00: begin
+				key_out[0] <= (com_op_1>com_op_2)?1'b1:1'b0;
+			end
+			2'b01: begin
+				key_out[0] <= (com_op_1>=com_op_2)?1'b1:1'b0;
+			end
+			2'b10: begin
+				key_out[0] <= (com_op_1==com_op_2)?1'b1:1'b0;
+			end
+			default: begin
+				key_out[0] <= 1'b1;
+			end
 		endcase
+		
+		key_offset_r <= key_offset_w_r;
+		key_mask_out_r <= key_mask_w_r;
 	end
 end
 
diff -ruN '--exclude=.git' '--exclude=p4c' '--exclude=tb' menshen/last_stage.v parametric_menshen/last_stage.v
--- menshen/last_stage.v
+++ parametric_menshen/last_stage.v
@@ -4,13 +4,14 @@
 module last_stage #(
     parameter C_S_AXIS_DATA_WIDTH = 512,
     parameter C_S_AXIS_TUSER_WIDTH = 128,
-    parameter STAGE_ID = 0,  // valid: 0-4
+    parameter STAGE_ID = 0,  // valid: 0-32
     parameter PHV_LEN = 48*8+32*8+16*8+256,
     parameter KEY_LEN = 48*2+32*2+16*2+1,
     parameter ACT_LEN = 25,
     parameter KEY_OFF = 6*3+20,
-	parameter C_NUM_QUEUES = 4,
-	parameter C_VLANID_WIDTH = 12
+    parameter C_NUM_QUEUES = 1,
+    parameter C_VLANID_WIDTH = 12,
+    parameter NUM_OF_STAGES = 5
 )
 (
     input									axis_clk,
@@ -29,18 +30,6 @@
     output reg                       phv_out_valid_0,
 	input                        phv_fifo_ready_0,
 
-    output reg [PHV_LEN-1:0]         phv_out_1,
-    output reg                       phv_out_valid_1,
-	input                        phv_fifo_ready_1,
-
-    output reg [PHV_LEN-1:0]         phv_out_2,
-    output reg                       phv_out_valid_2,
-	input                        phv_fifo_ready_2,
-
-    output reg [PHV_LEN-1:0]         phv_out_3,
-    output reg                       phv_out_valid_3,
-	input                        phv_fifo_ready_3,
-
 
     //control path
     input [C_S_AXIS_DATA_WIDTH-1:0]			c_s_axis_tdata,
@@ -166,7 +155,8 @@
     .PHV_LEN(),
     .KEY_LEN(KEY_LEN),
     .ACT_LEN(),
-    .LOOKUP_ID()
+    .LOOKUP_ID(),
+    .NUM_OF_STAGES(NUM_OF_STAGES)
 ) lookup_engine(
     .clk(axis_clk),
     .rst_n(aresetn),
@@ -223,7 +213,7 @@
     //signals output from ALUs
     .phv_out(phv_out),
     .phv_valid_out(phv_out_valid_from_ae),
-    .ready_in(phv_fifo_ready_0&&phv_fifo_ready_1&&phv_fifo_ready_2&&phv_fifo_ready_3),
+    .ready_in(phv_fifo_ready_0),
 	.act_vlan_in			(act_vlan_out_r),
 	.act_vlan_valid_in		(act_vlan_out_valid_r),
 	.act_vlan_ready			(act_vlan_ready),
@@ -245,77 +235,29 @@
 	.c_m_axis_tlast(c_m_axis_tlast)
 );
 
-// pkt_hdr_vec_next = {pkt_hdr_vec_w[PKT_HDR_LEN-1:145], p_cur_queue_val, pkt_hdr_vec_w[0+:141]}; 
-// position: [141+:4]
-//
-
-// assign phv_out_0 = phv_out;
-// assign phv_out_1 = phv_out;
-// assign phv_out_2 = phv_out;
-// assign phv_out_3 = phv_out;
-// 
-// 
-// assign phv_out_valid_0 = (phv_out[141]==1?1:0) & phv_out_valid_from_ae;
-// assign phv_out_valid_1 = (phv_out[142]==1?1:0) & phv_out_valid_from_ae;
-// assign phv_out_valid_2 = (phv_out[143]==1?1:0) & phv_out_valid_from_ae;
-// assign phv_out_valid_3 = (phv_out[144]==1?1:0) & phv_out_valid_from_ae;
-
 reg [PHV_LEN-1:0] phv_out_0_next;
-reg [PHV_LEN-1:0] phv_out_1_next;
-reg [PHV_LEN-1:0] phv_out_2_next;
-reg [PHV_LEN-1:0] phv_out_3_next;
 reg phv_out_valid_0_next;
-reg phv_out_valid_1_next;
-reg phv_out_valid_2_next;
-reg phv_out_valid_3_next;
 
 always @(*) begin
 	phv_out_valid_0_next = 0;
-	phv_out_valid_1_next = 0;
-	phv_out_valid_2_next = 0;
-	phv_out_valid_3_next = 0;
 
 	phv_out_0_next = phv_out;
-	phv_out_1_next = phv_out;
-	phv_out_2_next = phv_out;
-	phv_out_3_next = phv_out;
 
 	if (phv_out_valid_from_ae) begin
 		if (phv_out[141]) begin
 			phv_out_valid_0_next = 1;
 		end
-		if (phv_out[142]) begin
-			phv_out_valid_1_next = 1;
-		end
-		if (phv_out[143]) begin
-			phv_out_valid_2_next = 1;
-		end
-		if (phv_out[144]) begin
-			phv_out_valid_3_next = 1;
-		end
 	end
 end
 
 always @(posedge axis_clk) begin
 	if (~aresetn) begin
 		phv_out_0 <= 0;
-		phv_out_1 <= 0;
-		phv_out_2 <= 0;
-		phv_out_3 <= 0;
 		phv_out_valid_0 <= 0;
-		phv_out_valid_1 <= 0;
-		phv_out_valid_2 <= 0;
-		phv_out_valid_3 <= 0;
 	end
 	else begin
 		phv_out_0 <= phv_out_0_next;
-		phv_out_1 <= phv_out_1_next;
-		phv_out_2 <= phv_out_2_next;
-		phv_out_3 <= phv_out_3_next;
 		phv_out_valid_0 <= phv_out_valid_0_next;
-		phv_out_valid_1 <= phv_out_valid_1_next;
-		phv_out_valid_2 <= phv_out_valid_2_next;
-		phv_out_valid_3 <= phv_out_valid_3_next;
 	end
 end
 
diff -ruN '--exclude=.git' '--exclude=p4c' '--exclude=tb' menshen/lookup/lke_cam_part.v parametric_menshen/lookup/lke_cam_part.v
--- menshen/lookup/lke_cam_part.v
+++ parametric_menshen/lookup/lke_cam_part.v
@@ -8,7 +8,8 @@
     parameter KEY_LEN = 48*2+32*2+16*2+5,
     parameter ACT_LEN = 625,
     parameter LOOKUP_ID = 2,
-	parameter C_VLANID_WIDTH = 12
+    parameter C_VLANID_WIDTH = 12,
+    parameter NUM_OF_STAGES = 5
 )
 (
     input clk,
@@ -44,101 +45,115 @@
 );
 
 /********intermediate variables declared here********/
-wire [3:0]		match_addr;
-wire			match;
-
-reg [PHV_LEN-1:0] phv_reg;
-reg [2:0] lookup_state;
-
-wire [11:0] vlan_id;
-
-assign vlan_id = phv_in[140:129];
-
-wire [204:0] dbg_input;
-
-assign dbg_input = {vlan_id[3:0], vlan_id[11:4], extract_key};
-
-/********intermediate variables declared here********/
-
-//here, the output should be controlled.
-localparam IDLE_S = 3'd0,
-           WAIT1_S = 3'd1,
-           WAIT2_S = 3'd2,
-           TRANS_S = 3'd3,
-		   HALT_S = 3'd4,
-		   EMPTY1_S = 3'd5,
-		   OUTPUT_S = 3'd6;
+reg                key_valid_ff;
+reg [PHV_LEN-1:0]  phv_in_ff;
+reg [KEY_LEN-1:0]  extract_key_ff;
+reg [223:0]        cam_out_data_ff;
+reg                cam_out_valid_ff;
+reg [2:0]          rst_counter;
+reg                cam_rst;
+
+wire [3:0]         match_addr;
+wire               match;
+reg [223:0]        cam_out_data;
+reg                cam_out_valid;
+reg                rst_busy;
+reg                cam_lkup_ready;
+reg                cam_hwui_ready;
+wire [PHV_LEN-1:0] fifo_phv_out;
+wire               fifo_full;
+
+wire [11:0]        vlan_id_ff;
+
+wire               rst_busy_r;
+reg [207:0]        cam_in;
+reg                key_valid_r;
+wire [223:0]       cam_out_data_r;
+wire               cam_out_valid_r;
+wire               cam_lkup_ready_r;
+reg [223:0]        conf_in;
+reg                c_wr_en_cam_r;
+wire               cam_hwui_ready_r;
+
+assign vlan_id_ff = phv_in_ff[140:129];
+
+assign match_addr = cam_out_data_ff[3:0];
+
+assign match = cam_out_data_ff[8];
+
+assign ready_out = (~fifo_full) & (~rst_busy) & cam_lkup_ready & cam_hwui_ready;
+
+fallthrough_small_fifo #(
+	.WIDTH(PHV_LEN),
+	.MAX_DEPTH_BITS(5)
+)
+phv_fifo_cam (
+	.clk            (clk),
+	.reset          (~rst_n),
+	.din            (phv_in_ff),
+	.wr_en          (key_valid_ff),
+	.rd_en          (cam_out_valid_ff && ready_in),
+	.dout           (fifo_phv_out),
+	.full           (),
+	.nearly_full    (fifo_full),
+	.empty          ()
+);
 
-assign ready_out = lookup_state!=HALT_S;
+always @(posedge clk or negedge rst_n) begin
+	if (~rst_n) begin
+		rst_counter <= 0;
+		cam_rst <= 0;
+		key_valid_ff <= 0;
+		phv_in_ff <= 0;
+		extract_key_ff <= 0;
+		cam_out_data_ff <= 0;
+		cam_out_valid_ff <= 0;
+	end
+	else begin
+		key_valid_ff <= key_valid;
+		phv_in_ff <= phv_in;
+		extract_key_ff <= extract_key;
+		cam_out_data_ff <= cam_out_data;
+		cam_out_valid_ff <= cam_out_valid;
+		if(rst_counter < 4) begin
+			rst_counter <= rst_counter + 1;
+			cam_rst <= 0;
+		end
+		else begin
+			cam_rst <= 1;
+		end
+	end
+end
 
 always @(posedge clk or negedge rst_n) begin
 
     if (~rst_n) begin
-        phv_reg <= 0;
-        lookup_state <= IDLE_S;
-
         phv_out <= 0;
-		phv_out_valid <= 0;
-		match_addr_out <= 0;
-		if_match <= 0;
-
+        phv_out_valid <= 0;
+        if_match <= 0;
+        match_addr_out <= 0;
 		// ready_out <= 1'b1;
     end
-
-    else begin
-        case(lookup_state)
-            IDLE_S: begin
-                if (key_valid == 1'b1) begin
-					// ready_out <= 1'b0;
-                    phv_reg <= phv_in;
-                    lookup_state <= WAIT1_S;
-                end
-                else begin
-					phv_out_valid <= 0;
-					if_match <= 0;
-					// ready_out <= 1'b1;
-                    lookup_state <= IDLE_S;
-                end
+    else
+    begin
+        if (cam_out_valid_ff && ready_in) begin
+            phv_out <= fifo_phv_out;
+            phv_out_valid <= 1'b1;
+            if(match == 1'b0) begin // CAM miss
+                if_match <= 0;
+                match_addr_out <= 4'hf;
             end
-
-            WAIT1_S: begin
-				if (ready_in) begin
-					phv_out <= phv_reg;
-					phv_out_valid <= 1'b1;
-
-					if(match == 1'b0) begin // CAM miss
-						if_match <= 0;
-						match_addr_out <= 4'hf;
-                	end
-                	else begin // CAM hit
-						if_match <= 1;
-						match_addr_out <= match_addr;
-                	end
-                	lookup_state <= IDLE_S;
-					// ready_out <= 1'b1;
-				end
-				else begin
-					lookup_state <= HALT_S;
-				end
+            else begin // CAM hit
+                if_match <= 1;
+                match_addr_out <= match_addr;
             end
-			HALT_S: begin
-				if (ready_in) begin
-					phv_out <= phv_reg;
-					phv_out_valid <= 1'b1;
-
-					if(match == 1'b0) begin // CAM miss
-						if_match <= 0;
-						match_addr_out <= 4'hf;
-                	end
-                	else begin // CAM hit
-						if_match <= 1;
-						match_addr_out <= match_addr;
-                	end
-                	lookup_state <= IDLE_S;
-					// ready_out <= 1'b1;
-				end
-			end
-        endcase
+        end
+        else begin
+            phv_out <= 0;
+            phv_out_valid <= 0;
+            if_match <= 0;
+            match_addr_out <= 4'hf;
+        end
     end
 end
 
@@ -162,17 +177,12 @@
 
 reg  [7:0]          c_index_act;
 reg                 c_wr_en_act;
-reg  [ACT_LEN-1:0]  act_entry_tmp;             
 reg                 continous_flag;
 reg [204:0]         cam_entry_reg;
 
 
 reg [2:0]           c_state;
 
-/****for 256b exclusively*****/
-reg                                 c_m_axis_tvalid_r;
-reg                                 c_m_axis_tlast_r;
-
 
 localparam IDLE_C = 0,
            PARSE_C = 1,
@@ -183,133 +193,111 @@
            ACT_TMP_ENTRY = 6,
 		   FLUSH_REST_C = 7;
 
-generate 
-    if(C_S_AXIS_DATA_WIDTH == 512) begin
-        assign mod_id = c_s_axis_tdata[368+:8];
-        assign resv   = c_s_axis_tdata[376+:4];
-        assign control_flag = c_s_axis_tdata[335:320];
-        //LE to BE switching
-        wire[C_S_AXIS_DATA_WIDTH-1:0] c_s_axis_tdata_swapped;
-
-		assign c_s_axis_tdata_swapped = {	c_s_axis_tdata[0+:8],
-											c_s_axis_tdata[8+:8],
-											c_s_axis_tdata[16+:8],
-											c_s_axis_tdata[24+:8],
-											c_s_axis_tdata[32+:8],
-											c_s_axis_tdata[40+:8],
-											c_s_axis_tdata[48+:8],
-											c_s_axis_tdata[56+:8],
-											c_s_axis_tdata[64+:8],
-											c_s_axis_tdata[72+:8],
-											c_s_axis_tdata[80+:8],
-											c_s_axis_tdata[88+:8],
-											c_s_axis_tdata[96+:8],
-											c_s_axis_tdata[104+:8],
-											c_s_axis_tdata[112+:8],
-											c_s_axis_tdata[120+:8],
-											c_s_axis_tdata[128+:8],
-											c_s_axis_tdata[136+:8],
-											c_s_axis_tdata[144+:8],
-											c_s_axis_tdata[152+:8],
-											c_s_axis_tdata[160+:8],
-											c_s_axis_tdata[168+:8],
-											c_s_axis_tdata[176+:8],
-											c_s_axis_tdata[184+:8],
-											c_s_axis_tdata[192+:8],
-											c_s_axis_tdata[200+:8],
-											c_s_axis_tdata[208+:8],
-											c_s_axis_tdata[216+:8],
-											c_s_axis_tdata[224+:8],
-											c_s_axis_tdata[232+:8],
-											c_s_axis_tdata[240+:8],
-											c_s_axis_tdata[248+:8],
-                                            c_s_axis_tdata[256+:8],
-                                            c_s_axis_tdata[264+:8],
-                                            c_s_axis_tdata[272+:8],
-                                            c_s_axis_tdata[280+:8],
-                                            c_s_axis_tdata[288+:8],
-                                            c_s_axis_tdata[296+:8],
-                                            c_s_axis_tdata[304+:8],
-                                            c_s_axis_tdata[312+:8],
-                                            c_s_axis_tdata[320+:8],
-                                            c_s_axis_tdata[328+:8],
-                                            c_s_axis_tdata[336+:8],
-                                            c_s_axis_tdata[344+:8],
-                                            c_s_axis_tdata[352+:8],
-                                            c_s_axis_tdata[360+:8],
-                                            c_s_axis_tdata[368+:8],
-                                            c_s_axis_tdata[376+:8],
-                                            c_s_axis_tdata[384+:8],
-                                            c_s_axis_tdata[392+:8],
-                                            c_s_axis_tdata[400+:8],
-                                            c_s_axis_tdata[408+:8],
-                                            c_s_axis_tdata[416+:8],
-                                            c_s_axis_tdata[424+:8],
-                                            c_s_axis_tdata[432+:8],
-                                            c_s_axis_tdata[440+:8],
-                                            c_s_axis_tdata[448+:8],
-                                            c_s_axis_tdata[456+:8],
-                                            c_s_axis_tdata[464+:8],
-                                            c_s_axis_tdata[472+:8],
-                                            c_s_axis_tdata[480+:8],
-                                            c_s_axis_tdata[488+:8],
-                                            c_s_axis_tdata[496+:8],
-                                            c_s_axis_tdata[504+:8]
-                                            };
-        always @(posedge clk or negedge rst_n) begin
-            if(~rst_n) begin
-                c_index_cam <= 0;
-                c_wr_en_cam <= 0;
-
-                c_index_act <= 0;
-                c_wr_en_act <= 0;
-
-                act_entry_tmp <= 0;
-                cam_entry_reg <= 0;
-                continous_flag <= 0;
-
-                c_m_axis_tdata <= 0;
-                c_m_axis_tuser <= 0;
-                c_m_axis_tkeep <= 0;
-                c_m_axis_tvalid <= 0;
-                c_m_axis_tlast <= 0;
+generate
+    assign mod_id = c_s_axis_tdata[368+:8];
+    assign resv   = c_s_axis_tdata[376+:4];
+    assign control_flag = c_s_axis_tdata[303:288];
+    //LE to BE switching
+    wire[C_S_AXIS_DATA_WIDTH-1:0] c_s_axis_tdata_swapped;
+
+    assign c_s_axis_tdata_swapped = {	c_s_axis_tdata[0+:8],
+									    c_s_axis_tdata[8+:8],
+									    c_s_axis_tdata[16+:8],
+									    c_s_axis_tdata[24+:8],
+									    c_s_axis_tdata[32+:8],
+									    c_s_axis_tdata[40+:8],
+									    c_s_axis_tdata[48+:8],
+									    c_s_axis_tdata[56+:8],
+									    c_s_axis_tdata[64+:8],
+									    c_s_axis_tdata[72+:8],
+									    c_s_axis_tdata[80+:8],
+									    c_s_axis_tdata[88+:8],
+									    c_s_axis_tdata[96+:8],
+									    c_s_axis_tdata[104+:8],
+									    c_s_axis_tdata[112+:8],
+									    c_s_axis_tdata[120+:8],
+									    c_s_axis_tdata[128+:8],
+									    c_s_axis_tdata[136+:8],
+									    c_s_axis_tdata[144+:8],
+									    c_s_axis_tdata[152+:8],
+									    c_s_axis_tdata[160+:8],
+									    c_s_axis_tdata[168+:8],
+									    c_s_axis_tdata[176+:8],
+									    c_s_axis_tdata[184+:8],
+									    c_s_axis_tdata[192+:8],
+									    c_s_axis_tdata[200+:8],
+									    c_s_axis_tdata[208+:8],
+									    c_s_axis_tdata[216+:8],
+									    c_s_axis_tdata[224+:8],
+									    c_s_axis_tdata[232+:8],
+									    c_s_axis_tdata[240+:8],
+									    c_s_axis_tdata[248+:8],
+                                        c_s_axis_tdata[256+:8],
+                                        c_s_axis_tdata[264+:8],
+                                        c_s_axis_tdata[272+:8],
+                                        c_s_axis_tdata[280+:8],
+                                        c_s_axis_tdata[288+:8],
+                                        c_s_axis_tdata[296+:8],
+                                        c_s_axis_tdata[304+:8],
+                                        c_s_axis_tdata[312+:8],
+                                        c_s_axis_tdata[320+:8],
+                                        c_s_axis_tdata[328+:8],
+                                        c_s_axis_tdata[336+:8],
+                                        c_s_axis_tdata[344+:8],
+                                        c_s_axis_tdata[352+:8],
+                                        c_s_axis_tdata[360+:8],
+                                        c_s_axis_tdata[368+:8],
+                                        c_s_axis_tdata[376+:8],
+                                        c_s_axis_tdata[384+:8],
+                                        c_s_axis_tdata[392+:8],
+                                        c_s_axis_tdata[400+:8],
+                                        c_s_axis_tdata[408+:8],
+                                        c_s_axis_tdata[416+:8],
+                                        c_s_axis_tdata[424+:8],
+                                        c_s_axis_tdata[432+:8],
+                                        c_s_axis_tdata[440+:8],
+                                        c_s_axis_tdata[448+:8],
+                                        c_s_axis_tdata[456+:8],
+                                        c_s_axis_tdata[464+:8],
+                                        c_s_axis_tdata[472+:8],
+                                        c_s_axis_tdata[480+:8],
+                                        c_s_axis_tdata[488+:8],
+                                        c_s_axis_tdata[496+:8],
+                                        c_s_axis_tdata[504+:8]
+                                        };
+    always @(posedge clk or negedge rst_n) begin
+        if(~rst_n) begin
+            c_index_cam <= 0;
+            c_wr_en_cam <= 0;
+
+            c_index_act <= 0;
+            c_wr_en_act <= 0;
+
+            cam_entry_reg <= 0;
+            continous_flag <= 0;
+
+            c_m_axis_tdata <= 0;
+            c_m_axis_tuser <= 0;
+            c_m_axis_tkeep <= 0;
+            c_m_axis_tvalid <= 0;
+            c_m_axis_tlast <= 0;
 
-                c_state <= IDLE_C;
+            c_state <= IDLE_C;
 
-            end
-
-            else begin
-                case(c_state)
-                    IDLE_C: begin
-                        if(c_s_axis_tvalid) begin
-                            if(mod_id[7:3] == STAGE_ID && mod_id[2:0] == LOOKUP_ID 
-									&& control_flag == 16'hf2f1
-									&& resv == 4'b0) begin // TCAM entry
-                                c_wr_en_cam <= 1'b0;
-                                c_index_cam <= c_s_axis_tdata[384+:8];
-                                c_state <= CAM_TMP_ENTRY;
-                            end
-                            //not for lookup
-                            else begin
-                                c_index_cam <= 0;
-                                c_wr_en_cam <= 0;
-
-                                c_index_act <= 0;
-                                c_wr_en_act <= 0;
-
-                                act_entry_tmp <= 0;
-                                continous_flag <= 0;
-
-                                c_m_axis_tdata <= c_s_axis_tdata;
-                                c_m_axis_tuser <= c_s_axis_tuser;
-                                c_m_axis_tkeep <= c_s_axis_tkeep;
-                                c_m_axis_tvalid <= c_s_axis_tvalid;
-                                c_m_axis_tlast <= c_s_axis_tlast;
+        end
 
-                                c_state <= IDLE_C;
-                            end
+        else begin
+            case(c_state)
+                IDLE_C: begin
+                    if(c_s_axis_tvalid) begin
+                        if(mod_id[7:3] == STAGE_ID && mod_id[2:0] == LOOKUP_ID 
+							    && control_flag == 16'hf2f1
+							    && resv == 4'b0) begin // TCAM entry
+                            c_wr_en_cam <= 1'b0;
+                            c_index_cam <= c_s_axis_tdata[384+:8];
+                            c_state <= CAM_TMP_ENTRY;
                         end
-                        //stay halt
+                        //not for lookup
                         else begin
                             c_index_cam <= 0;
                             c_wr_en_cam <= 0;
@@ -317,391 +305,163 @@
                             c_index_act <= 0;
                             c_wr_en_act <= 0;
 
-                            act_entry_tmp <= 0;
                             continous_flag <= 0;
 
-                            c_m_axis_tdata <= 0;
-                            c_m_axis_tuser <= 0;
-                            c_m_axis_tkeep <= 0;
-                            c_m_axis_tvalid <= 0;
-                            c_m_axis_tlast <= 0;
+                            c_m_axis_tdata <= c_s_axis_tdata;
+                            c_m_axis_tuser <= c_s_axis_tuser;
+                            c_m_axis_tkeep <= c_s_axis_tkeep;
+                            c_m_axis_tvalid <= c_s_axis_tvalid;
+                            c_m_axis_tlast <= c_s_axis_tlast;
 
                             c_state <= IDLE_C;
                         end
                     end
+                    //stay halt
+                    else begin
+                        c_index_cam <= 0;
+                        c_wr_en_cam <= 0;
+
+                        c_index_act <= 0;
+                        c_wr_en_act <= 0;
+
+                        continous_flag <= 0;
+
+                        c_m_axis_tdata <= 0;
+                        c_m_axis_tuser <= 0;
+                        c_m_axis_tkeep <= 0;
+                        c_m_axis_tvalid <= 0;
+                        c_m_axis_tlast <= 0;
 
-                    CAM_TMP_ENTRY: begin
-                        if(c_s_axis_tvalid) begin
-                            cam_entry_reg <= c_s_axis_tdata_swapped[511 -: 205];
-                            c_wr_en_cam <= 1'b1;
-                            if(c_s_axis_tlast) begin
-                                c_state <= IDLE_C;
-                            end
-                            else begin
-                                c_state <= SU_CAM_TMP_ENTRY;
-                            end
+                        c_state <= IDLE_C;
+                    end
+                end
+
+                CAM_TMP_ENTRY: begin
+                    if(c_s_axis_tvalid) begin
+                        cam_entry_reg <= c_s_axis_tdata_swapped[511 -: 205];
+                        c_wr_en_cam <= 1'b1;
+                        if(c_s_axis_tlast) begin
+                            c_state <= IDLE_C;
                         end
                         else begin
-                            c_wr_en_cam <= 1'b0;
+                            c_state <= SU_CAM_TMP_ENTRY;
                         end
                     end
+                    else begin
+                        c_wr_en_cam <= 1'b0;
+                    end
+                end
 
-                    SU_CAM_TMP_ENTRY: begin
-                        if(c_s_axis_tvalid) begin
-                            cam_entry_reg <= c_s_axis_tdata_swapped[511 -: 205];
-                            c_wr_en_cam <= 1'b1;
-                            c_index_cam <= c_index_cam + 1'b1;
-                            if(c_s_axis_tlast) begin
-                                c_state <= IDLE_C;
-                            end
-                            else begin
-                                c_state <= SU_CAM_TMP_ENTRY;
-                            end
+                SU_CAM_TMP_ENTRY: begin
+                    if(c_s_axis_tvalid) begin
+                        cam_entry_reg <= c_s_axis_tdata_swapped[511 -: 205];
+                        c_wr_en_cam <= 1'b1;
+                        c_index_cam <= c_index_cam + 1'b1;
+                        if(c_s_axis_tlast) begin
+                            c_state <= IDLE_C;
                         end
                         else begin
-                            c_wr_en_cam <= 1'b0;
+                            c_state <= SU_CAM_TMP_ENTRY;
                         end
                     end
-                endcase
-            end
+                    else begin
+                        c_wr_en_cam <= 1'b0;
+                    end
+                end
+            endcase
         end
-
-		if (STAGE_ID == 4) begin
-			// tcam1 for lookup
-        	cam_top # ( 
-        	    .C_DEPTH			(16),
-        	    // .C_WIDTH			(256),
-        	    .C_WIDTH			(205),
-        	    .C_MEM_INIT			(0)
-        	    // .C_MEM_INIT_FILE	("./cam_init_file.mif")
-        	)
-        	cam_0
-        	(
-        	    .CLK				(clk),
-        	    .CMP_DIN			({vlan_id[3:0], vlan_id[11:4], extract_key}),
-        	    //.CMP_DATA_MASK		({4'b1111, extract_mask}),
-        	    .CMP_DATA_MASK      (),
-				.BUSY				(),
-        	    .MATCH				(match),
-        	    .MATCH_ADDR			(match_addr[3:0]),
-
-        	    //.WE				(lookup_din_en),
-        	    //.WR_ADDR			(lookup_din_addr),
-        	    //.DATA_MASK		(lookup_din_mask),  
-        	    //.DIN				(lookup_din),
-
-        	    .WE                 (c_wr_en_cam),
-        	    .WR_ADDR            (c_index_cam[3:0]),
-        	    .DATA_MASK          (),  //TODO do we need ternary matching?
-        	    .DIN                (cam_entry_reg),
-        	    .EN					(1'b1)
-        	);
-		end
-		else begin
-			// tcam1 for lookup
-        	cam_top # ( 
-        	    .C_DEPTH			(16),
-        	    // .C_WIDTH			(256),
-        	    .C_WIDTH			(205),
-        	    .C_MEM_INIT			(0)
-        	    // .C_MEM_INIT_FILE	("./cam_init_file.mif")
-        	)
-        	cam_0
-        	(
-        	    .CLK				(clk),
-        	    .CMP_DIN			({vlan_id[3:0], vlan_id[11:4], extract_key}),
-        	    //.CMP_DATA_MASK		({4'b0000, extract_mask}),
-        	    .CMP_DATA_MASK      (),
-        	    .BUSY				(),
-        	    .MATCH				(match),
-        	    .MATCH_ADDR			(match_addr[3:0]),
-
-        	    //.WE				(lookup_din_en),
-        	    //.WR_ADDR			(lookup_din_addr),
-        	    //.DATA_MASK		(lookup_din_mask),  
-        	    //.DIN				(lookup_din),
-
-        	    .WE                 (c_wr_en_cam),
-        	    .WR_ADDR            (c_index_cam[3:0]),
-        	    .DATA_MASK          (),  //TODO do we need ternary matching?
-        	    .DIN                (cam_entry_reg),
-        	    .EN					(1'b1)
-        	);
-		end
     end
-    //NOTE: data width is 256b
-    else begin
-		wire[C_S_AXIS_DATA_WIDTH-1:0] c_s_axis_tdata_swapped;
-		assign c_s_axis_tdata_swapped = {	c_s_axis_tdata[0+:8],
-											c_s_axis_tdata[8+:8],
-											c_s_axis_tdata[16+:8],
-											c_s_axis_tdata[24+:8],
-											c_s_axis_tdata[32+:8],
-											c_s_axis_tdata[40+:8],
-											c_s_axis_tdata[48+:8],
-											c_s_axis_tdata[56+:8],
-											c_s_axis_tdata[64+:8],
-											c_s_axis_tdata[72+:8],
-											c_s_axis_tdata[80+:8],
-											c_s_axis_tdata[88+:8],
-											c_s_axis_tdata[96+:8],
-											c_s_axis_tdata[104+:8],
-											c_s_axis_tdata[112+:8],
-											c_s_axis_tdata[120+:8],
-											c_s_axis_tdata[128+:8],
-											c_s_axis_tdata[136+:8],
-											c_s_axis_tdata[144+:8],
-											c_s_axis_tdata[152+:8],
-											c_s_axis_tdata[160+:8],
-											c_s_axis_tdata[168+:8],
-											c_s_axis_tdata[176+:8],
-											c_s_axis_tdata[184+:8],
-											c_s_axis_tdata[192+:8],
-											c_s_axis_tdata[200+:8],
-											c_s_axis_tdata[208+:8],
-											c_s_axis_tdata[216+:8],
-											c_s_axis_tdata[224+:8],
-											c_s_axis_tdata[232+:8],
-											c_s_axis_tdata[240+:8],
-											c_s_axis_tdata[248+:8]};
-
-        assign mod_id = c_s_axis_tdata[112+:8];
-        assign resv = c_s_axis_tdata[120+:4];
-        assign control_flag = c_s_axis_tdata[64+:16];
-		// 
-		reg [2:0] c_state_next;
-		reg [C_S_AXIS_DATA_WIDTH-1:0]		r_tdata, c_s_axis_tdata_d1;
-		reg [C_S_AXIS_TUSER_WIDTH-1:0]		r_tuser, c_s_axis_tuser_d1;
-		reg [C_S_AXIS_DATA_WIDTH/8-1:0]		r_tkeep, c_s_axis_tkeep_d1;
-		reg									r_tlast, c_s_axis_tlast_d1;
-		reg									r_tvalid, c_s_axis_tvalid_d1;
-
-		reg [C_S_AXIS_DATA_WIDTH-1:0]		r_1st_tdata, r_1st_tdata_next;
-		reg [C_S_AXIS_TUSER_WIDTH-1:0]		r_1st_tuser, r_1st_tuser_next;
-		reg [C_S_AXIS_DATA_WIDTH/8-1:0]		r_1st_tkeep, r_1st_tkeep_next;
-		reg									r_1st_tlast, r_1st_tlast_next;
-		reg									r_1st_tvalid, r_1st_tvalid_next;
-
-		reg [7:0]							c_index_cam_next, c_index_act_next;
-		reg									c_wr_en_cam_next, c_wr_en_act_next;
-		reg [204:0]							c_wr_cam_data, c_wr_cam_data_next;
-		reg [ACT_LEN-1:0]					c_wr_act_data, c_wr_act_data_next;
-
-		always @(*) begin
-			c_state_next = c_state;
-
-			r_tdata = 0;
-			r_tkeep = 0;
-			r_tuser = 0;
-			r_tlast = 0;
-			r_tvalid = 0;
-
-			r_1st_tdata_next = r_1st_tdata;
-			r_1st_tkeep_next = r_1st_tkeep;
-			r_1st_tuser_next = r_1st_tuser;
-			r_1st_tlast_next = r_1st_tlast;
-			r_1st_tvalid_next = r_1st_tvalid;
-
-			c_index_cam_next = c_index_cam;
-			c_index_act_next = c_index_act;
-			c_wr_en_cam_next = 0;
-			c_wr_en_act_next = 0;
-			c_wr_cam_data_next = c_wr_cam_data;
-			c_wr_act_data_next = c_wr_act_data;
-
-			case (c_state) 
-				IDLE_C: begin // 1st segment
-					r_tvalid = 0;
-					if (c_s_axis_tvalid) begin
-						// store 1st segment
-						r_1st_tdata_next = c_s_axis_tdata;
-						r_1st_tuser_next = c_s_axis_tuser;
-						r_1st_tkeep_next = c_s_axis_tkeep;
-						r_1st_tlast_next = c_s_axis_tlast;
-						r_1st_tvalid_next = c_s_axis_tvalid;
-
-						c_state_next = PARSE_C;
-					end
-				end
-				PARSE_C: begin // 2nd segment
-					if (mod_id[7:3] == STAGE_ID && mod_id[2:0] == LOOKUP_ID && 
-						control_flag == 16'hf2f1 && c_s_axis_tvalid && resv==4'b0) begin
-						// should not emit segment
-						c_index_cam_next = c_s_axis_tdata[128+:8];
-						c_state_next = CAM_TMP_ENTRY;
-					end
-					else if (!c_s_axis_tvalid) begin
-					end
-					else begin
-						// emit
-						r_tdata = r_1st_tdata;
-						r_tkeep = r_1st_tkeep;
-						r_tuser = r_1st_tuser;
-						r_tlast = r_1st_tlast;
-						r_tvalid = r_1st_tvalid;
-						c_state_next = FLUSH_REST_C;
-					end
-				end
-				CAM_TMP_ENTRY: begin
-					if (c_s_axis_tvalid) begin
-						c_wr_en_cam_next = 1; // next clk to write
-						c_wr_cam_data_next = c_s_axis_tdata_swapped[51+:205];
-						
-						c_state_next = IDLE_C;
-					end
-				end
-				FLUSH_REST_C: begin
-					c_wr_en_cam_next = 0;
-					c_wr_en_act_next = 0;
-					r_tdata = c_s_axis_tdata_d1;
-					r_tkeep = c_s_axis_tkeep_d1;
-					r_tuser = c_s_axis_tuser_d1;
-					r_tlast = c_s_axis_tlast_d1;
-					r_tvalid = c_s_axis_tvalid_d1;
-					if (c_s_axis_tvalid_d1 && c_s_axis_tlast_d1) begin
-						c_state_next = IDLE_C;
-					end
-				end
-			endcase
-		end
-
-		always @(posedge clk) begin
-			if (~rst_n) begin
-				c_state <= IDLE_C;
-
-				// control output
-				c_m_axis_tdata <= 0;
-				c_m_axis_tuser <= 0;
-				c_m_axis_tkeep <= 0;
-				c_m_axis_tlast <= 0;
-				c_m_axis_tvalid <= 0;
-				//
-				c_index_cam <= 0;
-				c_index_act <= 0;
-				c_wr_en_cam <= 0;
-				c_wr_en_act <= 0;
-				c_wr_cam_data <= 0;
-				c_wr_act_data <= 0;
-			end
-			else begin
-				c_state <= c_state_next;
-
-
-				// output ctrl master signals
-				c_m_axis_tdata <= r_tdata;
-				c_m_axis_tkeep <= r_tkeep;
-				c_m_axis_tuser <= r_tuser;
-				c_m_axis_tlast <= r_tlast;
-				c_m_axis_tvalid <= r_tvalid;
-				//
-				c_index_cam <= c_index_cam_next;
-				c_index_act <= c_index_act_next;
-				c_wr_en_cam <= c_wr_en_cam_next;
-				c_wr_en_act <= c_wr_en_act_next;
-				c_wr_cam_data <= c_wr_cam_data_next;
-				c_wr_act_data <= c_wr_act_data_next;
-			end
-		end
-
-		always @(posedge clk) begin
-			if (~rst_n) begin
-				// delayed 1 clk
-				c_s_axis_tdata_d1 <= 0;
-				c_s_axis_tuser_d1 <= 0;
-				c_s_axis_tkeep_d1 <= 0;
-				c_s_axis_tlast_d1 <= 0;
-				c_s_axis_tvalid_d1 <= 0;
-				//
-				r_1st_tdata <= 0;
-				r_1st_tkeep <= 0;
-				r_1st_tuser <= 0;
-				r_1st_tlast <= 0;
-				r_1st_tvalid <= 0;
-			end
-			else begin
-				// delayed 1 clk
-				c_s_axis_tdata_d1 <= c_s_axis_tdata;
-				c_s_axis_tuser_d1 <= c_s_axis_tuser;
-				c_s_axis_tkeep_d1 <= c_s_axis_tkeep;
-				c_s_axis_tlast_d1 <= c_s_axis_tlast;
-				c_s_axis_tvalid_d1 <= c_s_axis_tvalid;
-				// 
-				r_1st_tdata <= r_1st_tdata_next;
-				r_1st_tkeep <= r_1st_tkeep_next;
-				r_1st_tuser <= r_1st_tuser_next;
-				r_1st_tlast <= r_1st_tlast_next;
-				r_1st_tvalid <= r_1st_tvalid_next;
-			end
-		end
-
-		if (STAGE_ID == 4) begin
-			// tcam1 for lookup
-        	cam_top # ( 
-        	    .C_DEPTH			(16),
-        	    // .C_WIDTH			(256),
-        	    .C_WIDTH			(205), // 192+1+12
-        	    .C_MEM_INIT			(0)
-        	    // .C_MEM_INIT_FILE	("./cam_init_file.mif")
-        	)
-        	//TODO remember to change it back.
-        	cam_0
-        	(
-        	    .CLK				(clk),
-        	    .CMP_DIN			({vlan_id[3:0], vlan_id[11:4], extract_key}),
-        	    // .CMP_DATA_MASK		({4'b1111, extract_mask}),
-        	    .CMP_DATA_MASK		(),
-        	    .BUSY				(),
-        	    .MATCH				(match),
-        	    .MATCH_ADDR			(match_addr),
-
-        	    //.WE				(lookup_din_en),
-        	    //.WR_ADDR			(lookup_din_addr),
-        	    //.DATA_MASK		(lookup_din_mask),  
-        	    //.DIN				(lookup_din),
-
-        	    .WE                 (c_wr_en_cam),
-        	    .WR_ADDR            (c_index_cam[3:0]),
-        	    // .WR_ADDR            (c_index_cam),
-        	    .DATA_MASK          (),  //TODO do we need ternary matching?
-        	    .DIN                (c_wr_cam_data),
-        	    .EN					(1'b1)
-        	);
-		end
-		else begin
-			// tcam1 for lookup
-        	cam_top # ( 
-        	    .C_DEPTH			(16),
-        	    // .C_WIDTH			(256),
-        	    .C_WIDTH			(205), // 192+1+12
-        	    .C_MEM_INIT			(0)
-        	    // .C_MEM_INIT_FILE	("./cam_init_file.mif")
-        	)
-        	//TODO remember to change it back.
-        	cam_0
-        	(
-        	    .CLK				(clk),
-        	    .CMP_DIN			({vlan_id[3:0], vlan_id[11:4], extract_key}),
-        	    // .CMP_DATA_MASK		({4'b0000, extract_mask}),
-        	    .CMP_DATA_MASK		(),
-        	    .BUSY				(),
-        	    .MATCH				(match),
-        	    .MATCH_ADDR			(match_addr),
-
-        	    //.WE				(lookup_din_en),
-        	    //.WR_ADDR			(lookup_din_addr),
-        	    //.DATA_MASK		(lookup_din_mask),  
-        	    //.DIN				(lookup_din),
-
-        	    .WE                 (c_wr_en_cam),
-        	    .WR_ADDR            (c_index_cam[3:0]),
-        	    // .WR_ADDR            (c_index_cam),
-        	    .DATA_MASK          (),  //TODO do we need ternary matching?
-        	    .DIN                (c_wr_cam_data),
-        	    .EN					(1'b1)
-        	);
-		end
+    
+    always @(posedge clk) begin
+        if(~rst_n) begin
+            rst_busy <= 0;
+            
+            cam_in <= 0;
+            key_valid_r <= 0;
+            
+            cam_out_data <= 0;
+            cam_out_valid <= 0;
+            cam_lkup_ready <= 0;
+            
+            conf_in <= 0;
+            c_wr_en_cam_r <= 0;
+            
+            cam_hwui_ready <= 0;
+        end
+        else begin
+            rst_busy <= rst_busy_r;
+            
+            cam_in <= {3'b000, vlan_id_ff[3:0], vlan_id_ff[11:4], extract_key_ff};
+            key_valid_r <= key_valid_ff;
+            
+            cam_out_data <= cam_out_data_r;
+            cam_out_valid <= cam_out_valid_r;
+            cam_lkup_ready <= cam_lkup_ready_r;
+            
+            conf_in <= {4'b0000, c_index_cam[3:0], 3'b000, cam_entry_reg, 8'h00};
+            c_wr_en_cam_r <= c_wr_en_cam;
+            
+            cam_hwui_ready <= cam_hwui_ready_r;
+        end
     end
-
+    
+    cam_top
+    cam_inst
+    (
+        // Inputs
+        .s_axi_aclk(clk),
+        .s_axi_aresetn(cam_rst),
+        .rstn(cam_rst),
+        .key_clk(clk),
+        .ram_clk(clk),
+        
+        // Outputs
+        .rst_busy(rst_busy_r),
+        .sbiterr(),
+        .dbiterr(),
+        .debug_status(),
+        
+        // axi stream inputs
+        .s_axis_lkup_tdata(cam_in),
+        .s_axis_lkup_tvalid(key_valid_r),
+        .m_axis_lkup_tready(ready_in),
+        
+        // axi stream outputs
+        .m_axis_lkup_tdata(cam_out_data_r),
+        .m_axis_lkup_tvalid(cam_out_valid_r),
+        .s_axis_lkup_tready(cam_lkup_ready_r),
+        
+        // axi stream config in
+        .s_axis_hwui_tdata(conf_in),
+        .s_axis_hwui_tvalid(c_wr_en_cam_r),
+        .m_axis_hwui_tready(1'b1),
+        
+        // axi stream config out
+        .m_axis_hwui_tdata(),
+        .m_axis_hwui_tvalid(),
+        .s_axis_hwui_tready(cam_hwui_ready_r),
+        
+        // axi light inputs
+        .s_axi_araddr(13'b0000000000000),
+        .s_axi_arvalid(1'b0),
+        .s_axi_rready(1'b1),
+        .s_axi_awaddr(13'b0000000000000),
+        .s_axi_awvalid(1'b0),
+        .s_axi_wdata(32'h00000000),
+        .s_axi_wvalid(1'b0),
+        .s_axi_wstrb(4'b0000),
+        .s_axi_bready(1'b1),
+        
+        // axi light outputs
+        .s_axi_rdata(),
+        .s_axi_rresp(),
+        .s_axi_rvalid(),
+        .s_axi_arready(),
+        .s_axi_bresp(),
+        .s_axi_bvalid(),
+        .s_axi_awready(),
+        .s_axi_wready()
+    );
 endgenerate
 
 endmodule
diff -ruN '--exclude=.git' '--exclude=p4c' '--exclude=tb' menshen/lookup/lke_ram_part.v parametric_menshen/lookup/lke_ram_part.v
--- menshen/lookup/lke_ram_part.v
+++ parametric_menshen/lookup/lke_ram_part.v
@@ -71,7 +71,7 @@
 		   EMPTY1_S = 3'd5,
 		   OUTPUT_S = 3'd6;
 
-assign ready_out = lookup_state!=HALT_S;
+assign ready_out = (lookup_state!=HALT_S) && (lookup_state!=WAIT1_S || ready_in);
 
 always @(posedge clk or negedge rst_n) begin
 
@@ -89,24 +89,21 @@
     end
 
     else begin
+        phv_out <= phv_reg;
+        act_vlan_out <= vlan_id;
+        action_valid <= 1'b0;
+
         case(lookup_state)
             IDLE_S: begin
                 if (phv_valid == 1'b1) begin
+                    lookup_state <= WAIT1_S;
 					// ready_out <= 1'b0;
-                    phv_reg <= phv_in;
-					act_vlan_out <= vlan_id;
+					phv_reg <= phv_in;
+					act_vlan_out_valid <= act_vlan_ready;
 					if_match_d1 <= if_match;
-
-					if (act_vlan_ready) begin
-						act_vlan_out_valid <= 1;
-					end
-
-					lookup_state <= WAIT1_S;
                 end
                 else begin
 					// ready_out <= 1'b1;
-                    lookup_state <= IDLE_S;
-					action_valid <= 1'b0;
 					act_vlan_out_valid <= 0;
 					if_match_d1 <= 0;
                 end
@@ -117,7 +114,6 @@
 					act_vlan_out_valid <= 0;
 					action_valid <= 1'b1;
 					// ready_out <= 1'b1;
-					phv_out <= phv_reg;
 					lookup_state <= IDLE_S;
 				end
 				else begin
@@ -129,7 +125,6 @@
 					act_vlan_out_valid <= 0;
 					action_valid <= 1'b1;
 					// ready_out <= 1'b1;
-					phv_out <= phv_reg;
 					lookup_state <= IDLE_S;
 				end
 			end
@@ -164,10 +159,6 @@
 
 reg [2:0]           c_state;
 
-/****for 256b exclusively*****/
-reg                                 c_m_axis_tvalid_r;
-reg                                 c_m_axis_tlast_r;
-
 
 localparam IDLE_C = 0,
            PARSE_C = 1,
@@ -178,134 +169,113 @@
            ACT_TMP_ENTRY = 6,
 		   FLUSH_REST_C = 7;
 
-generate 
-    if(C_S_AXIS_DATA_WIDTH == 512) begin
-        assign mod_id = c_s_axis_tdata[368+:8];
-        assign resv   = c_s_axis_tdata[376+:4];
-        assign control_flag = c_s_axis_tdata[335:320];
-        //LE to BE switching
-        wire[C_S_AXIS_DATA_WIDTH-1:0] c_s_axis_tdata_swapped;
-
-		assign c_s_axis_tdata_swapped = {	c_s_axis_tdata[0+:8],
-											c_s_axis_tdata[8+:8],
-											c_s_axis_tdata[16+:8],
-											c_s_axis_tdata[24+:8],
-											c_s_axis_tdata[32+:8],
-											c_s_axis_tdata[40+:8],
-											c_s_axis_tdata[48+:8],
-											c_s_axis_tdata[56+:8],
-											c_s_axis_tdata[64+:8],
-											c_s_axis_tdata[72+:8],
-											c_s_axis_tdata[80+:8],
-											c_s_axis_tdata[88+:8],
-											c_s_axis_tdata[96+:8],
-											c_s_axis_tdata[104+:8],
-											c_s_axis_tdata[112+:8],
-											c_s_axis_tdata[120+:8],
-											c_s_axis_tdata[128+:8],
-											c_s_axis_tdata[136+:8],
-											c_s_axis_tdata[144+:8],
-											c_s_axis_tdata[152+:8],
-											c_s_axis_tdata[160+:8],
-											c_s_axis_tdata[168+:8],
-											c_s_axis_tdata[176+:8],
-											c_s_axis_tdata[184+:8],
-											c_s_axis_tdata[192+:8],
-											c_s_axis_tdata[200+:8],
-											c_s_axis_tdata[208+:8],
-											c_s_axis_tdata[216+:8],
-											c_s_axis_tdata[224+:8],
-											c_s_axis_tdata[232+:8],
-											c_s_axis_tdata[240+:8],
-											c_s_axis_tdata[248+:8],
-                                            c_s_axis_tdata[256+:8],
-                                            c_s_axis_tdata[264+:8],
-                                            c_s_axis_tdata[272+:8],
-                                            c_s_axis_tdata[280+:8],
-                                            c_s_axis_tdata[288+:8],
-                                            c_s_axis_tdata[296+:8],
-                                            c_s_axis_tdata[304+:8],
-                                            c_s_axis_tdata[312+:8],
-                                            c_s_axis_tdata[320+:8],
-                                            c_s_axis_tdata[328+:8],
-                                            c_s_axis_tdata[336+:8],
-                                            c_s_axis_tdata[344+:8],
-                                            c_s_axis_tdata[352+:8],
-                                            c_s_axis_tdata[360+:8],
-                                            c_s_axis_tdata[368+:8],
-                                            c_s_axis_tdata[376+:8],
-                                            c_s_axis_tdata[384+:8],
-                                            c_s_axis_tdata[392+:8],
-                                            c_s_axis_tdata[400+:8],
-                                            c_s_axis_tdata[408+:8],
-                                            c_s_axis_tdata[416+:8],
-                                            c_s_axis_tdata[424+:8],
-                                            c_s_axis_tdata[432+:8],
-                                            c_s_axis_tdata[440+:8],
-                                            c_s_axis_tdata[448+:8],
-                                            c_s_axis_tdata[456+:8],
-                                            c_s_axis_tdata[464+:8],
-                                            c_s_axis_tdata[472+:8],
-                                            c_s_axis_tdata[480+:8],
-                                            c_s_axis_tdata[488+:8],
-                                            c_s_axis_tdata[496+:8],
-                                            c_s_axis_tdata[504+:8]
-                                            };
-        always @(posedge clk or negedge rst_n) begin
-            if(~rst_n) begin
-                c_index_cam <= 0;
-                c_wr_en_cam <= 0;
-
-                c_index_act <= 0;
-                c_wr_en_act <= 0;
-
-                act_entry_tmp <= 0;
-                cam_entry_reg <= 0;
-                continous_flag <= 0;
-
-                c_m_axis_tdata <= 0;
-                c_m_axis_tuser <= 0;
-                c_m_axis_tkeep <= 0;
-                c_m_axis_tvalid <= 0;
-                c_m_axis_tlast <= 0;
+generate
+    assign mod_id = c_s_axis_tdata[368+:8];
+    assign resv   = c_s_axis_tdata[376+:4];
+    assign control_flag = c_s_axis_tdata[303:288];
+    //LE to BE switching
+    wire[C_S_AXIS_DATA_WIDTH-1:0] c_s_axis_tdata_swapped;
+
+    assign c_s_axis_tdata_swapped = {	c_s_axis_tdata[0+:8],
+									    c_s_axis_tdata[8+:8],
+									    c_s_axis_tdata[16+:8],
+									    c_s_axis_tdata[24+:8],
+									    c_s_axis_tdata[32+:8],
+									    c_s_axis_tdata[40+:8],
+									    c_s_axis_tdata[48+:8],
+									    c_s_axis_tdata[56+:8],
+									    c_s_axis_tdata[64+:8],
+									    c_s_axis_tdata[72+:8],
+									    c_s_axis_tdata[80+:8],
+									    c_s_axis_tdata[88+:8],
+									    c_s_axis_tdata[96+:8],
+									    c_s_axis_tdata[104+:8],
+									    c_s_axis_tdata[112+:8],
+									    c_s_axis_tdata[120+:8],
+									    c_s_axis_tdata[128+:8],
+									    c_s_axis_tdata[136+:8],
+									    c_s_axis_tdata[144+:8],
+									    c_s_axis_tdata[152+:8],
+									    c_s_axis_tdata[160+:8],
+									    c_s_axis_tdata[168+:8],
+									    c_s_axis_tdata[176+:8],
+									    c_s_axis_tdata[184+:8],
+									    c_s_axis_tdata[192+:8],
+									    c_s_axis_tdata[200+:8],
+									    c_s_axis_tdata[208+:8],
+									    c_s_axis_tdata[216+:8],
+									    c_s_axis_tdata[224+:8],
+									    c_s_axis_tdata[232+:8],
+									    c_s_axis_tdata[240+:8],
+									    c_s_axis_tdata[248+:8],
+                                        c_s_axis_tdata[256+:8],
+                                        c_s_axis_tdata[264+:8],
+                                        c_s_axis_tdata[272+:8],
+                                        c_s_axis_tdata[280+:8],
+                                        c_s_axis_tdata[288+:8],
+                                        c_s_axis_tdata[296+:8],
+                                        c_s_axis_tdata[304+:8],
+                                        c_s_axis_tdata[312+:8],
+                                        c_s_axis_tdata[320+:8],
+                                        c_s_axis_tdata[328+:8],
+                                        c_s_axis_tdata[336+:8],
+                                        c_s_axis_tdata[344+:8],
+                                        c_s_axis_tdata[352+:8],
+                                        c_s_axis_tdata[360+:8],
+                                        c_s_axis_tdata[368+:8],
+                                        c_s_axis_tdata[376+:8],
+                                        c_s_axis_tdata[384+:8],
+                                        c_s_axis_tdata[392+:8],
+                                        c_s_axis_tdata[400+:8],
+                                        c_s_axis_tdata[408+:8],
+                                        c_s_axis_tdata[416+:8],
+                                        c_s_axis_tdata[424+:8],
+                                        c_s_axis_tdata[432+:8],
+                                        c_s_axis_tdata[440+:8],
+                                        c_s_axis_tdata[448+:8],
+                                        c_s_axis_tdata[456+:8],
+                                        c_s_axis_tdata[464+:8],
+                                        c_s_axis_tdata[472+:8],
+                                        c_s_axis_tdata[480+:8],
+                                        c_s_axis_tdata[488+:8],
+                                        c_s_axis_tdata[496+:8],
+                                        c_s_axis_tdata[504+:8]
+                                        };
+    always @(posedge clk or negedge rst_n) begin
+        if(~rst_n) begin
+            c_index_cam <= 0;
+            c_wr_en_cam <= 0;
+
+            c_index_act <= 0;
+            c_wr_en_act <= 0;
+
+            act_entry_tmp <= 0;
+            cam_entry_reg <= 0;
+            continous_flag <= 0;
+
+            c_m_axis_tdata <= 0;
+            c_m_axis_tuser <= 0;
+            c_m_axis_tkeep <= 0;
+            c_m_axis_tvalid <= 0;
+            c_m_axis_tlast <= 0;
 
-                c_state <= IDLE_C;
+            c_state <= IDLE_C;
 
-            end
-
-            else begin
-                case(c_state)
-                    IDLE_C: begin
-                        if(c_s_axis_tvalid) begin
-                            if(mod_id[7:3] == STAGE_ID && mod_id[2:0] == LOOKUP_ID 
-									&& control_flag == 16'hf2f1
-									&& resv != 4'b0) begin
-                                //ACTION entry
-                                continous_flag <= 1'b0;
-                                c_index_act <= c_s_axis_tdata[384+:8];
-                                c_state <= ACT_TMP_ENTRY_WAIT;
-                            end
-                            //not for lookup
-                            else begin
-                                c_index_cam <= 0;
-                                c_wr_en_cam <= 0;
-
-                                c_index_act <= 0;
-                                c_wr_en_act <= 0;
-
-                                act_entry_tmp <= 0;
-                                continous_flag <= 0;
-
-                                c_m_axis_tdata <= c_s_axis_tdata;
-                                c_m_axis_tuser <= c_s_axis_tuser;
-                                c_m_axis_tkeep <= c_s_axis_tkeep;
-                                c_m_axis_tvalid <= c_s_axis_tvalid;
-                                c_m_axis_tlast <= c_s_axis_tlast;
+        end
 
-                                c_state <= IDLE_C;
-                            end
+        else begin
+            case(c_state)
+                IDLE_C: begin
+                    if(c_s_axis_tvalid) begin
+                        if(mod_id[7:3] == STAGE_ID && mod_id[2:0] == LOOKUP_ID 
+							    && control_flag == 16'hf2f1
+							    && resv != 4'b0) begin
+                            //ACTION entry
+                            continous_flag <= 1'b0;
+                            c_index_act <= c_s_axis_tdata[384+:8];
+                            c_state <= ACT_TMP_ENTRY_WAIT;
                         end
-                        //stay halt
+                        //not for lookup
                         else begin
                             c_index_cam <= 0;
                             c_wr_en_cam <= 0;
@@ -316,316 +286,95 @@
                             act_entry_tmp <= 0;
                             continous_flag <= 0;
 
-                            c_m_axis_tdata <= 0;
-                            c_m_axis_tuser <= 0;
-                            c_m_axis_tkeep <= 0;
-                            c_m_axis_tvalid <= 0;
-                            c_m_axis_tlast <= 0;
+                            c_m_axis_tdata <= c_s_axis_tdata;
+                            c_m_axis_tuser <= c_s_axis_tuser;
+                            c_m_axis_tkeep <= c_s_axis_tkeep;
+                            c_m_axis_tvalid <= c_s_axis_tvalid;
+                            c_m_axis_tlast <= c_s_axis_tlast;
 
                             c_state <= IDLE_C;
                         end
                     end
+                    //stay halt
+                    else begin
+                        c_index_cam <= 0;
+                        c_wr_en_cam <= 0;
+
+                        c_index_act <= 0;
+                        c_wr_en_act <= 0;
+
+                        act_entry_tmp <= 0;
+                        continous_flag <= 0;
+
+                        c_m_axis_tdata <= 0;
+                        c_m_axis_tuser <= 0;
+                        c_m_axis_tkeep <= 0;
+                        c_m_axis_tvalid <= 0;
+                        c_m_axis_tlast <= 0;
 
-                    ACT_TMP_ENTRY_WAIT: begin
-                        c_m_axis_tvalid_r <= 1'b0;
-                        c_m_axis_tlast_r <= 1'b0;
-                        //flush the whole table
-                        if(c_s_axis_tvalid && ~c_s_axis_tlast) begin
-                            if (continous_flag)   c_index_act <= c_index_act + 8'b1;
-                            else                  c_index_act <= c_index_act;
-                            act_entry_tmp[624 -: 512] <= c_s_axis_tdata_swapped;
-                            c_wr_en_act <= 1'b0;
-                            c_state <= ACT_TMP_ENTRY;
-                        end
-                        else if(c_s_axis_tvalid && c_s_axis_tlast) begin
-                            c_wr_en_act <= 1'b0;
-                            c_state <= IDLE_C;
-                        end
-                        else begin
-                            c_wr_en_act <= 1'b0;
-                            c_state <= c_state;
-                        end
+                        c_state <= IDLE_C;
                     end
+                end
 
-                    ACT_TMP_ENTRY: begin
-                        if(c_s_axis_tvalid) begin
-                            act_entry_tmp[112:0] <= c_s_axis_tdata_swapped[511-:113];
-                            c_wr_en_act <= 1'b1;
-                            if(c_s_axis_tlast)   c_state <= IDLE_C;
-                            else begin
-                                continous_flag <= 1'b1;
-                                c_state <= ACT_TMP_ENTRY_WAIT;
-                            end
-                        end
+                ACT_TMP_ENTRY_WAIT: begin
+                    //flush the whole table
+                    if(c_s_axis_tvalid && ~c_s_axis_tlast) begin
+                        if (continous_flag)   c_index_act <= c_index_act + 8'b1;
+                        else                  c_index_act <= c_index_act;
+                        act_entry_tmp[624 -: 512] <= c_s_axis_tdata_swapped;
+                        c_wr_en_act <= 1'b0;
+                        c_state <= ACT_TMP_ENTRY;
+                    end
+                    else if(c_s_axis_tvalid && c_s_axis_tlast) begin
+                        c_wr_en_act <= 1'b0;
+                        c_state <= IDLE_C;
+                    end
+                    else begin
+                        c_wr_en_act <= 1'b0;
+                        c_state <= c_state;
+                    end
+                end
+
+                ACT_TMP_ENTRY: begin
+                    if(c_s_axis_tvalid) begin
+                        act_entry_tmp[112:0] <= c_s_axis_tdata_swapped[511-:113];
+                        c_wr_en_act <= 1'b1;
+                        if(c_s_axis_tlast)   c_state <= IDLE_C;
                         else begin
-                            c_state <= c_state;
-                            act_entry_tmp <= act_entry_tmp;
-                            c_wr_en_act <= c_wr_en_act;
+                            continous_flag <= 1'b1;
+                            c_state <= ACT_TMP_ENTRY_WAIT;
                         end
                     end
+                    else begin
+                        c_state <= c_state;
+                        act_entry_tmp <= act_entry_tmp;
+                        c_wr_en_act <= c_wr_en_act;
+                    end
+                end
 
-                endcase
-            end
+            endcase
         end
-
-        //ram for action
-        // blk_mem_gen_1 #(
-        // 	.C_INIT_FILE_NAME	("./llup.mif"),
-        // 	.C_LOAD_INIT_FILE	(1)
-        // )
-        blk_mem_gen_1
-        act_ram_625w_16d
-        (
-            .addra(c_index_act[3:0]),
-            .clka(clk),
-            .dina(act_entry_tmp),
-            .ena(1'b1),
-            .wea(c_wr_en_act),
-
-            .addrb(match_addr[3:0]),
-            .clkb(clk),
-            .doutb(action_wire),
-            .enb(1'b1)
-        );
-
-    end
-    //NOTE: data width is 256b
-    else begin
-		wire[C_S_AXIS_DATA_WIDTH-1:0] c_s_axis_tdata_swapped;
-		assign c_s_axis_tdata_swapped = {	c_s_axis_tdata[0+:8],
-											c_s_axis_tdata[8+:8],
-											c_s_axis_tdata[16+:8],
-											c_s_axis_tdata[24+:8],
-											c_s_axis_tdata[32+:8],
-											c_s_axis_tdata[40+:8],
-											c_s_axis_tdata[48+:8],
-											c_s_axis_tdata[56+:8],
-											c_s_axis_tdata[64+:8],
-											c_s_axis_tdata[72+:8],
-											c_s_axis_tdata[80+:8],
-											c_s_axis_tdata[88+:8],
-											c_s_axis_tdata[96+:8],
-											c_s_axis_tdata[104+:8],
-											c_s_axis_tdata[112+:8],
-											c_s_axis_tdata[120+:8],
-											c_s_axis_tdata[128+:8],
-											c_s_axis_tdata[136+:8],
-											c_s_axis_tdata[144+:8],
-											c_s_axis_tdata[152+:8],
-											c_s_axis_tdata[160+:8],
-											c_s_axis_tdata[168+:8],
-											c_s_axis_tdata[176+:8],
-											c_s_axis_tdata[184+:8],
-											c_s_axis_tdata[192+:8],
-											c_s_axis_tdata[200+:8],
-											c_s_axis_tdata[208+:8],
-											c_s_axis_tdata[216+:8],
-											c_s_axis_tdata[224+:8],
-											c_s_axis_tdata[232+:8],
-											c_s_axis_tdata[240+:8],
-											c_s_axis_tdata[248+:8]};
-
-        assign mod_id = c_s_axis_tdata[112+:8];
-        assign resv = c_s_axis_tdata[120+:4];
-        assign control_flag = c_s_axis_tdata[64+:16];
-		// 
-		reg [2:0] c_state_next;
-		reg [C_S_AXIS_DATA_WIDTH-1:0]		r_tdata, c_s_axis_tdata_d1;
-		reg [C_S_AXIS_TUSER_WIDTH-1:0]		r_tuser, c_s_axis_tuser_d1;
-		reg [C_S_AXIS_DATA_WIDTH/8-1:0]		r_tkeep, c_s_axis_tkeep_d1;
-		reg									r_tlast, c_s_axis_tlast_d1;
-		reg									r_tvalid, c_s_axis_tvalid_d1;
-
-		reg [C_S_AXIS_DATA_WIDTH-1:0]		r_1st_tdata, r_1st_tdata_next;
-		reg [C_S_AXIS_TUSER_WIDTH-1:0]		r_1st_tuser, r_1st_tuser_next;
-		reg [C_S_AXIS_DATA_WIDTH/8-1:0]		r_1st_tkeep, r_1st_tkeep_next;
-		reg									r_1st_tlast, r_1st_tlast_next;
-		reg									r_1st_tvalid, r_1st_tvalid_next;
-
-		reg [7:0]							c_index_cam_next, c_index_act_next;
-		reg									c_wr_en_cam_next, c_wr_en_act_next;
-		reg [204:0]							c_wr_cam_data, c_wr_cam_data_next;
-		reg [ACT_LEN-1:0]					c_wr_act_data, c_wr_act_data_next;
-
-		always @(*) begin
-			c_state_next = c_state;
-
-			r_tdata = 0;
-			r_tkeep = 0;
-			r_tuser = 0;
-			r_tlast = 0;
-			r_tvalid = 0;
-
-			r_1st_tdata_next = r_1st_tdata;
-			r_1st_tkeep_next = r_1st_tkeep;
-			r_1st_tuser_next = r_1st_tuser;
-			r_1st_tlast_next = r_1st_tlast;
-			r_1st_tvalid_next = r_1st_tvalid;
-
-			c_index_cam_next = c_index_cam;
-			c_index_act_next = c_index_act;
-			c_wr_en_cam_next = 0;
-			c_wr_en_act_next = 0;
-			c_wr_cam_data_next = c_wr_cam_data;
-			c_wr_act_data_next = c_wr_act_data;
-
-			case (c_state) 
-				IDLE_C: begin // 1st segment
-					r_tvalid = 0;
-					if (c_s_axis_tvalid) begin
-						// store 1st segment
-						r_1st_tdata_next = c_s_axis_tdata;
-						r_1st_tuser_next = c_s_axis_tuser;
-						r_1st_tkeep_next = c_s_axis_tkeep;
-						r_1st_tlast_next = c_s_axis_tlast;
-						r_1st_tvalid_next = c_s_axis_tvalid;
-
-						c_state_next = PARSE_C;
-					end
-				end
-				PARSE_C: begin // 2nd segment
-					if (mod_id[7:3] == STAGE_ID && mod_id[2:0] == LOOKUP_ID && 
-						control_flag == 16'hf2f1 && c_s_axis_tvalid && resv!=4'b0) begin
-						// should not emit segment
-						c_index_act_next = c_s_axis_tdata[128+:8];
-						c_state_next = ACT_TMP_ENTRY_WAIT;
-					end
-					else if (!c_s_axis_tvalid) begin
-					end
-					else begin
-						// emit
-						r_tdata = r_1st_tdata;
-						r_tkeep = r_1st_tkeep;
-						r_tuser = r_1st_tuser;
-						r_tlast = r_1st_tlast;
-						r_tvalid = r_1st_tvalid;
-						c_state_next = FLUSH_REST_C;
-					end
-				end
-				ACT_TMP_ENTRY_WAIT: begin
-					if (c_s_axis_tvalid) begin
-						c_wr_act_data_next[369+:256] = c_s_axis_tdata_swapped;
-						c_state_next = ACT_TMP_ENTRY_WAIT_2;
-					end
-				end
-				ACT_TMP_ENTRY_WAIT_2: begin
-					if (c_s_axis_tvalid) begin
-						c_wr_act_data_next[113+:256] = c_s_axis_tdata_swapped;
-						c_state_next = ACT_TMP_ENTRY;
-					end
-				end
-				ACT_TMP_ENTRY: begin
-					if (c_s_axis_tvalid) begin
-						c_wr_en_act_next = 1; // next clk to write
-						c_wr_act_data_next[0+:113] = c_s_axis_tdata_swapped[143+:113];
-						c_state_next = IDLE_C;
-					end
-				end
-				FLUSH_REST_C: begin
-					c_wr_en_cam_next = 0;
-					c_wr_en_act_next = 0;
-					r_tdata = c_s_axis_tdata_d1;
-					r_tkeep = c_s_axis_tkeep_d1;
-					r_tuser = c_s_axis_tuser_d1;
-					r_tlast = c_s_axis_tlast_d1;
-					r_tvalid = c_s_axis_tvalid_d1;
-					if (c_s_axis_tvalid_d1 && c_s_axis_tlast_d1) begin
-						c_state_next = IDLE_C;
-					end
-				end
-			endcase
-		end
-
-		always @(posedge clk) begin
-			if (~rst_n) begin
-				c_state <= IDLE_C;
-
-				// control output
-				c_m_axis_tdata <= 0;
-				c_m_axis_tuser <= 0;
-				c_m_axis_tkeep <= 0;
-				c_m_axis_tlast <= 0;
-				c_m_axis_tvalid <= 0;
-				//
-				c_index_cam <= 0;
-				c_index_act <= 0;
-				c_wr_en_cam <= 0;
-				c_wr_en_act <= 0;
-				c_wr_cam_data <= 0;
-				c_wr_act_data <= 0;
-			end
-			else begin
-				c_state <= c_state_next;
-
-
-				// output ctrl master signals
-				c_m_axis_tdata <= r_tdata;
-				c_m_axis_tkeep <= r_tkeep;
-				c_m_axis_tuser <= r_tuser;
-				c_m_axis_tlast <= r_tlast;
-				c_m_axis_tvalid <= r_tvalid;
-				//
-				c_index_cam <= c_index_cam_next;
-				c_index_act <= c_index_act_next;
-				c_wr_en_cam <= c_wr_en_cam_next;
-				c_wr_en_act <= c_wr_en_act_next;
-				c_wr_cam_data <= c_wr_cam_data_next;
-				c_wr_act_data <= c_wr_act_data_next;
-			end
-		end
-
-		always @(posedge clk) begin
-			if (~rst_n) begin
-				// delayed 1 clk
-				c_s_axis_tdata_d1 <= 0;
-				c_s_axis_tuser_d1 <= 0;
-				c_s_axis_tkeep_d1 <= 0;
-				c_s_axis_tlast_d1 <= 0;
-				c_s_axis_tvalid_d1 <= 0;
-				//
-				r_1st_tdata <= 0;
-				r_1st_tkeep <= 0;
-				r_1st_tuser <= 0;
-				r_1st_tlast <= 0;
-				r_1st_tvalid <= 0;
-			end
-			else begin
-				// delayed 1 clk
-				c_s_axis_tdata_d1 <= c_s_axis_tdata;
-				c_s_axis_tuser_d1 <= c_s_axis_tuser;
-				c_s_axis_tkeep_d1 <= c_s_axis_tkeep;
-				c_s_axis_tlast_d1 <= c_s_axis_tlast;
-				c_s_axis_tvalid_d1 <= c_s_axis_tvalid;
-				// 
-				r_1st_tdata <= r_1st_tdata_next;
-				r_1st_tkeep <= r_1st_tkeep_next;
-				r_1st_tuser <= r_1st_tuser_next;
-				r_1st_tlast <= r_1st_tlast_next;
-				r_1st_tvalid <= r_1st_tvalid_next;
-			end
-		end
-
-        //ram for action
-        // blk_mem_gen_1 #(
-        // 	.C_INIT_FILE_NAME	("./llup.mif"),
-        // 	.C_LOAD_INIT_FILE	(1)
-        // )
-        blk_mem_gen_1
-        act_ram_625w_16d
-        (
-            .addra(c_index_act[3:0]),
-            .clka(clk),
-            .dina(c_wr_act_data),
-            .ena(1'b1), // always set to 1
-            .wea(c_wr_en_act),
-
-            .addrb(match_addr),
-            .clkb(clk),
-            .doutb(action_wire),
-            .enb(1'b1) // always set to 1
-        );
     end
 
+    //ram for action
+    // blk_mem_gen_1 #(
+    // 	.C_INIT_FILE_NAME	("./llup.mif"),
+    // 	.C_LOAD_INIT_FILE	(1)
+    // )
+    blk_mem_gen_1
+    act_ram_625w_16d
+    (
+        .addra(c_index_act[3:0]),
+        .clka(clk),
+        .dina(act_entry_tmp),
+        .ena(1'b1),
+        .wea(c_wr_en_act),
+
+        .addrb(match_addr[3:0]),
+        .clkb(clk),
+        .doutb(action_wire),
+        .enb(1'b1)
+    );
 endgenerate
 
 endmodule
diff -ruN '--exclude=.git' '--exclude=p4c' '--exclude=tb' menshen/lookup/lookup_engine_top.v parametric_menshen/lookup/lookup_engine_top.v
--- menshen/lookup/lookup_engine_top.v
+++ parametric_menshen/lookup/lookup_engine_top.v
@@ -8,7 +8,8 @@
     parameter KEY_LEN = 48*2+32*2+16*2+5,
     parameter ACT_LEN = 625,
     parameter LOOKUP_ID = 2,
-	parameter C_VLANID_WIDTH = 12
+    parameter C_VLANID_WIDTH = 12,
+    parameter NUM_OF_STAGES = 5
 )
 (
     input clk,
@@ -88,7 +89,8 @@
     .KEY_LEN(KEY_LEN),
     .ACT_LEN(ACT_LEN),
     .LOOKUP_ID(LOOKUP_ID),
-	.C_VLANID_WIDTH(C_VLANID_WIDTH)
+    .C_VLANID_WIDTH(C_VLANID_WIDTH),
+    .NUM_OF_STAGES(NUM_OF_STAGES)
 )
 lke_cam (
 	.clk		(clk),
diff -ruN '--exclude=.git' '--exclude=p4c' '--exclude=tb' menshen/output_arbiter.v parametric_menshen/output_arbiter.v
--- menshen/output_arbiter.v
+++ parametric_menshen/output_arbiter.v
@@ -1,176 +0,0 @@
-`timescale 1ns / 1ps
-
-module output_arbiter #(
-	parameter C_AXIS_DATA_WIDTH=256,
-	parameter C_AXIS_TUSER_WIDTH=128,
-	parameter C_NUM_QUEUES=4,
-	parameter C_NUM_QUEUES_WIDTH=2
-)
-(
-	input									axis_clk,
-	input									aresetn,
-
-	// output
-	output [C_AXIS_DATA_WIDTH-1:0]			m_axis_tdata,
-	output [C_AXIS_DATA_WIDTH/8-1:0]		m_axis_tkeep,
-	output [C_AXIS_TUSER_WIDTH-1:0]			m_axis_tuser,
-	output									m_axis_tvalid,
-	output									m_axis_tlast,
-	input									m_axis_tready,
-
-	// input
-	input [C_AXIS_DATA_WIDTH-1:0]			s_axis_tdata_0,
-	input [C_AXIS_DATA_WIDTH/8-1:0]			s_axis_tkeep_0,
-	input [C_AXIS_TUSER_WIDTH-1:0]			s_axis_tuser_0,
-	input									s_axis_tlast_0,
-	input									s_axis_tvalid_0,
-	output									s_axis_tready_0,
-
-	input [C_AXIS_DATA_WIDTH-1:0]			s_axis_tdata_1,
-	input [C_AXIS_DATA_WIDTH/8-1:0]			s_axis_tkeep_1,
-	input [C_AXIS_TUSER_WIDTH-1:0]			s_axis_tuser_1,
-	input									s_axis_tlast_1,
-	input									s_axis_tvalid_1,
-	output									s_axis_tready_1,
-
-	input [C_AXIS_DATA_WIDTH-1:0]			s_axis_tdata_2,
-	input [C_AXIS_DATA_WIDTH/8-1:0]			s_axis_tkeep_2,
-	input [C_AXIS_TUSER_WIDTH-1:0]			s_axis_tuser_2,
-	input									s_axis_tlast_2,
-	input									s_axis_tvalid_2,
-	output									s_axis_tready_2,
-
-	input [C_AXIS_DATA_WIDTH-1:0]			s_axis_tdata_3,
-	input [C_AXIS_DATA_WIDTH/8-1:0]			s_axis_tkeep_3,
-	input [C_AXIS_TUSER_WIDTH-1:0]			s_axis_tuser_3,
-	input									s_axis_tlast_3,
-	input									s_axis_tvalid_3,
-	output									s_axis_tready_3
-);
-
-wire [C_NUM_QUEUES-1:0]					nearly_full;
-wire [C_NUM_QUEUES-1:0]					empty;
-wire [C_AXIS_DATA_WIDTH-1:0]			in_tdata [C_NUM_QUEUES-1:0];
-wire [C_AXIS_DATA_WIDTH/8-1:0]			in_tkeep [C_NUM_QUEUES-1:0];
-wire [C_AXIS_TUSER_WIDTH-1:0]			in_tuser [C_NUM_QUEUES-1:0];
-wire [C_NUM_QUEUES-1:0]					in_tvalid;
-wire [C_NUM_QUEUES-1:0]					in_tlast;
-
-wire [C_AXIS_DATA_WIDTH-1:0]			fifo_out_tdata [C_NUM_QUEUES-1:0];
-wire [C_AXIS_DATA_WIDTH/8-1:0]			fifo_out_tkeep [C_NUM_QUEUES-1:0];
-wire [C_AXIS_TUSER_WIDTH-1:0]			fifo_out_tuser [C_NUM_QUEUES-1:0];
-wire [C_NUM_QUEUES-1:0]					fifo_out_tlast;
-
-reg [C_NUM_QUEUES-1:0]					rd_en;
-wire [C_NUM_QUEUES_WIDTH-1:0]			cur_queue_plus1;
-reg [C_NUM_QUEUES_WIDTH-1:0]			cur_queue, cur_queue_next;
-
-reg										state, state_next;
-
-
-
-generate
-	genvar i;
-	for (i=0; i<C_NUM_QUEUES; i=i+1) begin:
-		out_arb_queues
-		fallthrough_small_fifo #(
-			.WIDTH(C_AXIS_DATA_WIDTH+C_AXIS_DATA_WIDTH/8+C_AXIS_TUSER_WIDTH+1),
-			.MAX_DEPTH_BITS(4)
-		) out_arb_fifo (
-			.dout			({fifo_out_tdata[i], fifo_out_tuser[i], fifo_out_tkeep[i], fifo_out_tlast[i]}),
-			.rd_en			(rd_en[i]),
-
-			.din			({in_tdata[i], in_tuser[i], in_tkeep[i], in_tlast[i]}),
-			.wr_en			(in_tvalid[i] & ~nearly_full[i]),
-
-			.full			(),
-			.nearly_full	(nearly_full[i]),
-			.empty			(empty[i]),
-			.reset			(~aresetn),
-			.clk			(axis_clk)
-		);
-	end
-endgenerate
-
-assign in_tdata[0] = s_axis_tdata_0;
-assign in_tkeep[0] = s_axis_tkeep_0;
-assign in_tuser[0] = s_axis_tuser_0;
-assign in_tlast[0] = s_axis_tlast_0;
-assign in_tvalid[0] = s_axis_tvalid_0;
-assign s_axis_tready_0 = ~nearly_full[0];
-
-assign in_tdata[1] = s_axis_tdata_1;
-assign in_tkeep[1] = s_axis_tkeep_1;
-assign in_tuser[1] = s_axis_tuser_1;
-assign in_tlast[1] = s_axis_tlast_1;
-assign in_tvalid[1] = s_axis_tvalid_1;
-assign s_axis_tready_1 = ~nearly_full[1];
-
-assign in_tdata[2] = s_axis_tdata_2;
-assign in_tkeep[2] = s_axis_tkeep_2;
-assign in_tuser[2] = s_axis_tuser_2;
-assign in_tlast[2] = s_axis_tlast_2;
-assign in_tvalid[2] = s_axis_tvalid_2;
-assign s_axis_tready_2 = ~nearly_full[2];
-
-assign in_tdata[3] = s_axis_tdata_3;
-assign in_tkeep[3] = s_axis_tkeep_3;
-assign in_tuser[3] = s_axis_tuser_3;
-assign in_tlast[3] = s_axis_tlast_3;
-assign in_tvalid[3] = s_axis_tvalid_3;
-assign s_axis_tready_3 = ~nearly_full[3];
-
-assign cur_queue_plus1 = (cur_queue==C_NUM_QUEUES-1)? 0 : cur_queue+1;
-
-assign m_axis_tdata = fifo_out_tdata[cur_queue];
-assign m_axis_tuser = fifo_out_tuser[cur_queue];
-assign m_axis_tkeep = fifo_out_tkeep[cur_queue];
-assign m_axis_tlast = fifo_out_tlast[cur_queue];
-assign m_axis_tvalid = ~empty[cur_queue] && m_axis_tready;
-
-localparam	IDLE=0,
-			WR_PKT=1;
-
-always @(*) begin
-
-	state_next = state;
-	cur_queue_next = cur_queue;
-	rd_en = 0;
-
-	case (state)
-		IDLE: begin
-			if (!empty[cur_queue]) begin
-				if (m_axis_tready) begin
-					state_next = WR_PKT;
-					rd_en[cur_queue] = 1;
-				end
-			end
-			else begin
-				cur_queue_next = cur_queue_plus1;
-			end
-		end
-		WR_PKT: begin
-			if (m_axis_tready & m_axis_tlast) begin
-				state_next = IDLE;
-				rd_en[cur_queue] = 1;
-				cur_queue_next = cur_queue_plus1;
-			end
-			else if (m_axis_tready && !empty[cur_queue]) begin
-				rd_en[cur_queue] = 1;
-			end
-		end
-	endcase
-end
-
-always @(posedge axis_clk) begin
-	if (~aresetn) begin
-		state <= IDLE;
-		cur_queue <= 0;
-	end
-	else begin
-		state <= state_next;
-		cur_queue <= cur_queue_next;
-	end
-end
-
-endmodule
diff -ruN '--exclude=.git' '--exclude=p4c' '--exclude=tb' menshen/parser_do_parsing_top.v parametric_menshen/parser_do_parsing_top.v
--- menshen/parser_do_parsing_top.v
+++ parametric_menshen/parser_do_parsing_top.v
@@ -30,160 +30,107 @@
 	output reg										vlan_out_valid
 );
 
-wire [C_NUM_SEGS*C_AXIS_DATA_WIDTH-1:0]			sub_parser_segs_in [0:1];
-wire											sub_parser_segs_in_valid [0:1];
-wire [C_AXIS_TUSER_WIDTH-1:0]					sub_parser_tuser_1st_in [0:1];
-wire [C_PARSER_RAM_WIDTH-1:0]					sub_parser_bram_in [0:1];
-wire											sub_parser_bram_in_valid [0:1];
-
-reg [1:0] cur_queue, cur_queue_next;
-wire [1:0] cur_queue_plus1;
-
-assign cur_queue_plus1 = (cur_queue==1)?0:cur_queue+1;
-
-
-assign sub_parser_segs_in[0] = segs_in;
-assign sub_parser_segs_in[1] = segs_in;
-// assign sub_parser_segs_in[2] = segs_in;
-// assign sub_parser_segs_in[3] = segs_in;
-assign sub_parser_segs_in_valid[0] = (cur_queue==0)?segs_in_valid:0;
-assign sub_parser_segs_in_valid[1] = (cur_queue==1)?segs_in_valid:0;
-// assign sub_parser_segs_in_valid[2] = (cur_queue==2)?segs_in_valid:0;
-// assign sub_parser_segs_in_valid[3] = (cur_queue==3)?segs_in_valid:0;
-assign sub_parser_tuser_1st_in[0] = tuser_1st_in;
-assign sub_parser_tuser_1st_in[1] = tuser_1st_in;
-// assign sub_parser_tuser_1st_in[2] = tuser_1st_in;
-// assign sub_parser_tuser_1st_in[3] = tuser_1st_in;
-
-assign sub_parser_bram_in[0] = bram_in;
-assign sub_parser_bram_in[1] = bram_in;
-// assign sub_parser_bram_in[2] = bram_in;
-// assign sub_parser_bram_in[3] = bram_in;
-assign sub_parser_bram_in_valid[0] = (cur_queue==0)?bram_in_valid:0;
-assign sub_parser_bram_in_valid[1] = (cur_queue==1)?bram_in_valid:0;
-// assign sub_parser_bram_in_valid[2] = (cur_queue==2)?bram_in_valid:0;
-// assign sub_parser_bram_in_valid[3] = (cur_queue==3)?bram_in_valid:0;
+reg [C_NUM_SEGS*C_AXIS_DATA_WIDTH-1:0]			sub_parser_segs_in;
+reg												sub_parser_segs_in_valid;
+reg [C_AXIS_TUSER_WIDTH-1:0]					sub_parser_tuser_1st_in;
+reg [C_PARSER_RAM_WIDTH-1:0]					sub_parser_bram_in;
+reg												sub_parser_bram_in_valid;
 
 
-
-always @(*) begin
-	cur_queue_next = cur_queue;
-	if (segs_in_valid) begin
-		cur_queue_next = cur_queue_plus1;
-	end
-end
-
 always @(posedge clk) begin
 	if (~aresetn) begin
-		cur_queue <= 0;
+		sub_parser_segs_in <=       0;
+		sub_parser_segs_in_valid <= 0;
+		sub_parser_tuser_1st_in <=  0;
+		
+		sub_parser_bram_in <=       0;
+		sub_parser_bram_in_valid <= 0;
 	end
 	else begin
-		cur_queue <= cur_queue_next;
+		sub_parser_segs_in <=       segs_in;
+		sub_parser_segs_in_valid <= segs_in_valid;
+		sub_parser_tuser_1st_in <=  tuser_1st_in;
+		
+		sub_parser_bram_in <=       bram_in;
+		sub_parser_bram_in_valid <= bram_in_valid;
 	end
 end
 
-wire [1:0]					nearly_full;
-wire [1:0]					empty;
-wire [1:0]					vlan_nearly_full;
-wire [1:0]					vlan_empty;
-wire [PKT_HDR_LEN-1:0]		sub_parser_pkt_hdr_out [0:1];
-wire [1:0]					sub_parser_pkt_hdr_valid;
-wire [C_VLANID_WIDTH-1:0]	sub_parser_vlan_out [0:1];
-wire [1:0]					sub_parser_vlan_out_valid;
-
-reg [PKT_HDR_LEN-1:0]		sub_parser_pkt_hdr_out_d1 [0:1];
-reg [1:0]					sub_parser_pkt_hdr_valid_d1;
-reg [C_VLANID_WIDTH-1:0]	sub_parser_vlan_out_d1 [0:1];
-reg [1:0]					sub_parser_vlan_out_valid_d1;
-
-generate
-	genvar i;
-	for (i=0; i<2; i=i+1) begin:
-		sub_do_parsing
-		parser_do_parsing #(
-			.C_AXIS_DATA_WIDTH(C_AXIS_DATA_WIDTH),
-			.C_AXIS_TUSER_WIDTH(C_AXIS_TUSER_WIDTH)
-		)
-		phv_do_parsing (
-			.axis_clk			(clk),
-			.aresetn			(aresetn),
-			.tdata_segs			(sub_parser_segs_in[i]),
-			.tuser_1st			(sub_parser_tuser_1st_in[i]),
-			.segs_valid			(sub_parser_segs_in_valid[i]),
-
-			.bram_in			(sub_parser_bram_in[i]),
-			.bram_in_valid		(sub_parser_bram_in_valid[i]),
-			.stg_ready_in		(1'b1),
-			// output
-			.parser_valid		(sub_parser_pkt_hdr_valid[i]),
-			.pkt_hdr_vec		(sub_parser_pkt_hdr_out[i]),
-			.vlan_out			(sub_parser_vlan_out[i]),
-			.vlan_out_valid		(sub_parser_vlan_out_valid[i])
-		);
-	end
-endgenerate
+wire [PKT_HDR_LEN-1:0]		sub_parser_pkt_hdr_out;
+wire					sub_parser_pkt_hdr_valid;
+wire [C_VLANID_WIDTH-1:0]	sub_parser_vlan_out;
+wire					sub_parser_vlan_out_valid;
+
+reg [PKT_HDR_LEN-1:0]		sub_parser_pkt_hdr_out_d1;
+reg					sub_parser_pkt_hdr_valid_d1;
+reg [C_VLANID_WIDTH-1:0]	sub_parser_vlan_out_d1;
+reg					sub_parser_vlan_out_valid_d1;
+
+parser_do_parsing #(
+	.C_AXIS_DATA_WIDTH(C_AXIS_DATA_WIDTH),
+	.C_AXIS_TUSER_WIDTH(C_AXIS_TUSER_WIDTH)
+)
+phv_do_parsing (
+	.axis_clk			(clk),
+	.aresetn			(aresetn),
+	.tdata_segs			(sub_parser_segs_in),
+	.tuser_1st			(sub_parser_tuser_1st_in),
+	.segs_valid			(sub_parser_segs_in_valid),
+
+	.bram_in			(sub_parser_bram_in),
+	.bram_in_valid		(sub_parser_bram_in_valid),
+	.stg_ready_in		(1'b1),
+	// output
+	.parser_valid		(sub_parser_pkt_hdr_valid),
+	.pkt_hdr_vec		(sub_parser_pkt_hdr_out),
+	.vlan_out			(sub_parser_vlan_out),
+	.vlan_out_valid		(sub_parser_vlan_out_valid)
+);
+
 
-reg [1:0] out_cur_queue, out_cur_queue_next;
-wire [1:0] out_cur_queue_plus1;
 reg [PKT_HDR_LEN-1:0] pkt_hdr_vec_next;
 reg parser_valid_next;
 
-assign out_cur_queue_plus1 = (out_cur_queue==1)?0:out_cur_queue+1;
-
 always @(*) begin
 	pkt_hdr_vec_next = pkt_hdr_vec;
 	parser_valid_next = 0;
 	
-	out_cur_queue_next = out_cur_queue;
-
-	if (sub_parser_pkt_hdr_valid_d1[out_cur_queue]) begin
-		pkt_hdr_vec_next = sub_parser_pkt_hdr_out_d1[out_cur_queue];
+	if (sub_parser_pkt_hdr_valid_d1) begin
+		pkt_hdr_vec_next = sub_parser_pkt_hdr_out_d1;
 		parser_valid_next = 1;
-		out_cur_queue_next = out_cur_queue_plus1;
 	end
 end
 
 always @(posedge clk) begin
 	if (~aresetn) begin
-		out_cur_queue <= 0;
 		pkt_hdr_vec <= 0;
 		parser_valid <= 0;
 	end
 	else begin
-		out_cur_queue <= out_cur_queue_next;
 		pkt_hdr_vec <= pkt_hdr_vec_next;
 		parser_valid <= parser_valid_next;
 	end
 end
 
-reg [1:0] vlan_out_cur_queue, vlan_out_cur_queue_next;
-wire [1:0] vlan_out_cur_queue_plus1;
 reg [C_VLANID_WIDTH-1:0] vlan_out_next;
 reg vlan_out_valid_next;
 
-assign vlan_out_cur_queue_plus1 = (vlan_out_cur_queue==1)?0:vlan_out_cur_queue+1;
-
 always @(*) begin
 	vlan_out_next = vlan_out;
 	vlan_out_valid_next = 0;
-
-	vlan_out_cur_queue_next = vlan_out_cur_queue;
-
-	if (sub_parser_vlan_out_valid_d1[vlan_out_cur_queue]) begin
-		vlan_out_next = sub_parser_vlan_out_d1[vlan_out_cur_queue];
+        
+	if (sub_parser_vlan_out_valid_d1) begin
+		vlan_out_next = sub_parser_vlan_out_d1;
 		vlan_out_valid_next = 1;
-		vlan_out_cur_queue_next = vlan_out_cur_queue_plus1;
 	end
 end
 
 always @(posedge clk) begin
 	if (~aresetn) begin
-		vlan_out_cur_queue <= 0;
 		vlan_out <= 0;
 		vlan_out_valid <= 0;
 	end
 	else begin
-		vlan_out_cur_queue <= vlan_out_cur_queue_next;
 		vlan_out <= vlan_out_next;
 		vlan_out_valid <= vlan_out_valid_next;
 	end
@@ -191,122 +138,17 @@
 
 always @(posedge clk) begin
 	if (~aresetn) begin
-		sub_parser_pkt_hdr_out_d1[0] <= 0;
-		sub_parser_pkt_hdr_out_d1[1] <= 0;
+		sub_parser_pkt_hdr_out_d1 <= 0;
 		sub_parser_pkt_hdr_valid_d1 <= 0;
-		sub_parser_vlan_out_d1[0] <= 0;
-		sub_parser_vlan_out_d1[1] <= 0;
+		sub_parser_vlan_out_d1 <= 0;
 		sub_parser_vlan_out_valid_d1 <= 0;
 	end
 	else begin
-		sub_parser_pkt_hdr_out_d1[0] <= sub_parser_pkt_hdr_out[0];
-		sub_parser_pkt_hdr_out_d1[1] <= sub_parser_pkt_hdr_out[1];
+		sub_parser_pkt_hdr_out_d1 <= sub_parser_pkt_hdr_out;
 		sub_parser_pkt_hdr_valid_d1 <= sub_parser_pkt_hdr_valid;
-		sub_parser_vlan_out_d1[0] <= sub_parser_vlan_out[0];
-		sub_parser_vlan_out_d1[1] <= sub_parser_vlan_out[1];
+		sub_parser_vlan_out_d1 <= sub_parser_vlan_out;
 		sub_parser_vlan_out_valid_d1 <= sub_parser_vlan_out_valid;
 	end
 end
 
-
-/*
-generate
-	for (i=0; i<2; i=i+1) begin:
-		out_arb_queues
-		fallthrough_small_fifo #(
-			.WIDTH(PKT_HDR_LEN),
-			.MAX_DEPTH_BITS(4)
-		) out_arb_fifo (
-			.dout			(fifo_pkt_hdr_out[i]),
-			.rd_en			(fifo_rd_en[i]),
-
-			.din			(sub_parser_pkt_hdr_out[i]),
-			.wr_en			(sub_parser_pkt_hdr_valid[i] & ~nearly_full[i]),
-
-			.full			(),
-			.nearly_full	(nearly_full[i]),
-			.empty			(empty[i]),
-			.reset			(~aresetn),
-			.clk			(clk)
-		);
-	end
-	// vlan queue
-	for (i=0; i<2; i=i+1) begin:
-		vlan_out_arb_queues
-		fallthrough_small_fifo #(
-			.WIDTH(C_VLANID_WIDTH),
-			.MAX_DEPTH_BITS(4)
-		) vlan_out_arb_fifo (
-			.dout			(fifo_vlan_out[i]),
-			.rd_en			(fifo_vlan_rd_en[i]),
-
-			.din			(sub_parser_vlan_out[i]),
-			.wr_en			(sub_parser_vlan_out_valid[i] & ~vlan_nearly_full[i]),
-
-			.full			(),
-			.nearly_full	(vlan_nearly_full[i]),
-			.empty			(vlan_empty[i]),
-			.reset			(~aresetn),
-			.clk			(clk)
-		);
-	end
-endgenerate
-
-
-localparam	IDLE=0;
-
-reg [1:0] out_cur_queue, out_cur_queue_next;
-wire [1:0] out_cur_queue_plus1;
-reg [1:0] vlan_out_cur_queue, vlan_out_cur_queue_next;
-wire [1:0] vlan_out_cur_queue_plus1;
-
-assign out_cur_queue_plus1 = (out_cur_queue==1)?0:out_cur_queue+1;
-assign vlan_out_cur_queue_plus1 = (vlan_out_cur_queue==1)?0:vlan_out_cur_queue+1;
-
-assign pkt_hdr_vec = fifo_pkt_hdr_out[out_cur_queue];
-assign parser_valid = ~empty[out_cur_queue];
-assign parser_ready = ~nearly_full[0] ||
-						~nearly_full[1];
-						// ~nearly_full[2] ||
-						// ~nearly_full[3];
-assign vlan_out = fifo_vlan_out[vlan_out_cur_queue];
-assign vlan_out_valid = ~vlan_empty[vlan_out_cur_queue];
-
-always @(*) begin
-
-	out_cur_queue_next = out_cur_queue;
-	fifo_rd_en = 0;
-
-	if (!empty[out_cur_queue]) begin
-		if (stg_ready) begin
-			fifo_rd_en[out_cur_queue] = 1;
-			out_cur_queue_next = out_cur_queue_plus1;
-		end
-	end
-end
-
-always @(*) begin
-
-	vlan_out_cur_queue_next = vlan_out_cur_queue;
-	fifo_vlan_rd_en = 0;
-
-	if (!vlan_empty[vlan_out_cur_queue]) begin
-		if (stg_vlan_ready) begin
-			fifo_vlan_rd_en[out_cur_queue] = 1;
-			vlan_out_cur_queue_next = vlan_out_cur_queue_plus1;
-		end
-	end
-end
-
-always @(posedge clk) begin
-	if (~aresetn) begin
-		out_cur_queue <= 0;
-		vlan_out_cur_queue <= 0;
-	end
-	else begin
-		out_cur_queue <= out_cur_queue_next;
-		vlan_out_cur_queue <= vlan_out_cur_queue_next;
-	end
-end*/
-
 endmodule
diff -ruN '--exclude=.git' '--exclude=p4c' '--exclude=tb' menshen/parser_do_parsing.v parametric_menshen/parser_do_parsing.v
--- menshen/parser_do_parsing.v
+++ parametric_menshen/parser_do_parsing.v
@@ -11,12 +11,6 @@
 `define PROT_TCP		8'h06
 `define PROT_UDP		8'h11
 
-`define SUB_PARSE(idx) \
-	case(sub_parse_val_out_type_d1[idx]) \
-		2'b01: val_2B_nxt[sub_parse_val_out_seq_d1[idx]] = sub_parse_val_out_d1[idx][15:0]; \
-		2'b10: val_4B_nxt[sub_parse_val_out_seq_d1[idx]] = sub_parse_val_out_d1[idx][31:0]; \
-		2'b11: val_6B_nxt[sub_parse_val_out_seq_d1[idx]] = sub_parse_val_out_d1[idx][47:0]; \
-	endcase \
 
 `define SWAP_BYTE_ORDER(idx) \
 	assign val_6B_swapped[idx] = {	val_6B[idx][0+:8], \
@@ -62,7 +56,7 @@
 	output reg										vlan_out_valid
 );
 
-integer i;
+integer i, j;
 
 localparam			IDLE=0,
 					WAIT_1CYCLE_RAM=1,
@@ -73,6 +67,32 @@
 					EMPTY_1=6;
 					
 
+reg [C_NUM_SEGS*C_AXIS_DATA_WIDTH-1:0]		tdata_segs_r;
+reg [C_AXIS_TUSER_WIDTH-1:0]				tuser_1st_r;
+reg [C_PARSER_RAM_WIDTH-1:0]				bram_in_r;
+reg											bram_in_valid_r;
+reg [9:0]                                   sub_parse_act_valid;
+
+always @(posedge axis_clk) begin
+	if (~aresetn) begin
+		tdata_segs_r <= 0;
+		tuser_1st_r <= 0;
+		bram_in_r <= 0;
+		bram_in_valid_r <= 0;
+		
+		sub_parse_act_valid <= 0;
+	end
+	else begin
+		tdata_segs_r <=    tdata_segs;
+		tuser_1st_r <=     tuser_1st;
+		bram_in_r <=       bram_in;
+		bram_in_valid_r <= bram_in_valid;
+		
+		sub_parse_act_valid <= {10{segs_valid}};
+	end
+end
+
+
 //
 reg [PKT_HDR_LEN-1:0]	pkt_hdr_vec_next;
 reg parser_valid_next;
@@ -83,19 +103,18 @@
 // parsing actions
 wire [15:0] parse_action [0:9];		// we have 10 parse action
 
-assign parse_action[9] = bram_in[0+:16];
-assign parse_action[8] = bram_in[16+:16];
-assign parse_action[7] = bram_in[32+:16];
-assign parse_action[6] = bram_in[48+:16];
-assign parse_action[5] = bram_in[64+:16];
-assign parse_action[4] = bram_in[80+:16];
-assign parse_action[3] = bram_in[96+:16];
-assign parse_action[2] = bram_in[112+:16];
-assign parse_action[1] = bram_in[128+:16];
-assign parse_action[0] = bram_in[144+:16];
+assign parse_action[9] = bram_in_r[0+:16];
+assign parse_action[8] = bram_in_r[16+:16];
+assign parse_action[7] = bram_in_r[32+:16];
+assign parse_action[6] = bram_in_r[48+:16];
+assign parse_action[5] = bram_in_r[64+:16];
+assign parse_action[4] = bram_in_r[80+:16];
+assign parse_action[3] = bram_in_r[96+:16];
+assign parse_action[2] = bram_in_r[112+:16];
+assign parse_action[1] = bram_in_r[128+:16];
+assign parse_action[0] = bram_in_r[144+:16];
 
 
-reg [9:0] sub_parse_act_valid;
 wire [47:0] sub_parse_val_out [0:9];
 wire [9:0] sub_parse_val_out_valid;
 wire [1:0] sub_parse_val_out_type [0:9];
@@ -109,9 +128,6 @@
 reg [47:0] val_6B [0:7];
 reg [31:0] val_4B [0:7];
 reg [15:0] val_2B [0:7];
-reg [47:0] val_6B_nxt [0:7];
-reg [31:0] val_4B_nxt [0:7];
-reg [15:0] val_2B_nxt [0:7];
 
 wire [47:0] val_6B_swapped [0:7];
 wire [31:0] val_4B_swapped [0:7];
@@ -126,77 +142,55 @@
 `SWAP_BYTE_ORDER(6)
 `SWAP_BYTE_ORDER(7)
 
+always @(posedge axis_clk) begin
+    if (~aresetn || state!=IDLE) begin
+		for (j=0; j<8; j=j+1) begin
+			val_2B[j] <= 0;
+			val_4B[j] <= 0;
+			val_6B[j] <= 0;
+		end
+    end
+    else begin
+        for (j=0; j<10; j=j+1) begin
+            case(sub_parse_val_out_type_d1[j])
+                2'b01: val_2B[sub_parse_val_out_seq_d1[j]] <= sub_parse_val_out_d1[j][15:0];
+                2'b10: val_4B[sub_parse_val_out_seq_d1[j]] <= sub_parse_val_out_d1[j][31:0];
+                2'b11: val_6B[sub_parse_val_out_seq_d1[j]] <= sub_parse_val_out_d1[j][47:0];
+            endcase
+        end
+    end
+end
+
+always @(posedge axis_clk) begin
+	if (~aresetn) begin
+		vlan_out_next <= 0;
+	end
+	else begin
+		if (segs_valid)
+			vlan_out_next <= tdata_segs[288+:12];
+	end
+end
+
 always @(*) begin
 	state_next = state;
 	//
 	parser_valid_next = 0;
 	pkt_hdr_vec_next = pkt_hdr_vec;
 	//
-	val_2B_nxt[0]=val_2B[0];
-	val_2B_nxt[1]=val_2B[1];
-	val_2B_nxt[2]=val_2B[2];
-	val_2B_nxt[3]=val_2B[3];
-	val_2B_nxt[4]=val_2B[4];
-	val_2B_nxt[5]=val_2B[5];
-	val_2B_nxt[6]=val_2B[6];
-	val_2B_nxt[7]=val_2B[7];
-	val_4B_nxt[0]=val_4B[0];
-	val_4B_nxt[1]=val_4B[1];
-	val_4B_nxt[2]=val_4B[2];
-	val_4B_nxt[3]=val_4B[3];
-	val_4B_nxt[4]=val_4B[4];
-	val_4B_nxt[5]=val_4B[5];
-	val_4B_nxt[6]=val_4B[6];
-	val_4B_nxt[7]=val_4B[7];
-	val_6B_nxt[0]=val_6B[0];
-	val_6B_nxt[1]=val_6B[1];
-	val_6B_nxt[2]=val_6B[2];
-	val_6B_nxt[3]=val_6B[3];
-	val_6B_nxt[4]=val_6B[4];
-	val_6B_nxt[5]=val_6B[5];
-	val_6B_nxt[6]=val_6B[6];
-	val_6B_nxt[7]=val_6B[7];
-	//
-	sub_parse_act_valid = 10'b0;
-	//
-	vlan_out_next = vlan_out;
 	vlan_out_valid_next = 0;
 
 	case (state)
 		IDLE: begin
-			if (segs_valid) begin
-				sub_parse_act_valid = 10'b1111111111;
-				vlan_out_next = tdata_segs[116+:12];
-				state_next = FINISH_SUB_PARSE;
+			if(&sub_parse_val_out_valid_d1) begin
+				vlan_out_valid_next = 1;
+			    state_next = GET_PHV_OUTPUT;
 			end
 		end
-		FINISH_SUB_PARSE: begin
-			state_next = EMPTY_1;
-		end
-		EMPTY_1: begin
-			state_next = GET_PHV_OUTPUT;
-			`SUB_PARSE(0)
-			`SUB_PARSE(1)
-			`SUB_PARSE(2)
-			`SUB_PARSE(3)
-			`SUB_PARSE(4)
-			`SUB_PARSE(5)
-			`SUB_PARSE(6)
-			`SUB_PARSE(7)
-			`SUB_PARSE(8)
-			`SUB_PARSE(9)
-			vlan_out_valid_next = 1;
-		end
 		GET_PHV_OUTPUT: begin
 			pkt_hdr_vec_next ={val_6B_swapped[7], val_6B_swapped[6], val_6B_swapped[5], val_6B_swapped[4], val_6B_swapped[3], val_6B_swapped[2], val_6B_swapped[1], val_6B_swapped[0],
 							val_4B_swapped[7], val_4B_swapped[6], val_4B_swapped[5], val_4B_swapped[4], val_4B_swapped[3], val_4B_swapped[2], val_4B_swapped[1], val_4B_swapped[0],
 							val_2B_swapped[7], val_2B_swapped[6], val_2B_swapped[5], val_2B_swapped[4], val_2B_swapped[3], val_2B_swapped[2], val_2B_swapped[1], val_2B_swapped[0],
-							// Tao: manually set output port to 1 for eazy test
-							// {115{1'b0}}, vlan_id, 1'b0, tuser_1st[127:32], 8'h04, tuser_1st[23:0]};
-							{115{1'b0}}, vlan_out, 1'b0, tuser_1st[127:32], 8'h04, tuser_1st[23:0]};
-							// {115{1'b0}}, vlan_id, 1'b0, tuser_1st};
-							// {128{1'b0}}, tuser_1st[127:32], 8'h04, tuser_1st[23:0]};
-							//
+							{115{1'b0}}, vlan_out, 1'b0, (C_AXIS_TUSER_WIDTH == 128 ? tuser_1st_r : ({{128-C_AXIS_TUSER_WIDTH{1'b0}}, tuser_1st_r})) };
 			if (stg_ready_in) begin
 				parser_valid_next = 1;
 				state_next = IDLE;
@@ -209,32 +203,6 @@
 			if (stg_ready_in) begin
 				parser_valid_next = 1;
 				state_next = IDLE;
-				
-				// zero out
-				val_2B_nxt[0]=0;
-				val_2B_nxt[1]=0;
-				val_2B_nxt[2]=0;
-				val_2B_nxt[3]=0;
-				val_2B_nxt[4]=0;
-				val_2B_nxt[5]=0;
-				val_2B_nxt[6]=0;
-				val_2B_nxt[7]=0;
-				val_4B_nxt[0]=0;
-				val_4B_nxt[1]=0;
-				val_4B_nxt[2]=0;
-				val_4B_nxt[3]=0;
-				val_4B_nxt[4]=0;
-				val_4B_nxt[5]=0;
-				val_4B_nxt[6]=0;
-				val_4B_nxt[7]=0;
-				val_6B_nxt[0]=0;
-				val_6B_nxt[1]=0;
-				val_6B_nxt[2]=0;
-				val_6B_nxt[3]=0;
-				val_6B_nxt[4]=0;
-				val_6B_nxt[5]=0;
-				val_6B_nxt[6]=0;
-				val_6B_nxt[7]=0;
 			end
 		end
 	endcase
@@ -251,31 +219,6 @@
 		//
 		vlan_out <= 0;
 		vlan_out_valid <= 0;
-		//
-		val_2B[0] <= 0;
-		val_2B[1] <= 0;
-		val_2B[2] <= 0;
-		val_2B[3] <= 0;
-		val_2B[4] <= 0;
-		val_2B[5] <= 0;
-		val_2B[6] <= 0;
-		val_2B[7] <= 0;
-		val_4B[0] <= 0;
-		val_4B[1] <= 0;
-		val_4B[2] <= 0;
-		val_4B[3] <= 0;
-		val_4B[4] <= 0;
-		val_4B[5] <= 0;
-		val_4B[6] <= 0;
-		val_4B[7] <= 0;
-		val_6B[0] <= 0;
-		val_6B[1] <= 0;
-		val_6B[2] <= 0;
-		val_6B[3] <= 0;
-		val_6B[4] <= 0;
-		val_6B[5] <= 0;
-		val_6B[6] <= 0;
-		val_6B[7] <= 0;
 
 		for (i=0; i<10; i=i+1) begin
 			sub_parse_val_out_d1[i] <= 0;
@@ -293,31 +236,6 @@
 		vlan_out <= vlan_out_next;
 		vlan_out_valid <= vlan_out_valid_next;
 		//
-		val_2B[0] <= val_2B_nxt[0];
-		val_2B[1] <= val_2B_nxt[1];
-		val_2B[2] <= val_2B_nxt[2];
-		val_2B[3] <= val_2B_nxt[3];
-		val_2B[4] <= val_2B_nxt[4];
-		val_2B[5] <= val_2B_nxt[5];
-		val_2B[6] <= val_2B_nxt[6];
-		val_2B[7] <= val_2B_nxt[7];
-		val_4B[0] <= val_4B_nxt[0];
-		val_4B[1] <= val_4B_nxt[1];
-		val_4B[2] <= val_4B_nxt[2];
-		val_4B[3] <= val_4B_nxt[3];
-		val_4B[4] <= val_4B_nxt[4];
-		val_4B[5] <= val_4B_nxt[5];
-		val_4B[6] <= val_4B_nxt[6];
-		val_4B[7] <= val_4B_nxt[7];
-		val_6B[0] <= val_6B_nxt[0];
-		val_6B[1] <= val_6B_nxt[1];
-		val_6B[2] <= val_6B_nxt[2];
-		val_6B[3] <= val_6B_nxt[3];
-		val_6B[4] <= val_6B_nxt[4];
-		val_6B[5] <= val_6B_nxt[5];
-		val_6B[6] <= val_6B_nxt[6];
-		val_6B[7] <= val_6B_nxt[7];
-		//
 		for (i=0; i<10; i=i+1) begin
 			sub_parse_val_out_d1[i] <= sub_parse_val_out[i];
 			sub_parse_val_out_valid_d1 <= sub_parse_val_out_valid;
@@ -345,7 +263,7 @@
 			.parse_act_valid	(sub_parse_act_valid[index]),
 			.parse_act			(parse_action[index]),
 
-			.pkts_hdr			(tdata_segs),
+			.pkts_hdr			(tdata_segs_r),
 			.val_out_valid		(sub_parse_val_out_valid[index]),
 			.val_out			(sub_parse_val_out[index]),
 			.val_out_type		(sub_parse_val_out_type[index]),
diff -ruN '--exclude=.git' '--exclude=p4c' '--exclude=tb' menshen/parser_top.v parametric_menshen/parser_top.v
--- menshen/parser_top.v
+++ parametric_menshen/parser_top.v
@@ -37,7 +37,6 @@
 	output reg									out_vlan_valid,
 	input									out_vlan_ready,
 
-	// output to different pkt fifo queues (i.e., data cache)
 	output [C_S_AXIS_DATA_WIDTH-1:0]		m_axis_tdata_0,
 	output [C_S_AXIS_TUSER_WIDTH-1:0]		m_axis_tuser_0,
 	output [C_S_AXIS_DATA_WIDTH/8-1:0]		m_axis_tkeep_0,
@@ -45,27 +44,6 @@
 	output									m_axis_tvalid_0,
 	input									m_axis_tready_0,
 
-	output [C_S_AXIS_DATA_WIDTH-1:0]		m_axis_tdata_1,
-	output [C_S_AXIS_TUSER_WIDTH-1:0]		m_axis_tuser_1,
-	output [C_S_AXIS_DATA_WIDTH/8-1:0]		m_axis_tkeep_1,
-	output									m_axis_tlast_1,
-	output									m_axis_tvalid_1,
-	input									m_axis_tready_1,
-
-	output [C_S_AXIS_DATA_WIDTH-1:0]		m_axis_tdata_2,
-	output [C_S_AXIS_TUSER_WIDTH-1:0]		m_axis_tuser_2,
-	output [C_S_AXIS_DATA_WIDTH/8-1:0]		m_axis_tkeep_2,
-	output									m_axis_tlast_2,
-	output									m_axis_tvalid_2,
-	input									m_axis_tready_2,
-
-	output [C_S_AXIS_DATA_WIDTH-1:0]		m_axis_tdata_3,
-	output [C_S_AXIS_TUSER_WIDTH-1:0]		m_axis_tuser_3,
-	output [C_S_AXIS_DATA_WIDTH/8-1:0]		m_axis_tkeep_3,
-	output									m_axis_tlast_3,
-	output									m_axis_tvalid_3,
-	input									m_axis_tready_3,
-
 	// ctrl path
 	input [C_S_AXIS_DATA_WIDTH-1:0]			ctrl_s_axis_tdata,
 	input [C_S_AXIS_TUSER_WIDTH-1:0]		ctrl_s_axis_tuser,
@@ -96,106 +74,25 @@
 reg bram_ready, bram_ready_next;
 
 
-assign s_axis_tready = bram_ready
-						&& m_axis_tready_0
-						&& m_axis_tready_1
-						&& m_axis_tready_2
-						&& m_axis_tready_3;
-//
-
-wire [3:0] m_axis_tready_queue;
-
-assign m_axis_tready_queue[0] = m_axis_tready_0;
-assign m_axis_tready_queue[1] = m_axis_tready_1;
-assign m_axis_tready_queue[2] = m_axis_tready_2;
-assign m_axis_tready_queue[3] = m_axis_tready_3;
-
-
-localparam	IDLE=0,
-			FLUSH_REST_PKTS=1;
-reg [1:0] state, state_next;
-reg [1:0] cur_queue, cur_queue_next;
-wire [1:0] cur_queue_plus1;
+assign s_axis_tready = bram_ready && m_axis_tready_0;
 
-assign cur_queue_plus1 = (cur_queue==3)?0:cur_queue+1;
-
-// ==================================================
 assign m_axis_tdata_0 = s_axis_tdata;
 assign m_axis_tuser_0 = s_axis_tuser;
 assign m_axis_tkeep_0 = s_axis_tkeep;
 assign m_axis_tlast_0 = s_axis_tlast;
-assign m_axis_tvalid_0 = (cur_queue==0?1:0) & s_axis_tvalid;
-
-assign m_axis_tdata_1 = s_axis_tdata;
-assign m_axis_tuser_1 = s_axis_tuser;
-assign m_axis_tkeep_1 = s_axis_tkeep;
-assign m_axis_tlast_1 = s_axis_tlast;
-assign m_axis_tvalid_1 = (cur_queue==1?1:0) & s_axis_tvalid;
-
-assign m_axis_tdata_2 = s_axis_tdata;
-assign m_axis_tuser_2 = s_axis_tuser;
-assign m_axis_tkeep_2 = s_axis_tkeep;
-assign m_axis_tlast_2 = s_axis_tlast;
-assign m_axis_tvalid_2 = (cur_queue==2?1:0) & s_axis_tvalid;
-
-assign m_axis_tdata_3 = s_axis_tdata;
-assign m_axis_tuser_3 = s_axis_tuser;
-assign m_axis_tkeep_3 = s_axis_tkeep;
-assign m_axis_tlast_3 = s_axis_tlast;
-assign m_axis_tvalid_3 = (cur_queue==3?1:0) & s_axis_tvalid;
-// ==================================================
-
+assign m_axis_tvalid_0 = s_axis_tvalid;
 
-always @(*) begin
-	state_next = state;
-	cur_queue_next = cur_queue;
-
-	case (state)
-		IDLE: begin
-			if (s_axis_tvalid) begin
-				if (m_axis_tready_queue[cur_queue]) begin
-
-					if (!s_axis_tlast) begin
-						state_next = FLUSH_REST_PKTS;
-					end
-					else begin
-						cur_queue_next = cur_queue_plus1;
-					end
-				end
-			end
-		end
-		FLUSH_REST_PKTS: begin
-			if (s_axis_tvalid) begin
-				if (m_axis_tready_queue[cur_queue]) begin
-
-					if (s_axis_tlast) begin
-						cur_queue_next = cur_queue_plus1;
-						state_next = IDLE;
-					end
-				end
-			end
-		end
-	endcase
-end
-
-always @(posedge axis_clk) begin
-	if (~aresetn) begin
-		state <= IDLE;
-		cur_queue <= 0;
-	end
-	else begin
-		state <= state_next;
-		cur_queue <= cur_queue_next;
-	end
-end
 
 // ==================================================
 
-wire [C_VLANID_WIDTH-1:0]				parser_out_vlan, vlan_fifo_out;
+wire [C_VLANID_WIDTH-1:0]				parser_out_vlan;
 wire									parser_out_vlan_valid;
+reg  [C_VLANID_WIDTH-1:0]				parser_out_vlan_r;
+reg										parser_out_vlan_valid_r;
+
 // wire	vlan_fifo_empty, vlan_fifo_nearly_full;
 reg [C_VLANID_WIDTH-1:0] out_vlan_next;
-reg out_vlan_valid_next;
+reg                      out_vlan_valid_next;
 // reg		vlan_fifo_rd_en;
 
 // wire [PKT_HDR_LEN-1:0]		phv_fifo_out;
@@ -204,54 +101,21 @@
 
 
 
-localparam P_IDLE=0;
-
-reg [1:0] p_state, p_state_next;
-reg [1:0] p_cur_queue, p_cur_queue_next;
-wire [1:0] p_cur_queue_plus1;
-
-assign p_cur_queue_plus1 = (p_cur_queue==3)?0:p_cur_queue+1;
 
-wire [3:0] p_cur_queue_val;
-assign p_cur_queue_val[0] = (p_cur_queue==0)?1:0;
-assign p_cur_queue_val[1] = (p_cur_queue==1)?1:0;
-assign p_cur_queue_val[2] = (p_cur_queue==2)?1:0;
-assign p_cur_queue_val[3] = (p_cur_queue==3)?1:0;
-
-wire parser_valid_w;
+wire                   parser_valid_w;
 wire [PKT_HDR_LEN-1:0] pkt_hdr_vec_w;
-reg [PKT_HDR_LEN-1:0] pkt_hdr_vec_next, pkt_hdr_vec_r;
-reg parser_valid_next, parser_valid_r;
+reg                    parser_valid_w_r;
+reg  [PKT_HDR_LEN-1:0] pkt_hdr_vec_w_r;
+reg  [PKT_HDR_LEN-1:0] pkt_hdr_vec_next, pkt_hdr_vec_r;
+reg                    parser_valid_next, parser_valid_r;
 
-/*
 always @(*) begin
-	p_state_next = p_state;
-	p_cur_queue_next = p_cur_queue;
-	
-	pkt_hdr_vec_next = pkt_hdr_vec;
-	parser_valid_next = 0;
-	case (p_state)
-		P_IDLE: begin
-			if (parser_valid_w) begin
-				pkt_hdr_vec_next = {pkt_hdr_vec_w[PKT_HDR_LEN-1:145], p_cur_queue_val, pkt_hdr_vec_w[0+:141]};
-				parser_valid_next = 1;
-
-				p_cur_queue_next = p_cur_queue_plus1;
-			end
-		end
-	endcase
-end*/
-
-always @(*) begin
-	p_cur_queue_next = p_cur_queue;
-	pkt_hdr_vec_next = pkt_hdr_vec_r;
+	pkt_hdr_vec_next = pkt_hdr_vec_w_r;
 	parser_valid_next = 0;
 
-	if (parser_valid_w) begin
-		pkt_hdr_vec_next = {pkt_hdr_vec_w[PKT_HDR_LEN-1:145], p_cur_queue_val, pkt_hdr_vec_w[0+:141]};
+	if (parser_valid_w_r) begin
+		pkt_hdr_vec_next = {pkt_hdr_vec_w_r[PKT_HDR_LEN-1:145], 4'b0001, pkt_hdr_vec_w_r[0+:141]};
 		parser_valid_next = 1;
-
-		p_cur_queue_next = p_cur_queue_plus1;
 	end
 end
 
@@ -259,16 +123,14 @@
 	out_vlan_valid_next = 0;
 	out_vlan_next = out_vlan;
 
-	if (parser_out_vlan_valid) begin
+	if (parser_out_vlan_valid_r) begin
 		out_vlan_valid_next = 1;
-		out_vlan_next = parser_out_vlan;
+		out_vlan_next = parser_out_vlan_r;
 	end
 end
 
 always @(posedge axis_clk) begin
 	if (~aresetn) begin
-		p_state <= P_IDLE;
-		p_cur_queue <= 0;
 		pkt_hdr_vec <= 0;
 		parser_valid <= 0;
 
@@ -277,10 +139,13 @@
 
 		pkt_hdr_vec_r <= 0;
 		parser_valid_r <= 0;
+		
+		parser_out_vlan_r <= 0;
+		parser_out_vlan_valid_r <= 0;
+		parser_valid_r <= 0;
+		pkt_hdr_vec_w_r <= 0;
 	end
 	else begin
-		p_state <= p_state_next;
-		p_cur_queue <= p_cur_queue_next;
 		pkt_hdr_vec_r <= pkt_hdr_vec_next;
 		parser_valid_r <= parser_valid_next;
 		pkt_hdr_vec <= pkt_hdr_vec_r;
@@ -288,6 +153,11 @@
 
 		out_vlan <= out_vlan_next;
 		out_vlan_valid <= out_vlan_valid_next;
+		
+		parser_out_vlan_r <= parser_out_vlan;
+		parser_out_vlan_valid_r <= parser_out_vlan_valid;
+		parser_valid_w_r <= parser_valid_w;
+		pkt_hdr_vec_w_r <= pkt_hdr_vec_w;
 	end
 end
 
@@ -307,6 +177,7 @@
 
 //
 parser_wait_segs #(
+    .C_AXIS_TUSER_WIDTH(C_S_AXIS_TUSER_WIDTH)
 )
 get_segs
 (
@@ -326,6 +197,7 @@
 );
 
 parser_do_parsing_top #(
+    .C_AXIS_TUSER_WIDTH(C_S_AXIS_TUSER_WIDTH)
 )
 do_parsing
 (
@@ -449,7 +321,7 @@
            SU_WRITE_C = 3;
 
 assign mod_id = ctrl_s_axis_tdata[368+:8];
-assign control_flag = ctrl_s_axis_tdata[335:320];
+assign control_flag = ctrl_s_axis_tdata[303:288];
 
 //LE to BE switching
 wire[C_S_AXIS_DATA_WIDTH-1:0] ctrl_s_axis_tdata_swapped;
diff -ruN '--exclude=.git' '--exclude=p4c' '--exclude=tb' menshen/parser_wait_segs.v parametric_menshen/parser_wait_segs.v
--- menshen/parser_wait_segs.v
+++ parametric_menshen/parser_wait_segs.v
@@ -30,24 +30,48 @@
 			WAIT_TILL_LAST=4;
 
 reg [2:0]	state, state_next;
-reg [C_NUM_SEGS*C_AXIS_DATA_WIDTH-1:0] tdata_segs_next;
-reg [C_AXIS_TUSER_WIDTH-1:0] tuser_1st_next;
 reg	segs_valid_next;
 
+reg en_shift, en_shift_next;
+
+always @(posedge axis_clk) begin
+	if (~aresetn) begin
+		state <= WAIT_1ST_SEG;
+		
+		tdata_segs <= 0;
+		tuser_1st <= 0;
+		segs_valid <= 0;
+
+		en_shift <= 0;
+	end
+	else begin
+		state <= state_next;
+
+		if(en_shift)
+			tdata_segs <= {s_axis_tdata, tdata_segs[C_AXIS_DATA_WIDTH+:C_AXIS_DATA_WIDTH]};
+		tuser_1st <= s_axis_tuser;
+		segs_valid <= segs_valid_next;
+
+		en_shift <= en_shift_next;
+	end
+end
+
 always @(*) begin
 
 	state_next = state;
 
-	tdata_segs_next = tdata_segs;
-	tuser_1st_next = tuser_1st;
+	// tdata_segs_next = tdata_segs;
+	// tuser_1st_next = tuser_1st;
 	segs_valid_next = 0;
 
+	en_shift_next = 1;
+	
 	case (state)
 		// at-most 2 segs
 		WAIT_1ST_SEG: begin
 			if (s_axis_tvalid) begin
-				tdata_segs_next[0*C_AXIS_DATA_WIDTH+:C_AXIS_DATA_WIDTH] = s_axis_tdata;
-				tuser_1st_next = s_axis_tuser;
+				// tdata_segs_next[0*C_AXIS_DATA_WIDTH+:C_AXIS_DATA_WIDTH] = s_axis_tdata;
+				// tuser_1st_next = s_axis_tuser;
 
 				if (s_axis_tlast) begin
 					state_next = WAIT_1CYCLE;
@@ -63,7 +87,7 @@
 		end
 		WAIT_2ND_SEG: begin
 			if (s_axis_tvalid) begin
-				tdata_segs_next[1*C_AXIS_DATA_WIDTH+:C_AXIS_DATA_WIDTH] = s_axis_tdata;
+				// tdata_segs_next[1*C_AXIS_DATA_WIDTH+:C_AXIS_DATA_WIDTH] = s_axis_tdata;
 
 				segs_valid_next = 1;
 				if (s_axis_tlast) begin
@@ -82,24 +106,4 @@
 	endcase
 end
 
-
-always @(posedge axis_clk) begin
-	if (~aresetn) begin
-
-		state <= WAIT_1ST_SEG;
-
-		tdata_segs <= {C_NUM_SEGS*C_AXIS_DATA_WIDTH{1'b0}};
-		tuser_1st <= {C_AXIS_TUSER_WIDTH{1'b0}};
-		segs_valid <= 0;
-	end
-	else begin
-		state <= state_next;
-
-		tdata_segs <= tdata_segs_next;
-		tuser_1st <= tuser_1st_next;
-
-		segs_valid <= segs_valid_next;
-	end
-end
-
 endmodule
diff -ruN '--exclude=.git' '--exclude=p4c' '--exclude=tb' menshen/pkt_filter.v parametric_menshen/pkt_filter.v
--- menshen/pkt_filter.v
+++ parametric_menshen/pkt_filter.v
@@ -10,8 +10,8 @@
 	parameter C_VLANID_WIDTH = 12
 )
 (
-	input				clk,
-	input				aresetn,
+	input			clk,
+	input			aresetn,
 
 	input [31:0]		vlan_drop_flags,
 	output [31:0]		ctrl_token,
@@ -19,39 +19,39 @@
 
 	// input Slave AXI Stream
 	input [C_S_AXIS_DATA_WIDTH-1:0]			s_axis_tdata,
-	input [((C_S_AXIS_DATA_WIDTH/8))-1:0]	s_axis_tkeep,
+	input [((C_S_AXIS_DATA_WIDTH/8))-1:0]		s_axis_tkeep,
 	input [C_S_AXIS_TUSER_WIDTH-1:0]		s_axis_tuser,
-	input									s_axis_tvalid,
-	output									s_axis_tready,
-	input									s_axis_tlast,
+	input						s_axis_tvalid,
+	output						s_axis_tready,
+	input						s_axis_tlast,
 
 	// output Master AXI Stream
 	output reg [C_S_AXIS_DATA_WIDTH-1:0]		m_axis_tdata,
 	output reg [((C_S_AXIS_DATA_WIDTH/8))-1:0]	m_axis_tkeep,
 	output reg [C_S_AXIS_TUSER_WIDTH-1:0]		m_axis_tuser,
-	output reg									m_axis_tvalid,
-	input										m_axis_tready,
-	output reg									m_axis_tlast,
+	output reg					m_axis_tvalid,
+	input						m_axis_tready,
+	output reg					m_axis_tlast,
 
-	output reg [C_VLANID_WIDTH-1:0]				vlan_id,
-	output reg									vlan_id_valid,
+	output reg [C_VLANID_WIDTH-1:0]			vlan_id,
+	output reg					vlan_id_valid,
 
 	//TODO a back-pressure is needed?
 	output reg [C_S_AXIS_DATA_WIDTH-1:0]		c_m_axis_tdata,
 	output reg [((C_S_AXIS_DATA_WIDTH/8))-1:0]	c_m_axis_tkeep,
 	output reg [C_S_AXIS_TUSER_WIDTH-1:0]		c_m_axis_tuser,
-	output reg									c_m_axis_tvalid,
-	output reg									c_m_axis_tlast
+	output reg					c_m_axis_tvalid,
+	output reg					c_m_axis_tlast
 
 );
 
 
-wire [C_S_AXIS_DATA_WIDTH-1:0]	pkt_fifo_tdata;
-wire [C_S_AXIS_DATA_WIDTH/8-1:0]	pkt_fifo_tkeep;
-wire [C_S_AXIS_TUSER_WIDTH-1:0]		pkt_fifo_tuser;
-wire								pkt_fifo_tlast;
-reg								pkt_fifo_rd_en;
-wire	pkt_fifo_empty, pkt_fifo_full;
+wire [C_S_AXIS_DATA_WIDTH-1:0] pkt_fifo_tdata;
+wire [C_S_AXIS_DATA_WIDTH/8-1:0] pkt_fifo_tkeep;
+wire [C_S_AXIS_TUSER_WIDTH-1:0] pkt_fifo_tuser;
+wire pkt_fifo_tlast;
+reg pkt_fifo_rd_en;
+wire pkt_fifo_empty, pkt_fifo_full;
 
 //
 assign s_axis_tready = !pkt_fifo_full;
@@ -108,7 +108,7 @@
 assign w_c_switch = c_switch;
 assign ctrl_token = ctrl_token_r;
 
-assign vlan_id_w = pkt_fifo_tdata[116 +: 12];
+assign vlan_id_w = pkt_fifo_tdata[288 +: 12];
 assign vlan_id_one_hot_w = (1'b1 << vlan_id_w[8:4]); 
 
 always @(*) begin
@@ -133,11 +133,11 @@
 		WAIT_FIRST_PKT: begin
 			if (!pkt_fifo_empty) begin
 				if (m_axis_tready) begin
-					if ((pkt_fifo_tdata[143:128]==`ETH_TYPE_IPV4) && 
-						(pkt_fifo_tdata[223:216]==`IPPROT_UDP)) begin
+					if ((pkt_fifo_tdata[111:96] ==`ETH_TYPE_IPV4) && 
+						(pkt_fifo_tdata[191:184]==`IPPROT_UDP)) begin
 						//checkme: we put the security check here
-						// if(s_axis_tdata[335:320] == `CONTROL_PORT && cookie_w == cookie_val_d1) begin
-						if(pkt_fifo_tdata[335:320] == `CONTROL_PORT) begin
+						// if(s_axis_tdata[303:288] == `CONTROL_PORT && cookie_w == cookie_val_d1) begin
+						if(pkt_fifo_tdata[303:288] == `CONTROL_PORT) begin
 							state_next = FLUSH_CTL;
 							c_switch = 1'b1;
 							//modify token once its true
diff -ruN '--exclude=.git' '--exclude=p4c' '--exclude=tb' menshen/README.md parametric_menshen/README.md
--- menshen/README.md
+++ parametric_menshen/README.md
@@ -0,0 +1 @@
+In this branch the isolation mechanism of menshen based on the vlan id is changed and now based on the level 4 port (the udp port)
diff -ruN '--exclude=.git' '--exclude=p4c' '--exclude=tb' menshen/rmt_wrapper.sv parametric_menshen/rmt_wrapper.sv
--- menshen/rmt_wrapper.sv
+++ parametric_menshen/rmt_wrapper.sv
@@ -0,0 +1,682 @@
+`timescale 1ns / 1ps
+
+module rmt_wrapper #(
+	// AXI-Lite parameters
+	// Width of AXI lite data bus in bits
+	parameter AXIL_DATA_WIDTH = 32,
+	// Width of AXI lite address bus in bits
+	parameter AXIL_ADDR_WIDTH = 16,
+	// Width of AXI lite wstrb (width of data bus in words)
+	parameter AXIL_STRB_WIDTH = (AXIL_DATA_WIDTH/8),
+	// AXI Stream parameters
+	// Slave
+	parameter C_S_AXIS_DATA_WIDTH = 512,
+	parameter C_S_AXIS_TUSER_WIDTH = 128,
+	// Master
+	// self-defined
+	parameter PHV_LEN = 48*8+32*8+16*8+256,
+	parameter KEY_LEN = 48*2+32*2+16*2+1,
+	parameter ACT_LEN = 25,
+	parameter KEY_OFF = 6*3+20,
+	parameter C_VLANID_WIDTH = 12,
+	parameter C_FIFO_BIT_WIDTH = 4,
+	parameter NUM_OF_STAGES = 5
+)
+(
+	input						clk,		// axis clk
+	input						aresetn,	
+	input [31:0]					vlan_drop_flags,
+	output reg [31:0]				ctrl_token,
+
+	/*
+     * input Slave AXI Stream
+     */
+	input [C_S_AXIS_DATA_WIDTH-1:0]			s_axis_tdata,
+	input [((C_S_AXIS_DATA_WIDTH/8))-1:0]		s_axis_tkeep,
+	input [C_S_AXIS_TUSER_WIDTH-1:0]		s_axis_tuser,
+	input						s_axis_tvalid,
+	output reg					s_axis_tready,
+	input						s_axis_tlast,
+
+	/*
+     * output Master AXI Stream
+     */
+	output reg [C_S_AXIS_DATA_WIDTH-1:0]		m_axis_tdata,
+	output reg [((C_S_AXIS_DATA_WIDTH/8))-1:0]	m_axis_tkeep,
+	output reg [C_S_AXIS_TUSER_WIDTH-1:0]		m_axis_tuser,
+	output reg					m_axis_tvalid,
+	input						m_axis_tready,
+	output reg					m_axis_tlast
+
+	
+);
+
+integer idx;
+
+/*=================================================*/
+localparam PKT_VEC_WIDTH = (6+4+2)*8*8+256;
+
+
+// input and output registers
+logic [C_S_AXIS_DATA_WIDTH-1:0]       s_axis_tdata_r;
+logic [((C_S_AXIS_DATA_WIDTH/8))-1:0] s_axis_tkeep_r;
+logic [C_S_AXIS_TUSER_WIDTH-1:0]      s_axis_tuser_r;
+logic                                 s_axis_tvalid_r;
+logic                                 s_axis_tready_r;
+logic                                 s_axis_tlast_r;
+
+logic [C_S_AXIS_DATA_WIDTH-1:0]       m_axis_tdata_r  [1:0];
+logic [((C_S_AXIS_DATA_WIDTH/8))-1:0] m_axis_tkeep_r  [1:0];
+logic [C_S_AXIS_TUSER_WIDTH-1:0]      m_axis_tuser_r  [1:0];
+logic                                 m_axis_tvalid_r [1:0];
+logic                                 m_axis_tready_r;
+logic                                 m_axis_tlast_r  [1:0];
+
+logic [31:0] vlan_drop_flags_r;
+logic [31:0] ctrl_token_r;
+
+// logic just for the first stage
+logic stg0_phv_in_valid;
+logic stg0_phv_in_valid_sv;
+logic [PKT_VEC_WIDTH-1:0] stg0_phv_in;
+logic [PKT_VEC_WIDTH-1:0] stg0_phv_in_sv;
+logic [C_VLANID_WIDTH-1:0] stg0_vlan_in;
+logic [C_VLANID_WIDTH-1:0] stg0_vlan_in_sv;
+logic stg0_vlan_valid_in;
+logic stg0_vlan_valid_in_sv;
+
+// logic parametric in the number of stages
+logic [PKT_VEC_WIDTH-1:0] stg_phv_out [NUM_OF_STAGES-2:0];
+logic [PKT_VEC_WIDTH-1:0] stg_phv_out_sv [NUM_OF_STAGES-2:0];
+logic stg_phv_out_valid [NUM_OF_STAGES-2:0];
+logic stg_phv_out_valid_sv [NUM_OF_STAGES-2:0];
+logic stg_vlan_ready [NUM_OF_STAGES-1:0];
+logic [C_VLANID_WIDTH-1:0] stg_vlan_out [NUM_OF_STAGES-2:0];
+logic [C_VLANID_WIDTH-1:0] stg_vlan_out_sv [NUM_OF_STAGES-2:0];
+logic stg_vlan_valid_out [NUM_OF_STAGES-2:0];
+logic stg_vlan_valid_out_sv [NUM_OF_STAGES-2:0];
+
+// back pressure signals
+logic s_axis_tready_p;
+logic [NUM_OF_STAGES-1:0] stg_ready;
+
+
+/*=================================================*/
+
+logic [C_VLANID_WIDTH-1:0] s_vlan_id;
+logic s_vlan_id_valid;
+
+logic [C_VLANID_WIDTH-1:0] s_vlan_id_sv;
+logic s_vlan_id_valid_sv;
+
+//NOTE: to filter out packets other than UDP/IP.
+logic [C_S_AXIS_DATA_WIDTH-1:0] s_axis_tdata_f;
+logic [(C_S_AXIS_DATA_WIDTH/8)-1:0] s_axis_tkeep_f;
+logic [C_S_AXIS_TUSER_WIDTH-1:0] s_axis_tuser_f;
+logic s_axis_tvalid_f;
+logic s_axis_tready_f;
+logic s_axis_tlast_f;
+
+logic [C_S_AXIS_DATA_WIDTH-1:0] s_axis_tdata_f_sv;
+logic [(C_S_AXIS_DATA_WIDTH/8)-1:0] s_axis_tkeep_f_sv;
+logic [C_S_AXIS_TUSER_WIDTH-1:0] s_axis_tuser_f_sv;
+logic s_axis_tvalid_f_sv;
+logic s_axis_tlast_f_sv;
+
+//NOTE: filter control packets from data packets.
+logic [C_S_AXIS_DATA_WIDTH-1:0] ctrl_s_axis_tdata [NUM_OF_STAGES+1:0];
+logic [(C_S_AXIS_DATA_WIDTH/8)-1:0] ctrl_s_axis_tkeep [NUM_OF_STAGES+1:0];
+logic [C_S_AXIS_TUSER_WIDTH-1:0] ctrl_s_axis_tuser [NUM_OF_STAGES+1:0];
+logic ctrl_s_axis_tvalid [NUM_OF_STAGES+1:0];
+logic ctrl_s_axis_tlast [NUM_OF_STAGES+1:0];
+
+logic [C_S_AXIS_DATA_WIDTH-1:0] ctrl_s_axis_tdata_sv [NUM_OF_STAGES+1:0];
+logic [(C_S_AXIS_DATA_WIDTH/8)-1:0] ctrl_s_axis_tkeep_sv [NUM_OF_STAGES+1:0];
+logic [C_S_AXIS_TUSER_WIDTH-1:0] ctrl_s_axis_tuser_sv [NUM_OF_STAGES+1:0];
+logic ctrl_s_axis_tvalid_sv [NUM_OF_STAGES+1:0];
+logic ctrl_s_axis_tlast_sv [NUM_OF_STAGES+1:0];
+
+pkt_filter #(
+	.C_S_AXIS_DATA_WIDTH(C_S_AXIS_DATA_WIDTH),
+	.C_S_AXIS_TUSER_WIDTH(C_S_AXIS_TUSER_WIDTH)
+)pkt_filter
+(
+	.clk			(clk),
+	.aresetn		(aresetn),
+
+	.vlan_drop_flags	(vlan_drop_flags_r),
+	.ctrl_token		(ctrl_token_r),
+
+	// input Slave AXI Stream
+	.s_axis_tdata		(s_axis_tdata_r),
+	.s_axis_tkeep		(s_axis_tkeep_r),
+	.s_axis_tuser		(s_axis_tuser_r),
+	.s_axis_tvalid		(s_axis_tvalid_r),
+	.s_axis_tready		(s_axis_tready_r),
+	.s_axis_tlast		(s_axis_tlast_r),
+
+	.vlan_id		(s_vlan_id),
+	.vlan_id_valid		(s_vlan_id_valid),
+
+	// output Master AXI Stream
+	.m_axis_tdata		(s_axis_tdata_f),
+	.m_axis_tkeep		(s_axis_tkeep_f),
+	.m_axis_tuser		(s_axis_tuser_f),
+	.m_axis_tvalid		(s_axis_tvalid_f),
+	// .m_axis_tready(s_axis_tready_f && s_axis_tready_p),
+	.m_axis_tready		(s_axis_tready_f),
+	.m_axis_tlast		(s_axis_tlast_f),
+
+	//control path
+	.c_m_axis_tdata		(ctrl_s_axis_tdata[0]),
+	.c_m_axis_tkeep		(ctrl_s_axis_tkeep[0]),
+	.c_m_axis_tuser		(ctrl_s_axis_tuser[0]),
+	.c_m_axis_tvalid	(ctrl_s_axis_tvalid[0]),
+	.c_m_axis_tlast		(ctrl_s_axis_tlast[0])
+);
+
+// we will have multiple pkt fifos and phv fifos
+// pkt fifo logics
+logic [C_S_AXIS_DATA_WIDTH-1:0] pkt_fifo_tdata_out;
+logic [C_S_AXIS_TUSER_WIDTH-1:0] pkt_fifo_tuser_out;
+logic [(C_S_AXIS_DATA_WIDTH/8)-1:0] pkt_fifo_tkeep_out;
+logic pkt_fifo_tlast_out;
+
+// output from parser
+logic [C_S_AXIS_DATA_WIDTH-1:0] parser_m_axis_tdata;
+logic [C_S_AXIS_TUSER_WIDTH-1:0] parser_m_axis_tuser;
+logic [(C_S_AXIS_DATA_WIDTH/8)-1:0] parser_m_axis_tkeep;
+logic parser_m_axis_tlast;
+logic parser_m_axis_tvalid;
+
+logic pkt_fifo_rd_en [1:0];
+logic pkt_fifo_nearly_full;
+logic pkt_fifo_empty;
+
+assign s_axis_tready_f = !pkt_fifo_nearly_full;
+
+logic switch_in_pkt_fifo;      // logic used for the 2 deparsers, since the FSM inside can accept packets only at
+logic switch_in_phv_fifo;      // half the frequency of the clock
+logic switch_out;
+
+// create a fifo interposed between the parser and the data cache
+fallthrough_small_fifo #(
+	.WIDTH(C_S_AXIS_DATA_WIDTH+C_S_AXIS_TUSER_WIDTH+C_S_AXIS_DATA_WIDTH/8+1),
+	.MAX_DEPTH_BITS(C_FIFO_BIT_WIDTH)
+)
+pkt_fifo (
+	.clk			(clk),                         // input logic clk
+	.reset			(~aresetn),                    // input logic srst
+	.din			({parser_m_axis_tdata, parser_m_axis_tuser,
+				  parser_m_axis_tkeep, parser_m_axis_tlast}),     // input logic [704 : 0] din
+	.wr_en			(parser_m_axis_tvalid),     // input logic wr_en
+	.rd_en			(pkt_fifo_rd_en[switch_in_pkt_fifo]),           // input logic rd_en
+	.dout			({pkt_fifo_tdata_out, pkt_fifo_tuser_out,
+				  pkt_fifo_tkeep_out, pkt_fifo_tlast_out}),       // output logic [704 : 0] dout
+	.full			(),
+	.nearly_full		(pkt_fifo_nearly_full),     // output logic full
+	.empty			(pkt_fifo_empty)            // output logic empty
+);
+
+logic [PKT_VEC_WIDTH-1:0] last_stg_phv_out;
+logic [PKT_VEC_WIDTH-1:0] phv_fifo_out;
+logic last_stg_phv_out_valid;
+
+logic phv_fifo_rd_en [1:0];
+logic phv_fifo_nearly_full;
+logic phv_fifo_empty;
+logic [(PKT_VEC_WIDTH/2)-1:0] high_phv_out;
+logic [(PKT_VEC_WIDTH/2)-1:0] low_phv_out;
+
+assign phv_fifo_out = {high_phv_out, low_phv_out};
+
+// create 2 fifos (since each fifo is half the size of the phv) interposed between the phv exiting from the last stage and the phv entering the deparser
+fallthrough_small_fifo #(
+	.WIDTH(PKT_VEC_WIDTH/2),
+	.MAX_DEPTH_BITS(6)
+)
+phv_fifo_1 (
+	.clk			(clk),
+	.reset			(~aresetn),
+	.din			(last_stg_phv_out[(PKT_VEC_WIDTH/2)-1:0]),
+	.wr_en			(last_stg_phv_out_valid),
+	.rd_en			(phv_fifo_rd_en[switch_in_phv_fifo]),
+	.dout			(low_phv_out),
+	.full			(),
+	.nearly_full		(phv_fifo_nearly_full),
+	.empty			(phv_fifo_empty)
+);
+
+fallthrough_small_fifo #(
+	.WIDTH(PKT_VEC_WIDTH/2),
+	.MAX_DEPTH_BITS(6)
+)
+phv_fifo_2 (
+	.clk			(clk),
+	.reset			(~aresetn),
+	.din			(last_stg_phv_out[PKT_VEC_WIDTH-1:(PKT_VEC_WIDTH/2)]),
+	.wr_en			(last_stg_phv_out_valid),
+	.rd_en			(phv_fifo_rd_en[switch_in_phv_fifo]),
+	.dout			(high_phv_out),
+	.full			(),
+	.nearly_full		(),
+	.empty			()
+);
+
+parser_top #(
+	.C_S_AXIS_DATA_WIDTH(C_S_AXIS_DATA_WIDTH), //for 100g mac exclusively
+	.C_S_AXIS_TUSER_WIDTH(C_S_AXIS_TUSER_WIDTH),
+	.PKT_HDR_LEN()
+)
+phv_parser
+(
+	.axis_clk		(clk),
+	.aresetn		(aresetn),
+	// input slave axi stream
+	.s_axis_tdata		(s_axis_tdata_f_sv),
+	.s_axis_tuser		(s_axis_tuser_f_sv),
+	.s_axis_tkeep		(s_axis_tkeep_f_sv),
+	// .s_axis_tvalid(s_axis_tvalid_f_sv & s_axis_tready_f),
+	.s_axis_tvalid		(s_axis_tvalid_f_sv),
+	.s_axis_tlast		(s_axis_tlast_f_sv),
+	.s_axis_tready		(s_axis_tready_p),
+
+	.s_vlan_id		(s_vlan_id_sv),
+	.s_vlan_id_valid	(s_vlan_id_valid_sv),
+
+	// output
+	.parser_valid		(stg0_phv_in_valid),
+	.pkt_hdr_vec		(stg0_phv_in),
+	.out_vlan		(stg0_vlan_in),
+	.out_vlan_valid		(stg0_vlan_valid_in),
+	.out_vlan_ready		(stg_vlan_ready[0]),
+	// 
+	.stg_ready_in		(stg_ready[0]),
+
+	// output to different pkt fifos
+	.m_axis_tdata_0		(parser_m_axis_tdata),
+	.m_axis_tuser_0		(parser_m_axis_tuser),
+	.m_axis_tkeep_0		(parser_m_axis_tkeep),
+	.m_axis_tlast_0		(parser_m_axis_tlast),
+	.m_axis_tvalid_0	(parser_m_axis_tvalid),
+	.m_axis_tready_0	(~pkt_fifo_nearly_full),
+
+	// control path
+	.ctrl_s_axis_tdata	(ctrl_s_axis_tdata_sv[0]),
+	.ctrl_s_axis_tuser	(ctrl_s_axis_tuser_sv[0]),
+	.ctrl_s_axis_tkeep	(ctrl_s_axis_tkeep_sv[0]),
+	.ctrl_s_axis_tlast	(ctrl_s_axis_tlast_sv[0]),
+	.ctrl_s_axis_tvalid	(ctrl_s_axis_tvalid_sv[0]),
+
+	.ctrl_m_axis_tdata	(ctrl_s_axis_tdata[1]),
+	.ctrl_m_axis_tuser	(ctrl_s_axis_tuser[1]),
+	.ctrl_m_axis_tkeep	(ctrl_s_axis_tkeep[1]),
+	.ctrl_m_axis_tlast	(ctrl_s_axis_tlast[1]),
+	.ctrl_m_axis_tvalid	(ctrl_s_axis_tvalid[1])
+);
+
+stage #(
+	.C_S_AXIS_DATA_WIDTH(C_S_AXIS_DATA_WIDTH),
+	.STAGE_ID(0),
+	.NUM_OF_STAGES(NUM_OF_STAGES),
+	.C_S_AXIS_TUSER_WIDTH(C_S_AXIS_TUSER_WIDTH)
+)
+first_stage
+(
+	.axis_clk		(clk),
+	.aresetn		(aresetn),
+
+	// input
+	.phv_in			(stg0_phv_in_sv),
+	.phv_in_valid		(stg0_phv_in_valid_sv),
+	.vlan_in		(stg0_vlan_in_sv),
+	.vlan_valid_in		(stg0_vlan_valid_in_sv),
+	.vlan_ready_out		(stg_vlan_ready[0]),
+	// output
+	.vlan_out		(stg_vlan_out[0]),
+	.vlan_valid_out		(stg_vlan_valid_out[0]),
+	.vlan_out_ready		(stg_vlan_ready[1]),
+	// output
+	.phv_out		(stg_phv_out[0]),
+	.phv_out_valid		(stg_phv_out_valid[0]),
+	// back-pressure signals
+	.stage_ready_out	(stg_ready[0]),
+	.stage_ready_in		(stg_ready[1]),
+
+	// control path
+	.c_s_axis_tdata		(ctrl_s_axis_tdata_sv[1]),
+	.c_s_axis_tuser		(ctrl_s_axis_tuser_sv[1]),
+	.c_s_axis_tkeep		(ctrl_s_axis_tkeep_sv[1]),
+	.c_s_axis_tlast		(ctrl_s_axis_tlast_sv[1]),
+	.c_s_axis_tvalid	(ctrl_s_axis_tvalid_sv[1]),
+
+	.c_m_axis_tdata		(ctrl_s_axis_tdata[2]),
+	.c_m_axis_tuser		(ctrl_s_axis_tuser[2]),
+	.c_m_axis_tkeep		(ctrl_s_axis_tkeep[2]),
+	.c_m_axis_tlast		(ctrl_s_axis_tlast[2]),
+	.c_m_axis_tvalid	(ctrl_s_axis_tvalid[2])
+);
+
+genvar i;
+generate
+	for (i=0; i<NUM_OF_STAGES+2; i=i+1) begin
+		always_ff @(posedge clk) begin
+			if (~aresetn) begin
+				ctrl_s_axis_tdata_sv[i] <= {C_S_AXIS_DATA_WIDTH{1'b 0}};
+				ctrl_s_axis_tuser_sv[i] <= {C_S_AXIS_TUSER_WIDTH{1'b 0}};
+				ctrl_s_axis_tkeep_sv[i] <= {(C_S_AXIS_DATA_WIDTH/8){1'b 0}};
+				ctrl_s_axis_tlast_sv[i] <= 0;
+				ctrl_s_axis_tvalid_sv[i] <= 0;
+			end
+			else begin
+				ctrl_s_axis_tdata_sv[i] <= ctrl_s_axis_tdata[i];
+				ctrl_s_axis_tuser_sv[i] <= ctrl_s_axis_tuser[i];
+				ctrl_s_axis_tkeep_sv[i] <= ctrl_s_axis_tkeep[i];
+				ctrl_s_axis_tlast_sv[i] <= ctrl_s_axis_tlast[i];
+				ctrl_s_axis_tvalid_sv[i] <= ctrl_s_axis_tvalid[i];
+			end
+		end
+	end
+endgenerate
+
+generate
+	for (i=0; i<NUM_OF_STAGES-1; i=i+1) begin
+		always_ff @(posedge clk) begin
+			if (~aresetn) begin
+				stg_phv_out_sv[i] <= {PKT_VEC_WIDTH{1'b 0}};
+				stg_phv_out_valid_sv[i] <= 0;
+				stg_vlan_out_sv[i] <= {C_VLANID_WIDTH{1'b 0}};
+				stg_vlan_valid_out_sv[i] <= 0;
+			end
+			else begin
+				stg_phv_out_sv[i] <= stg_phv_out[i];
+				stg_phv_out_valid_sv[i] <= stg_phv_out_valid[i];
+				stg_vlan_out_sv[i] <= stg_vlan_out[i];
+				stg_vlan_valid_out_sv[i] <= stg_vlan_valid_out[i];
+			end
+		end
+	end
+endgenerate
+
+generate
+	for (i=0; i<NUM_OF_STAGES-2; i=i+1) begin:
+		middle_stage
+		stage #(
+			.C_S_AXIS_DATA_WIDTH(C_S_AXIS_DATA_WIDTH),
+			.STAGE_ID(i+1),
+			.NUM_OF_STAGES(NUM_OF_STAGES),
+			.C_S_AXIS_TUSER_WIDTH(C_S_AXIS_TUSER_WIDTH)
+		)
+		stage_i
+		(
+			.axis_clk		(clk),
+			.aresetn		(aresetn),
+
+			// input
+			.phv_in			(stg_phv_out_sv[i]),
+			.phv_in_valid		(stg_phv_out_valid_sv[i]),
+			.vlan_in		(stg_vlan_out_sv[i]),
+			.vlan_valid_in		(stg_vlan_valid_out_sv[i]),
+			.vlan_ready_out		(stg_vlan_ready[i+1]),
+			// output
+			.vlan_out		(stg_vlan_out[i+1]),
+			.vlan_valid_out		(stg_vlan_valid_out[i+1]),
+			.vlan_out_ready		(stg_vlan_ready[i+2]),
+			// output
+			.phv_out		(stg_phv_out[i+1]),
+			.phv_out_valid		(stg_phv_out_valid[i+1]),
+			// back-pressure signals
+			.stage_ready_out	(stg_ready[i+1]),
+			.stage_ready_in		(stg_ready[i+2]),
+
+			// control path
+			.c_s_axis_tdata		(ctrl_s_axis_tdata_sv[i+2]),
+			.c_s_axis_tuser		(ctrl_s_axis_tuser_sv[i+2]),
+			.c_s_axis_tkeep		(ctrl_s_axis_tkeep_sv[i+2]),
+			.c_s_axis_tlast		(ctrl_s_axis_tlast_sv[i+2]),
+			.c_s_axis_tvalid	(ctrl_s_axis_tvalid_sv[i+2]),
+
+			.c_m_axis_tdata		(ctrl_s_axis_tdata[i+3]),
+			.c_m_axis_tuser		(ctrl_s_axis_tuser[i+3]),
+			.c_m_axis_tkeep		(ctrl_s_axis_tkeep[i+3]),
+			.c_m_axis_tlast		(ctrl_s_axis_tlast[i+3]),
+			.c_m_axis_tvalid	(ctrl_s_axis_tvalid[i+3])
+		);
+	end
+endgenerate
+
+// [NOTICE] change to last stage
+last_stage #(
+	.C_S_AXIS_DATA_WIDTH(512),
+	//.C_S_AXIS_DATA_WIDTH(C_S_AXIS_DATA_WIDTH),
+	.STAGE_ID(NUM_OF_STAGES-1),
+	.NUM_OF_STAGES(NUM_OF_STAGES),
+	.C_S_AXIS_TUSER_WIDTH(C_S_AXIS_TUSER_WIDTH)
+)
+final_stage
+(
+	.axis_clk		(clk),
+	.aresetn		(aresetn),
+
+	// input
+	.phv_in			(stg_phv_out_sv[NUM_OF_STAGES-2]),
+	.phv_in_valid		(stg_phv_out_valid_sv[NUM_OF_STAGES-2]),
+	.vlan_in		(stg_vlan_out_sv[NUM_OF_STAGES-2]),
+	.vlan_valid_in		(stg_vlan_valid_out_sv[NUM_OF_STAGES-2]),
+	.vlan_ready_out		(stg_vlan_ready[NUM_OF_STAGES-1]),
+	// back-pressure signals
+	.stage_ready_out	(stg_ready[NUM_OF_STAGES-1]),
+	// output
+	.phv_out_0		(last_stg_phv_out),
+	.phv_out_valid_0	(last_stg_phv_out_valid),
+	.phv_fifo_ready_0	(~phv_fifo_nearly_full),
+
+	// control path
+	.c_s_axis_tdata		(ctrl_s_axis_tdata_sv[NUM_OF_STAGES]),
+	.c_s_axis_tuser		(ctrl_s_axis_tuser_sv[NUM_OF_STAGES]),
+	.c_s_axis_tkeep		(ctrl_s_axis_tkeep_sv[NUM_OF_STAGES]),
+	.c_s_axis_tlast		(ctrl_s_axis_tlast_sv[NUM_OF_STAGES]),
+	.c_s_axis_tvalid	(ctrl_s_axis_tvalid_sv[NUM_OF_STAGES]),
+
+	.c_m_axis_tdata		(ctrl_s_axis_tdata[NUM_OF_STAGES+1]),
+	.c_m_axis_tuser		(ctrl_s_axis_tuser[NUM_OF_STAGES+1]),
+	.c_m_axis_tkeep		(ctrl_s_axis_tkeep[NUM_OF_STAGES+1]),
+	.c_m_axis_tlast		(ctrl_s_axis_tlast[NUM_OF_STAGES+1]),
+	.c_m_axis_tvalid	(ctrl_s_axis_tvalid[NUM_OF_STAGES+1])
+);
+
+
+// logic used for the 2 deparsers, since the FSM inside can accept packets only at half the frequency of the clock
+always @(posedge clk) begin
+    if (~aresetn) begin
+        switch_in_pkt_fifo <= 0;
+    end
+    else begin
+        if(pkt_fifo_tlast_out && !pkt_fifo_empty && pkt_fifo_rd_en[switch_in_pkt_fifo])
+        begin
+            switch_in_pkt_fifo <= ~switch_in_pkt_fifo;
+        end
+    end
+end
+
+always @(posedge clk) begin
+    if (~aresetn) begin
+        switch_in_phv_fifo <= 0;
+    end
+    else begin
+        if(!phv_fifo_empty && phv_fifo_rd_en[switch_in_phv_fifo])
+        begin
+            switch_in_phv_fifo <= ~switch_in_phv_fifo;
+        end
+    end
+end
+
+// per gli output faccio la stessa cosa, ma con uno switch diverso e il ready in lo metto uguale ad entrambi
+always @(posedge clk) begin
+    if (~aresetn) begin
+        switch_out <= 0;
+    end
+    else begin
+        if(m_axis_tlast_r[switch_out] && m_axis_tvalid_r[switch_out])
+        begin
+            switch_out <= ~switch_out;
+        end
+    end
+end
+
+// N.B: ready in e control path sono quindi cortocircuitati su entrambi i moduli del deparser. Non serve fare uno switch per loro
+
+
+deparser_top #(
+	.C_AXIS_DATA_WIDTH(C_S_AXIS_DATA_WIDTH),
+	.C_AXIS_TUSER_WIDTH(C_S_AXIS_TUSER_WIDTH),
+	.C_PKT_VEC_WIDTH(),
+	.DEPARSER_MOD_ID()
+)
+phv_deparser_1 (
+	.axis_clk		(clk),
+	.aresetn		(aresetn),
+
+	//data plane
+	.pkt_fifo_tdata		(pkt_fifo_tdata_out),
+	.pkt_fifo_tkeep		(pkt_fifo_tkeep_out),
+	.pkt_fifo_tuser		(pkt_fifo_tuser_out),
+	.pkt_fifo_tlast		(pkt_fifo_tlast_out),
+	.pkt_fifo_empty		(pkt_fifo_empty | switch_in_pkt_fifo),
+	// output from STAGE
+	.pkt_fifo_rd_en		(pkt_fifo_rd_en[0]),
+
+	.phv_fifo_out		(phv_fifo_out),
+	.phv_fifo_empty		(phv_fifo_empty | switch_in_phv_fifo),
+	.phv_fifo_rd_en		(phv_fifo_rd_en[0]),
+	// output
+	.depar_out_tdata	(m_axis_tdata_r[0]),
+	.depar_out_tkeep	(m_axis_tkeep_r[0]),
+	.depar_out_tuser	(m_axis_tuser_r[0]),
+	.depar_out_tvalid	(m_axis_tvalid_r[0]),
+	.depar_out_tlast	(m_axis_tlast_r[0]),
+	// input
+	.depar_out_tready	(m_axis_tready_r),
+
+	//control path
+	.ctrl_s_axis_tdata	(ctrl_s_axis_tdata_sv[NUM_OF_STAGES+1]),
+	.ctrl_s_axis_tuser	(ctrl_s_axis_tuser_sv[NUM_OF_STAGES+1]),
+	.ctrl_s_axis_tkeep	(ctrl_s_axis_tkeep_sv[NUM_OF_STAGES+1]),
+	.ctrl_s_axis_tvalid	(ctrl_s_axis_tvalid_sv[NUM_OF_STAGES+1]),
+	.ctrl_s_axis_tlast	(ctrl_s_axis_tlast_sv[NUM_OF_STAGES+1])
+);
+
+deparser_top #(
+	.C_AXIS_DATA_WIDTH(C_S_AXIS_DATA_WIDTH),
+	.C_AXIS_TUSER_WIDTH(C_S_AXIS_TUSER_WIDTH),
+	.C_PKT_VEC_WIDTH(),
+	.DEPARSER_MOD_ID()
+)
+phv_deparser_2 (
+	.axis_clk		(clk),
+	.aresetn		(aresetn),
+
+	//data plane
+	.pkt_fifo_tdata		(pkt_fifo_tdata_out),
+	.pkt_fifo_tkeep		(pkt_fifo_tkeep_out),
+	.pkt_fifo_tuser		(pkt_fifo_tuser_out),
+	.pkt_fifo_tlast		(pkt_fifo_tlast_out),
+	.pkt_fifo_empty		(pkt_fifo_empty | ~switch_in_pkt_fifo),
+	// output from STAGE
+	.pkt_fifo_rd_en		(pkt_fifo_rd_en[1]),
+
+	.phv_fifo_out		(phv_fifo_out),
+	.phv_fifo_empty		(phv_fifo_empty | ~switch_in_phv_fifo),
+	.phv_fifo_rd_en		(phv_fifo_rd_en[1]),
+	// output
+	.depar_out_tdata	(m_axis_tdata_r[1]),
+	.depar_out_tkeep	(m_axis_tkeep_r[1]),
+	.depar_out_tuser	(m_axis_tuser_r[1]),
+	.depar_out_tvalid	(m_axis_tvalid_r[1]),
+	.depar_out_tlast	(m_axis_tlast_r[1]),
+	// input
+	.depar_out_tready	(m_axis_tready_r),
+
+	//control path
+	.ctrl_s_axis_tdata	(ctrl_s_axis_tdata_sv[NUM_OF_STAGES+1]),
+	.ctrl_s_axis_tuser	(ctrl_s_axis_tuser_sv[NUM_OF_STAGES+1]),
+	.ctrl_s_axis_tkeep	(ctrl_s_axis_tkeep_sv[NUM_OF_STAGES+1]),
+	.ctrl_s_axis_tvalid	(ctrl_s_axis_tvalid_sv[NUM_OF_STAGES+1]),
+	.ctrl_s_axis_tlast	(ctrl_s_axis_tlast_sv[NUM_OF_STAGES+1])
+);
+
+
+logic first_beat;
+
+always_ff @(posedge clk) begin
+    if (~aresetn) begin
+        stg0_phv_in_valid_sv <= 0;
+        stg0_phv_in_sv <= 0;
+        stg0_vlan_in_sv <= 0;
+        stg0_vlan_valid_in_sv <= 0;
+	    
+	    s_axis_tdata_r <= 0;
+        s_axis_tkeep_r <= 0;
+        s_axis_tuser_r <= 0;
+        s_axis_tvalid_r <= 0;
+        s_axis_tready <= 0;
+        s_axis_tlast_r <= 0;
+	    
+	    m_axis_tdata <= 0;
+        m_axis_tkeep <= 0;
+        m_axis_tuser <= 0;
+        m_axis_tvalid <= 0;
+        m_axis_tready_r <= 0;
+        m_axis_tlast <= 0;
+        
+        vlan_drop_flags_r <= 0;
+        ctrl_token <= 0;
+
+        s_axis_tdata_f_sv <= 0;
+        s_axis_tkeep_f_sv <= 0;
+        s_axis_tuser_f_sv <= 0;
+        s_axis_tlast_f_sv <= 0;
+        s_axis_tvalid_f_sv <= 0;
+
+        s_vlan_id_sv <= 0;
+        s_vlan_id_valid_sv <= 0;
+        
+        first_beat <= 0;
+    end
+    else begin
+        stg0_phv_in_valid_sv <= stg0_phv_in_valid;
+        stg0_phv_in_sv <= stg0_phv_in;
+        stg0_vlan_in_sv <= stg0_vlan_in;
+        stg0_vlan_valid_in_sv <= stg0_vlan_valid_in;
+	    
+	    s_axis_tdata_r <= s_axis_tdata;
+        s_axis_tkeep_r <= s_axis_tkeep;
+        s_axis_tuser_r <= s_axis_tuser;
+        s_axis_tvalid_r <= s_axis_tvalid & s_axis_tready;
+        s_axis_tready <= &{stg_ready, s_axis_tready_r} & (~s_axis_tlast) | (s_axis_tlast & ~first_beat);
+        s_axis_tlast_r <= s_axis_tlast;
+        
+	    m_axis_tdata <= m_axis_tdata_r[switch_out];
+        m_axis_tkeep <= m_axis_tkeep_r[switch_out];
+        m_axis_tuser <= m_axis_tuser_r[switch_out];
+        m_axis_tvalid <= m_axis_tvalid_r[switch_out];
+        m_axis_tready_r <= m_axis_tready;
+        m_axis_tlast <= m_axis_tlast_r[switch_out];
+        
+        vlan_drop_flags_r <= vlan_drop_flags;
+        ctrl_token <= ctrl_token_r;
+
+        s_axis_tdata_f_sv <= s_axis_tdata_f;
+        s_axis_tkeep_f_sv <= s_axis_tkeep_f;
+        s_axis_tuser_f_sv <= s_axis_tuser_f;
+        s_axis_tlast_f_sv <= s_axis_tlast_f;
+        s_axis_tvalid_f_sv <= s_axis_tvalid_f;
+
+        s_vlan_id_sv <= s_vlan_id;
+        s_vlan_id_valid_sv <= s_vlan_id_valid;
+        
+        first_beat <= ~s_axis_tvalid;
+    end
+end
+
+endmodule
diff -ruN '--exclude=.git' '--exclude=p4c' '--exclude=tb' menshen/stage.v parametric_menshen/stage.v
--- menshen/stage.v
+++ parametric_menshen/stage.v
@@ -3,12 +3,13 @@
 module stage #(
     parameter C_S_AXIS_DATA_WIDTH = 512,
     parameter C_S_AXIS_TUSER_WIDTH = 128,
-    parameter STAGE_ID = 0,  // valid: 0-4
+    parameter STAGE_ID = 0,  // valid: 0-32
     parameter PHV_LEN = 48*8+32*8+16*8+256,
     parameter KEY_LEN = 48*2+32*2+16*2+1,
     parameter ACT_LEN = 25,
     parameter KEY_OFF = 6*3+20,
-	parameter C_VLANID_WIDTH = 12
+    parameter C_VLANID_WIDTH = 12,
+    parameter NUM_OF_STAGES = 5
 )
 (
     input									axis_clk,
@@ -45,6 +46,7 @@
 
 );
 
+wire                         key_extract_ready_out;
 //key_extract to lookup_engine
 wire [KEY_LEN-1:0]           key2lookup_key;
 wire                         key2lookup_key_valid;
@@ -102,6 +104,8 @@
 reg							act_vlan_out_valid_r;
 wire						act_vlan_ready;
 
+assign stage_ready_out = key_extract_ready_out & lookup2key_ready;
+
 always @(posedge axis_clk) begin
 	if (~aresetn) begin
 		key2lookup_key_r <= 0;
@@ -175,7 +179,7 @@
     .rst_n(aresetn),
     .phv_in(phv_in),
     .phv_valid_in(phv_in_valid),
-    .ready_out(stage_ready_out),
+    .ready_out(key_extract_ready_out),
 
 	.vlan_in				(vlan_in),
 	.vlan_in_valid			(vlan_valid_in),
@@ -210,7 +214,8 @@
     .PHV_LEN(),
     .KEY_LEN(KEY_LEN),
     .ACT_LEN(),
-    .LOOKUP_ID()
+    .LOOKUP_ID(),
+    .NUM_OF_STAGES(NUM_OF_STAGES)
 ) lookup_engine(
     .clk(axis_clk),
     .rst_n(aresetn),
@@ -252,7 +257,8 @@
 	.C_S_AXIS_DATA_WIDTH(C_S_AXIS_DATA_WIDTH),
     .PHV_LEN(),
     .ACT_LEN(),
-    .ACTION_ID()
+    .ACTION_ID(),
+    .C_S_AXIS_TUSER_WIDTH(C_S_AXIS_TUSER_WIDTH)
 )action_engine(
     .clk(axis_clk),
     .rst_n(aresetn),
diff -ruN '--exclude=.git' '--exclude=p4c' '--exclude=tb' menshen/sub_deparser.v parametric_menshen/sub_deparser.v
--- menshen/sub_deparser.v
+++ parametric_menshen/sub_deparser.v
@@ -33,58 +33,56 @@
 	val_out_nxt = val_out;
 	val_out_type_nxt = val_out_type;
 
-	if (parse_act_valid) begin
-		val_out_valid_nxt = 1;
-
-		case({parse_act[5:4], parse_act[0]})
-			// 2B
-			3'b011: begin
-				val_out_type_nxt = 2'b01;
-				case(parse_act[3:1])
-					3'd0: val_out_nxt[15:0] = phv_in[PHV_2B_START_POS+16*0 +: 16];
-					3'd1: val_out_nxt[15:0] = phv_in[PHV_2B_START_POS+16*1 +: 16];
-					3'd2: val_out_nxt[15:0] = phv_in[PHV_2B_START_POS+16*2 +: 16];
-					3'd3: val_out_nxt[15:0] = phv_in[PHV_2B_START_POS+16*3 +: 16];
-					3'd4: val_out_nxt[15:0] = phv_in[PHV_2B_START_POS+16*4 +: 16];
-					3'd5: val_out_nxt[15:0] = phv_in[PHV_2B_START_POS+16*5 +: 16];
-					3'd6: val_out_nxt[15:0] = phv_in[PHV_2B_START_POS+16*6 +: 16];
-					3'd7: val_out_nxt[15:0] = phv_in[PHV_2B_START_POS+16*7 +: 16];
-				endcase
-			end
-			// 4B
-			3'b101: begin
-				val_out_type_nxt = 2'b10;
-				case(parse_act[3:1])
-					3'd0: val_out_nxt[31:0] = phv_in[PHV_4B_START_POS+32*0 +: 32];
-					3'd1: val_out_nxt[31:0] = phv_in[PHV_4B_START_POS+32*1 +: 32];
-					3'd2: val_out_nxt[31:0] = phv_in[PHV_4B_START_POS+32*2 +: 32];
-					3'd3: val_out_nxt[31:0] = phv_in[PHV_4B_START_POS+32*3 +: 32];
-					3'd4: val_out_nxt[31:0] = phv_in[PHV_4B_START_POS+32*4 +: 32];
-					3'd5: val_out_nxt[31:0] = phv_in[PHV_4B_START_POS+32*5 +: 32];
-					3'd6: val_out_nxt[31:0] = phv_in[PHV_4B_START_POS+32*6 +: 32];
-					3'd7: val_out_nxt[31:0] = phv_in[PHV_4B_START_POS+32*7 +: 32];
-				endcase
-			end
-			// 6B
-			3'b111: begin
-				val_out_type_nxt = 2'b11;
-				case(parse_act[3:1])
-					3'd0: val_out_nxt[47:0] = phv_in[PHV_6B_START_POS+48*0 +: 48];
-					3'd1: val_out_nxt[47:0] = phv_in[PHV_6B_START_POS+48*1 +: 48];
-					3'd2: val_out_nxt[47:0] = phv_in[PHV_6B_START_POS+48*2 +: 48];
-					3'd3: val_out_nxt[47:0] = phv_in[PHV_6B_START_POS+48*3 +: 48];
-					3'd4: val_out_nxt[47:0] = phv_in[PHV_6B_START_POS+48*4 +: 48];
-					3'd5: val_out_nxt[47:0] = phv_in[PHV_6B_START_POS+48*5 +: 48];
-					3'd6: val_out_nxt[47:0] = phv_in[PHV_6B_START_POS+48*6 +: 48];
-					3'd7: val_out_nxt[47:0] = phv_in[PHV_6B_START_POS+48*7 +: 48];
-				endcase
-			end
-			default: begin
-				val_out_type_nxt = 0;
-				val_out_nxt = 0;
-			end
-		endcase
-	end
+	val_out_valid_nxt = parse_act_valid;
+	
+	case({parse_act[5:4], parse_act[0]})
+		// 2B
+		3'b011: begin
+			val_out_type_nxt = 2'b01;
+			case(parse_act[3:1])
+				3'd0: val_out_nxt[15:0] = phv_in[PHV_2B_START_POS+16*0 +: 16];
+				3'd1: val_out_nxt[15:0] = phv_in[PHV_2B_START_POS+16*1 +: 16];
+				3'd2: val_out_nxt[15:0] = phv_in[PHV_2B_START_POS+16*2 +: 16];
+				3'd3: val_out_nxt[15:0] = phv_in[PHV_2B_START_POS+16*3 +: 16];
+				3'd4: val_out_nxt[15:0] = phv_in[PHV_2B_START_POS+16*4 +: 16];
+				3'd5: val_out_nxt[15:0] = phv_in[PHV_2B_START_POS+16*5 +: 16];
+				3'd6: val_out_nxt[15:0] = phv_in[PHV_2B_START_POS+16*6 +: 16];
+				3'd7: val_out_nxt[15:0] = phv_in[PHV_2B_START_POS+16*7 +: 16];
+			endcase
+		end
+		// 4B
+		3'b101: begin
+			val_out_type_nxt = 2'b10;
+			case(parse_act[3:1])
+				3'd0: val_out_nxt[31:0] = phv_in[PHV_4B_START_POS+32*0 +: 32];
+				3'd1: val_out_nxt[31:0] = phv_in[PHV_4B_START_POS+32*1 +: 32];
+				3'd2: val_out_nxt[31:0] = phv_in[PHV_4B_START_POS+32*2 +: 32];
+				3'd3: val_out_nxt[31:0] = phv_in[PHV_4B_START_POS+32*3 +: 32];
+				3'd4: val_out_nxt[31:0] = phv_in[PHV_4B_START_POS+32*4 +: 32];
+				3'd5: val_out_nxt[31:0] = phv_in[PHV_4B_START_POS+32*5 +: 32];
+				3'd6: val_out_nxt[31:0] = phv_in[PHV_4B_START_POS+32*6 +: 32];
+				3'd7: val_out_nxt[31:0] = phv_in[PHV_4B_START_POS+32*7 +: 32];
+			endcase
+		end
+		// 6B
+		3'b111: begin
+			val_out_type_nxt = 2'b11;
+			case(parse_act[3:1])
+				3'd0: val_out_nxt[47:0] = phv_in[PHV_6B_START_POS+48*0 +: 48];
+				3'd1: val_out_nxt[47:0] = phv_in[PHV_6B_START_POS+48*1 +: 48];
+				3'd2: val_out_nxt[47:0] = phv_in[PHV_6B_START_POS+48*2 +: 48];
+				3'd3: val_out_nxt[47:0] = phv_in[PHV_6B_START_POS+48*3 +: 48];
+				3'd4: val_out_nxt[47:0] = phv_in[PHV_6B_START_POS+48*4 +: 48];
+				3'd5: val_out_nxt[47:0] = phv_in[PHV_6B_START_POS+48*5 +: 48];
+				3'd6: val_out_nxt[47:0] = phv_in[PHV_6B_START_POS+48*6 +: 48];
+				3'd7: val_out_nxt[47:0] = phv_in[PHV_6B_START_POS+48*7 +: 48];
+			endcase
+		end
+		default: begin
+			val_out_type_nxt = 0;
+			val_out_nxt = 0;
+		end
+	endcase
 end
 
 
diff -ruN '--exclude=.git' '--exclude=p4c' '--exclude=tb' menshen/sub_parser.v parametric_menshen/sub_parser.v
--- menshen/sub_parser.v
+++ parametric_menshen/sub_parser.v
@@ -37,29 +37,29 @@
 	if (parse_act_valid) begin
 		val_out_valid_nxt = 1;
 		val_out_seq_nxt = parse_act[3:1];
-		
-		case({parse_act[5:4], parse_act[0]})
-			// 2B
-			3'b011: begin
-				val_out_type_nxt = 2'b01;
-				val_out_nxt[15:0] = pkts_hdr[(parse_act[12:6])*8 +: 16];
-			end
-			// 4B
-			3'b101: begin
-				val_out_type_nxt = 2'b10;
-				val_out_nxt[31:0] = pkts_hdr[(parse_act[12:6])*8 +: 32];
-			end
-			// 6B
-			3'b111: begin
-				val_out_type_nxt = 2'b11;
-				val_out_nxt[47:0] = pkts_hdr[(parse_act[12:6])*8 +: 48];
-			end
-			default: begin
-				val_out_type_nxt = 0;
-				val_out_nxt = 0;
-			end
-		endcase
 	end
+	
+	case({parse_act[5:4], parse_act[0]})
+		// 2B
+		3'b011: begin
+			val_out_type_nxt = 2'b01;
+			val_out_nxt[15:0] = pkts_hdr[(parse_act[12:6])*8 +: 16];
+		end
+		// 4B
+		3'b101: begin
+			val_out_type_nxt = 2'b10;
+			val_out_nxt[31:0] = pkts_hdr[(parse_act[12:6])*8 +: 32];
+		end
+		// 6B
+		3'b111: begin
+			val_out_type_nxt = 2'b11;
+			val_out_nxt[47:0] = pkts_hdr[(parse_act[12:6])*8 +: 48];
+		end
+		default: begin
+			val_out_type_nxt = 0;
+			val_out_nxt = 0;
+		end
+	endcase
 end
 
 always @(posedge clk) begin
diff -ruN '--exclude=.git' '--exclude=p4c' '--exclude=tb' menshen/tcl/proj_pkt_gen.tcl parametric_menshen/tcl/proj_pkt_gen.tcl
--- menshen/tcl/proj_pkt_gen.tcl
+++ parametric_menshen/tcl/proj_pkt_gen.tcl
@@ -2,14 +2,12 @@
 set sim_top tb/tb_pkt_gen.v
 set device xcu250-figd2104-2-e
 set proj_dir ./project_pktgen
-set public_repo_dir /home/wtao/workspace/hc20-verilog/corundum/fpga/lib_rmt/netfpga_fifo/
 
 create_project -name ${design} -force -dir "${proj_dir}" -part ${device}
 set_property source_mgmt_mode DisplayOnly [current_project]
 puts "Creating RMT 512b datawidth simulation"
 
 create_fileset -constrset -quiet constrants
-set_property ip_repo_paths ${public_repo_dir} [current_fileset]
 update_ip_catalog
 
 # dummy
@@ -97,7 +95,7 @@
 read_verilog "./deparser_top.v"
 read_verilog "./depar_do_deparsing.v"
 read_verilog "./depar_wait_segs.v"
-read_verilog "./rmt_wrapper.v"
+read_verilog "./rmt_wrapper.sv"
 read_verilog "./stage.v"
 read_verilog "./last_stage.v"
 read_verilog "./output_arbiter.v"
diff -ruN '--exclude=.git' '--exclude=p4c' '--exclude=tb' menshen/tcl/proj_sim.tcl parametric_menshen/tcl/proj_sim.tcl
--- menshen/tcl/proj_sim.tcl
+++ parametric_menshen/tcl/proj_sim.tcl
@@ -2,22 +2,14 @@
 set sim_top tb/tb_rmt_wrapper.v
 set device xcu250-figd2104-2-e
 set proj_dir ./project_sim
-set public_repo_dir /home/wtao/workspace/hc20-verilog/corundum/fpga/lib_rmt/netfpga_fifo/
 
 create_project -name ${design} -force -dir "${proj_dir}" -part ${device}
 set_property source_mgmt_mode DisplayOnly [current_project]
 puts "Creating RMT 512b datawidth simulation"
 
 create_fileset -constrset -quiet constrants
-set_property ip_repo_paths ${public_repo_dir} [current_fileset]
 update_ip_catalog
 
-# dummy
-create_ip -name input_arbiter -vendor NetFPGA -library NetFPGA -module_name input_arbiter_ip
-set_property generate_synth_checkpoint false [get_files input_arbiter_ip.xci]
-reset_target all [get_ips input_arbiter_ip]
-generate_target all [get_ips input_arbiter_ip]
-
 source ./tcl/fifo.tcl
 
 #Add Parser Action RAM IP
@@ -74,18 +66,40 @@
 set_property generate_synth_checkpoint false [get_files page_tbl_16w_32d.xci]
 reset_target all [get_ips page_tbl_16w_32d]
 generate_target all [get_ips page_tbl_16w_32d]
-####################
 
-update_ip_catalog
 
-###
-add_files "./memory_init_files/cam_init_file.mif"
 
-###
-read_vhdl -library cam  ../xilinx_cam/dmem.vhd
-read_vhdl -library cam  [glob ../xilinx_cam/cam*.vhd]
+create_ip -name cam -vendor xilinx.com -library ip -version 2.3 -module_name cam_top
+set_property -dict [list \
+	CONFIG.MODE {CBCAM} \
+	CONFIG.NUM_ENTRIES {16} \
+	CONFIG.KEY_WIDTH {205} \
+	CONFIG.RESP_WIDTH {4} \
+	CONFIG.LOOKUP_RATE {125} \
+	CONFIG.LOOKUP_INTERFACE_FREQ {250} \
+	CONFIG.CLOCKING_MODE {SINGLE CLOCK} \
+] [get_ips cam_top]
+
+# Parametri che non sono riuscito a settare:
+# CONFIG.FLOW_CONTROL {false}
+# CONFIG.PHYSICAL_CONSTRAINTS {false}
+# CONFIG.STATISTIC {false}
+# CONFIG.MEM_TYPE {AUTO}
+# CONFIG.OPTIMIZATION {AUTO}
+# CONFIG.L_MEM_UNITS {AUTO}
+ 
+
+set_property generate_synth_checkpoint false [get_files cam_top.xci]
+reset_target all [get_ips cam_top]
+generate_target all [get_ips cam_top]
+
+
+update_ip_catalog
+####################
 
 # rmt-related
+read_verilog "./fallthrough_small_fifo.v"
+read_verilog "./small_fifo.v"
 read_verilog "./cookie.v"
 read_verilog "./pkt_filter.v"
 read_verilog "./sub_parser.v"
@@ -97,10 +111,10 @@
 read_verilog "./deparser_top.v"
 read_verilog "./depar_do_deparsing.v"
 read_verilog "./depar_wait_segs.v"
-read_verilog "./rmt_wrapper.v"
+read_verilog "./rmt_wrapper.sv"
 read_verilog "./stage.v"
 read_verilog "./last_stage.v"
-read_verilog "./output_arbiter.v"
+#read_verilog "./output_arbiter.v"
 read_verilog "./action/action_engine.v"
 read_verilog "./action/alu_1.v"
 read_verilog "./action/alu_2.v"
@@ -111,13 +125,19 @@
 read_verilog "./lookup/lookup_engine_top.v"
 read_verilog "./lookup/lke_cam_part.v"
 read_verilog "./lookup/lke_ram_part.v"
-###
-read_verilog "./tb/tb_rmt_wrapper.v"
 
-update_compile_order -fileset sources_1
+set_property SOURCE_SET sources_1 [get_filesets sim_1]
+#add_files -fileset sim_1 -norecurse tb/tb_rmt_wrapper.v
+add_files -fileset sim_1 -norecurse tb/tb_rmt_wrapper_calc.sv
+add_files -fileset sim_1 -norecurse tb/tb_rmt_wrapper_drop.sv
+add_files -fileset sim_1 -norecurse tb/tb_rmt_wrapper_modules.sv
+add_files -fileset sim_1 -norecurse tb/tb_rmt_wrapper_stages.sv
+add_files -fileset sim_1 -norecurse tb/tb_rmt_wrapper_moreStages.sv
+add_files -fileset sim_1 -norecurse tb/tb_rmt_wrapper_throughput.sv
+set_property top tb_rmt_wrapper_calc [get_filesets sim_1]
+set_property top_lib xil_defaultlib [get_filesets sim_1]
 update_compile_order -fileset sim_1
 
-set_property top ${sim_top} [get_filesets sim_1]
 set_property include_dirs ${proj_dir} [get_filesets sim_1]
 set_property simulator_language Mixed [current_project]
 set_property verilog_define { {SIMULATION=1} } [get_filesets sim_1]
@@ -140,4 +160,6 @@
 launch_simulation -simset sim_1 -mode behavioral
 run 10us
 
+
+
 exit
